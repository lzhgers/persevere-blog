/*
 Navicat MySQL Data Transfer

 Source Server         : mysql80
 Source Server Type    : MySQL
 Source Server Version : 80027
 Source Host           : localhost:3307
 Source Schema         : lzh-blog

 Target Server Type    : MySQL
 Target Server Version : 80027
 File Encoding         : 65001

 Date: 25/02/2023 09:51:31
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for lzh_article
-- ----------------------------
DROP TABLE IF EXISTS `lzh_article`;
CREATE TABLE `lzh_article`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '标题',
  `html` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT 'html格式文章内容',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '文章内容',
  `summary` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章摘要',
  `category_id` bigint NULL DEFAULT NULL COMMENT '所属分类id',
  `thumbnail` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '缩略图',
  `is_top` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '是否置顶（0否，1是）',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '1' COMMENT '状态（0已发布，1草稿，2下架）',
  `view_count` bigint NULL DEFAULT 0 COMMENT '访问量',
  `collect_count` bigint NULL DEFAULT 0 COMMENT '收藏数',
  `comment_count` bigint UNSIGNED NULL DEFAULT 0 COMMENT '评论数',
  `liked_count` bigint UNSIGNED NULL DEFAULT 0 COMMENT '点赞数',
  `is_comment` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '1' COMMENT '是否允许评论 0否, 1是',
  `create_by` bigint NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `update_by` bigint NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  `del_flag` int NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1628270261736349699 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_article
-- ----------------------------
INSERT INTO `lzh_article` VALUES (2, 'weq1测试', '<h1><a></a>写文章</h1>\n<h2><a></a>离开教室离开房间打卡练腹肌送i</h2>\n<blockquote>\n<p>sfdlkfjsdlkfjslfj</p>\n</blockquote>\n<ul>\n<li>slkdfjlksdfj<br />\nsdfkjlsikdfj<br />\nlkjsdf</li>\n<li>lksjdlkf\n<ul>\n<li>sdfkljsdfkl</li>\n<li>sdfkljdfsl<br />\n<img src=\"https://img0.baidu.com/it/u=1705694933,4002952892&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1676998800&amp;t=4a202c1d1ef3fba758f190534293c005\" alt /><img src=\"http://1.117.218.230:9000/test/img_1676896643445.jpg\" alt=\"nb_d_71.jpg\" /></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>sdfsdf</p>\n</blockquote>\n<h1><a id=\"sdf_20\"></a>sdf</h1>\n', '<h1><a id=\"_0\"></a>写文章</h1>\n<h2><a id=\"i_3\"></a>离开教室离开房间打卡练腹肌送i</h2>\n<blockquote>\n<p>sfdlkfjsdlkfjslfj</p>\n</blockquote>\n<ul>\n<li>slkdfjlksdfj<br />\nsdfkjlsikdfj<br />\nlkjsdf</li>\n<li>lksjdlkf\n<ul>\n<li>sdfkljsdfkl</li>\n<li>sdfkljdfsl<br />\n<img src=\"https://img0.baidu.com/it/u=1705694933,4002952892&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1676998800&amp;t=4a202c1d1ef3fba758f190534293c005\" alt=\"\" /><img src=\"http://1.117.218.230:9000/test/img_1676896643445.jpg\" alt=\"nb_d_71.jpg\" /></li>\n</ul>\n</li>\n</ul>\n\n\n> sdfsdf\n# sdf', 'adad测试中。。。', 16, 'http://1.117.218.230:9000/test/img_1676886037196.jpg', '0', '0', 751, 15, 0, 2, '1', 2, '2022-01-12 14:58:30', 1, '2023-02-22 14:00:50', 0);
INSERT INTO `lzh_article` VALUES (3, 'test2', NULL, 'adadaeqe', 'adad', 2, 'https://img2.baidu.com/it/u=1190700930,2450996716&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800', '1', '0', 67, 2, 0, 2, '0', 2, '2022-01-22 14:58:30', 1, '2023-02-02 14:13:15', 0);
INSERT INTO `lzh_article` VALUES (5, 'test3', '<p>test3</p>\n', 'test3', 'adad', 2, 'https://img2.baidu.com/it/u=231475710,2178882669&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=500', '1', '0', 25, 6, 0, 1, '0', 2, '2022-01-05 14:58:30', 1, '2023-02-22 09:42:08', 0);
INSERT INTO `lzh_article` VALUES (8, 'test4', NULL, 'adadaeqe', 'adad', 2, 'https://img1.baidu.com/it/u=2370824654,1749077762&fm=253&fmt=auto&app=120&f=JPEG?w=660&h=473', '1', '0', 46, 4, 0, 3, '0', 2, '2021-11-21 14:58:30', 1, '2023-02-04 14:41:51', 0);
INSERT INTO `lzh_article` VALUES (9, 'test8', NULL, 'adadaeqe', 'adad', 2, 'https://img2.baidu.com/it/u=3234692665,683388737&fm=253&fmt=auto&app=138&f=JPEG?w=541&h=500', '1', '0', 16, 7, 0, 3, '0', 2, '2022-02-21 14:58:30', 1, '2023-02-04 14:41:48', 0);
INSERT INTO `lzh_article` VALUES (10, 'hello world', NULL, '<p>adadaeqe</p>\n', 'adad', 2, 'https://img2.baidu.com/it/u=3591363530,4004810453&fm=253&fmt=auto&app=120&f=JPEG?w=500&h=313', '1', '0', 11, 5, 0, 2, '0', 2, '2022-01-11 14:58:30', 1, '2023-02-20 20:00:19', 0);
INSERT INTO `lzh_article` VALUES (1576527547464937474, 'SpringBoot测试文章', NULL, '<p>adadaeqe</p>\n', 'adad', 2, 'https://img0.baidu.com/it/u=2204410325,27737494&fm=253&fmt=auto&app=138&f=JPEG?w=700&h=394', '1', '0', 59, 1, 0, 3, '0', 2, '2021-12-19 14:58:30', 1, '2023-02-20 17:44:13', 0);
INSERT INTO `lzh_article` VALUES (1576928390408253442, 'weq', NULL, '<p>adadaeqe</p>\n', 'adad', 2, 'https://img1.baidu.com/it/u=4180444433,235160089&fm=253&fmt=auto&app=120&f=GIF?w=300&h=300', '1', '0', 14, 13, 0, 2, '0', 2, '2022-01-21 14:58:30', 1, '2023-02-21 09:23:21', 0);
INSERT INTO `lzh_article` VALUES (1578333695557947393, 'weq', NULL, 'adadaeqe', 'adad', 2, 'http://rir6wdlzn.hd-bkt.clouddn.com/java.jpg', '1', '0', 2, 74, 0, 2, '0', 2, '2022-01-08 14:58:30', 1, '2022-10-22 18:44:19', 0);
INSERT INTO `lzh_article` VALUES (1579031502224822274, 'weq', NULL, 'adadaeqe', 'adad', 2, 'http://rir6wdlzn.hd-bkt.clouddn.com/java.jpg', '1', '0', 40, 733, 0, 2, '0', 2, '2022-01-18 14:58:30', 1, '2022-10-19 10:56:48', 0);
INSERT INTO `lzh_article` VALUES (1579034777426792450, 'weq', NULL, 'adadaeqe', 'adad', 2, 'http://rir6wdlzn.hd-bkt.clouddn.com/java.jpg', '1', '0', 7, 234, 0, 1, '0', 2, '2022-01-19 14:58:30', 1, '2022-10-13 20:09:43', 0);
INSERT INTO `lzh_article` VALUES (1579035117211553793, 'weq', NULL, 'adadaeqe', 'adad', 2, 'http://rir6wdlzn.hd-bkt.clouddn.com/java.jpg', '1', '0', 9, 35, 0, 3, '0', 2, '2022-01-21 14:58:30', 1, '2022-10-23 19:05:37', 0);
INSERT INTO `lzh_article` VALUES (1579692483556806657, 'weq', NULL, 'adadaeqe', 'adad', 2, 'http://rir6wdlzn.hd-bkt.clouddn.com/java.jpg', '1', '0', 12, 7, 0, 2, '0', 2, '2022-01-21 14:58:30', 1, '2022-10-23 19:05:44', 0);
INSERT INTO `lzh_article` VALUES (1579730661248593922, 'MybatisPlus功能介绍', NULL, '# 测试文章1\n## aaaaaaaa\n## 测试文章2\n### 大师傅士大夫', 'Nihao Shijie', 32, 'http://1.117.218.230:9000/test/java.jpg', '1', '0', 6, 3, 0, 1, '0', 1, '2022-10-11 15:08:34', NULL, '2023-02-02 14:47:23', 0);
INSERT INTO `lzh_article` VALUES (1580001549915234305, 'qqqqqqqqqqqqq', NULL, '# ssssssssssssssssss\n## dddddddddddd\n### cccccccccccc', 'qqqqqqqqqqqqqqqqqq\nqq\n', 15, 'https://img1.baidu.com/it/u=2942287144,2640556279&fm=253&fmt=auto&app=138&f=JPEG?w=667&h=500', '0', '0', 5, 9, 0, 2, '1', 1, '2022-10-12 09:04:59', NULL, '2023-02-04 14:44:18', 0);
INSERT INTO `lzh_article` VALUES (1580002217321168897, 'spring boot', NULL, '# Spring Boot\n## 集成SSM', 'spring boot framework', 15, 'https://img0.baidu.com/it/u=2571470231,3817601587&fm=253&fmt=auto&app=138&f=JPEG?w=281&h=500', '0', '0', 8, 65, 0, 2, '1', 1, '2022-10-12 09:07:38', NULL, '2023-02-04 14:44:24', 0);
INSERT INTO `lzh_article` VALUES (1580003318506323970, 'test article tag table insert', NULL, '# test table tag article', 'test', 2, 'https://img0.baidu.com/it/u=3542797209,312172119&fm=253&fmt=auto&app=138&f=JPEG?w=750&h=422', '0', '0', 22, 765, 0, 2, '1', 1, '2022-10-12 09:12:01', NULL, '2023-02-05 10:21:34', 0);
INSERT INTO `lzh_article` VALUES (1580782348893626370, 'aaaaaaaaaaaa', NULL, '# qqqq\n## 12323321\n>dfsdf\n\n## 2.1 使用jquery\n\n步骤：\n\n1. 需要在你的项目中加入jquery的文件， idea中是把jquery放在webapp目录。一般是创建一个js目录。存放js文件的。 对于hbuilder工具， 放在项目的js目录中就可以了\n\n2. 创建一个html文件或者jsp都可以， 在文件中使用\n\n   ```xml\n   <script type=\"text/javascript\" src=\"jquery的文件的相对路径\" /> 这样是不行的\n   <script type=\"text/javascript\" src=\"jquery的文件的相对路径\" /></script>这样是可以的\n   ```\n\n3. 在js代码中，调用jquery中函数\n\n```javascript\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"utf-8\">\n		<title>第一个jquery例子</title>\n		<script type=\"text/javascript\" src=\"js/jquery-3.4.1.js\"></script>\n		<script type=\"text/javascript\">\n			\n			/*\n			  $:jquery中的函数名\n			  document:是参数\n			  $(document): 把js中的document对象变成jquery可以使用的对象。\n			               然后调用ready()的函数。 这个ready()是jquery中的函数\n						   \n						   ready()的执行时间在页面dom对象加载后执行的。相当于js中onload事件\n					\n			  ready(函数):表示在页面对象加载后执行 这个函数\n			*/\n			/* $(document).ready(function(){\n				alert(\"使用jquery了\")\n			}) */\n			\n			/* $(document).ready( myinit() )\n			function myinit(){\n				alert(\"====相当于onload==\")\n			} */\n			\n			//jquery提供了简单方式,使用ready()\n			//$(  参数是一个函数 )\n			$( function(){\n				alert(\"简单的方式使用ready\")\n			} )\n			\n		</script>\n	</head>\n	<body>\n	</body>\n</html>\n```\n\n## 2.2 对象的分类\n\ndom对象和jquery对象。 在一个文件中同时存在两种对象\n\ndom对象： 使用js的代码获取，创建的对象。  html中的对象都是dom对象。\n\njquery对象： 使用jquery获取获取的对象。\n\n\n\n 为什么要使用dom对象，还有jquery对象？\n\n目的是要dom对象的函数或者属性， 以及使用使用jquery中提供的函数或者属性。 \n\n要 dom中的内容就需要使用dom对象， 要使用jquery函数库中的函数需要使用jquery对象。\n\n\n\ndom对象和jquery对象可以相互转换的\n\n### 2.2.1. dom对象转为jquery对象。\n\n语法： $( dom对象 ) 得到的是一个jquery对象， 可以调用jquery中提供的函数\n\n```javascript\n<input type=\"text\" id=\"t1\" />\n//通过js的函数，获取dom对象\nvar dom= document.getElementById(\"t1\");\n//把dom转为jquery\nvar jqueryObj = $(dom);\n//调用jquery中的函数\njqueryObject.val();//获取dom对象的value属性的值\n\n提示：为了区分dom对象和jquery对象，可以在jquery对象变量名上，加一个$ , 例如 $obj \n```\n\n### 2.2.2 jquery对象转为dom对象。\n\n语法： jquery对象是一个数组， 数组成员是dom对象。 使用 [下标] 或 get(下标)\n\n```javascript\n<input type=\"text\" id=\"txt1\"/>\n使用jquery的方式表示这个dom对象\n$(\"#txt1\"):获取id是txt1的dom对象。 \nvar  obj = $(\"#txt1\"); //obj是一个jquery对象，是一个包含了一个成员的dom数组。  obj[0]就是dom对象\n\nvar dom = obj[0]; 或者 obj.get(0)\n\n//使用dom对象的函数或者属性\nalert(dom.value)\n```\n\n\n\n## 2.3 选择器\n\n什么是选择器： 选择器就是一个字符串， 是一个定位dom对象的字符串。 使用这个字符串作为条件定位dom对象。 可以使用 id ，class样式名称， 标签名称等作为选择器使用，定位dom对象\n\n\n\n### 2.3.1 基本选择器\n\n使用dom对象的id， class名称， 标签名称等作为条件定位dom对象。\n\n1. 使用dom对象的id作为条件\n\n   语法： $(\"#id\")   document.getElementById(\"id\")\n\n   \n\n2. class选择器，使用对象的class名称定位dom对象\n\n   语法：$(\".class名称\")  document.getElementsByClassName()\n\n   \n\n3. 标签选择器，使用标签名称作为条件定位dom对象\n\n   语法：$(\"标签名称\")  document.getElementsByTagName()\n\n   \n\n4. 所有选择器\n\n   语法： $(\"*\")\n\n   \n\n5. 组合选择器\n\n   语法：$(\"#id,.class,标签名称\")\n\n   组合选择器使用 id 或者class名称或者标签名称定位dom对象， id，class，标签名称可以任意组合。\n\n\n\n### 2.3.2 表单选择器', 'ddddddddddddddddddd', 15, 'http://rir6wdlzn.hd-bkt.clouddn.com/2022/10/14/db9dc60a8eee41628cd43e78a814eeeb.jpg', '0', '0', 15, 6, 0, 2, '1', 1, '2022-10-14 12:47:36', NULL, '2023-02-05 10:29:06', 0);
INSERT INTO `lzh_article` VALUES (1580876557625585665, '啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦', NULL, '# 哈哈哈哈哈哈哈哈哈哈哈哈哈哈\n### hhhhh\n> 随便乱写离开家离开家数量的房间里的水库附近的', 'lllllllllllll', 1, 'http://rir6wdlzn.hd-bkt.clouddn.com/2022/10/14/d1ad0e6a6c274b178c2aea1ec85dd95b.jpg', '0', '0', 13, 8, 0, 1, '1', 1578603364453953538, '2022-10-14 19:01:57', NULL, '2022-10-20 13:41:59', 0);
INSERT INTO `lzh_article` VALUES (1581248764574834689, 'Spring框架', NULL, '# Spring开源框架使用介绍\n## Spring的产生便捷了Java的开发\n### 使用介绍\n## Spring的两大核心功能\n* IoC\n* AOP', '框架介绍', 1, 'http://rir6wdlzn.hd-bkt.clouddn.com/2022/10/15/cf69e479718a4882bb2bb457e1aaa813.jpg', '0', '0', 7, 89, 0, 2, '1', 1, '2022-10-15 19:40:58', NULL, '2022-10-25 13:45:41', 0);
INSERT INTO `lzh_article` VALUES (1581491547428610050, '测试草稿发布功能', NULL, '# sddddddddddddddd\n# hello world\n## nihaonihao\n### weileyujianni,wozhenxiziji', '测试发布草稿success', 23, 'http://rkafz00mn.hd-bkt.clouddn.com/2022/10/25/7528d79421db4023b1966b79e4621438.jpg', '0', '0', 9, 55, 0, 1, '1', 1, '2022-10-16 11:45:42', NULL, '2022-10-25 13:45:16', 0);
INSERT INTO `lzh_article` VALUES (1581492165140537345, 'test test article article test', NULL, '<img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2.niutuku.com%2Fdesk%2F1208%2F1300%2Fntk-1300-31979.jpg&refer=http%3A%2F%2Fimg2.niutuku.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1668484073&t=d499ed4c4b3fd5717136d5fa9bfff816\">\n## 测试文章\n> test article', 'welcome article write', 1, '', '0', '1', 28, 1, 0, 1, '1', 1, '2022-10-16 11:48:10', 1, '2022-10-25 16:10:12', 0);
INSERT INTO `lzh_article` VALUES (1581523482204844034, 'test test article article test', NULL, '<img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2.niutuku.com%2Fdesk%2F1208%2F1300%2Fntk-1300-31979.jpg&refer=http%3A%2F%2Fimg2.niutuku.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1668484073&t=d499ed4c4b3fd5717136d5fa9bfff816\">\n## 测试文章\n> test article', 'welcome article write', 1, '', '0', '1', 28, 1, 0, 1, '1', 1, '2022-10-16 11:48:10', 1, '2022-10-25 13:55:06', 0);
INSERT INTO `lzh_article` VALUES (1581523482204844035, 'test test article article test', NULL, '<img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2.niutuku.com%2Fdesk%2F1208%2F1300%2Fntk-1300-31979.jpg&refer=http%3A%2F%2Fimg2.niutuku.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1668484073&t=d499ed4c4b3fd5717136d5fa9bfff816\">\n## 测试文章\n> test article', 'welcome article write', 1, '', '0', '1', 28, 1, 0, 1, '1', 1, '2022-10-16 11:48:10', 1, '2022-10-25 13:26:23', 0);
INSERT INTO `lzh_article` VALUES (1581523482204844036, 'test test article article test', NULL, '<img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2.niutuku.com%2Fdesk%2F1208%2F1300%2Fntk-1300-31979.jpg&refer=http%3A%2F%2Fimg2.niutuku.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1668484073&t=d499ed4c4b3fd5717136d5fa9bfff816\">\n## 测试文章\n> test article', 'welcome article write', 1, '', '0', '1', 28, 1, 0, 1, '1', 1, '2022-10-16 11:48:10', 1, '2022-10-25 11:06:13', 0);
INSERT INTO `lzh_article` VALUES (1581523482204844037, 'test test article article test', NULL, '<img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2.niutuku.com%2Fdesk%2F1208%2F1300%2Fntk-1300-31979.jpg&refer=http%3A%2F%2Fimg2.niutuku.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1668484073&t=d499ed4c4b3fd5717136d5fa9bfff816\">\n## 测试文章\n> test article', 'welcome article write', 1, '', '0', '1', 28, 1, 0, 1, '1', 1, '2022-10-16 11:48:10', 1, '2022-10-25 13:26:53', 0);
INSERT INTO `lzh_article` VALUES (1581523482204844038, 'test test article article test', NULL, '<img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2.niutuku.com%2Fdesk%2F1208%2F1300%2Fntk-1300-31979.jpg&refer=http%3A%2F%2Fimg2.niutuku.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1668484073&t=d499ed4c4b3fd5717136d5fa9bfff816\">\n## 测试文章\n> test article', 'welcome article write', 1, '', '0', '1', 28, 1, 0, 1, '1', 1, '2022-10-16 11:48:10', 1, '2022-10-25 11:17:17', 0);
INSERT INTO `lzh_article` VALUES (1581523482204844039, 'test test article article test', NULL, '<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2.niutuku.com%2Fdesk%2F1208%2F1300%2Fntk-1300-31979.jpg&amp;refer=http%3A%2F%2Fimg2.niutuku.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1668484073&amp;t=d499ed4c4b3fd5717136d5fa9bfff816\" alt=\"\" /> ## 测试文章 &gt; test article</p>\n', 'welcome article write', 1, '', '0', '1', 28, 1, 0, 1, '1', 1, '2022-10-16 11:48:10', 1, '2023-02-20 19:55:22', 0);
INSERT INTO `lzh_article` VALUES (1581523482204844040, 'test test article article test', NULL, '<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2.niutuku.com%2Fdesk%2F1208%2F1300%2Fntk-1300-31979.jpg&amp;refer=http%3A%2F%2Fimg2.niutuku.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1668484073&amp;t=d499ed4c4b3fd5717136d5fa9bfff816\" alt=\"\" /> ## 测试文章 &gt; test article</p>\n', 'welcome article write', 1, '', '0', '1', 28, 1, 0, 1, '1', 1, '2022-10-16 11:48:10', 1, '2023-02-20 20:10:23', 0);
INSERT INTO `lzh_article` VALUES (1584795396985831425, '测试图片上传', NULL, '![合成效果.png]([object Object])', '测试测试', 15, 'http://rkafz00mn.hd-bkt.clouddn.com/2022/10/25/502c0cc419054038b53644ad66a564c1.jpg', '0', '0', 1, 0, 0, 0, '1', 1, '2022-10-25 14:34:01', NULL, '2022-10-25 14:34:36', 0);
INSERT INTO `lzh_article` VALUES (1584804994513879042, '测试文章', NULL, '# sdfsdf\n# sdfsd\n## sdfsdf\n> sdfsdffds\n- sdfsdfdfs\n- s\n- s\n- s\n- ss\n- s\n- ss\n- s\n- sss\n- s\n- s\n- s\n- ss\n- s\n- s\n- s\n- ss\n\n# sdfsdkljfsdlkjfl\n1. sdflkjkfl\n2. a\n3. gglafekds\n4. sdf\n5. ddf\n', 'test article success', 17, 'http://rkafz00mn.hd-bkt.clouddn.com/2022/10/25/01156bfa1d6741d58e745eade589218c.jpg', '0', '0', 1, 0, 0, 0, '1', 1, '2022-10-25 15:12:10', NULL, '2022-11-07 16:19:49', 0);
INSERT INTO `lzh_article` VALUES (1589422745435770881, 'testtesttest', NULL, '# test\n# test\n# test# test\n# test\n# test\n# test\n# test\n# test\n# test\n# test\n# test# test\n# test\n# test\n# test\n# test\n# test\n# test\n# test\n# test# test\n# test\n# test\n# test\n# test\n# test\n# test\n# test\n# test# test\n# test\n# test\n# test\n# test\n# test', '测试测试测试', 2, 'http://rkafz00mn.hd-bkt.clouddn.com/2022/11/07/eb46736334614758a0f382669c4c5e68.jpg', '0', '0', 1, 0, 0, 0, '1', 1, '2022-11-07 09:01:27', NULL, '2022-11-07 16:22:25', 0);
INSERT INTO `lzh_article` VALUES (1589568330876882945, 'javajava', NULL, '```java\npackage com.lzh.common.utils;\n\nimport org.springframework.beans.BeanUtils;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class BeanCopyUtils {\n\n    private BeanCopyUtils() {}\n\n    public static <V> V copyBean(Object source, Class<V> clazz) {\n\n        //创建目标对象\n        V result = null;\n        try {\n            result = clazz.newInstance();\n            //实现属性拷贝\n            BeanUtils.copyProperties(source, result);\n            //返回结果\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        //返回结果\n        return result;\n    }\n\n    public static <O,V> List<V> copyBeanList(List<O> list, Class<V> clazz) {\n        return list.stream()\n                .map(o -> copyBean(o, clazz))\n                .collect(Collectors.toList());\n    }\n\n}\n', NULL, NULL, '', '0', '0', 1, 0, 0, 0, '1', 1, '2022-11-07 18:39:57', NULL, '2022-11-07 18:40:04', 0);
INSERT INTO `lzh_article` VALUES (1589570053100048386, 'lkjlksdjlkjs', NULL, '```java\npackage com.lzh.common.utils;\n\nimport org.springframework.beans.BeanUtils;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class BeanCopyUtils {\n\n    private BeanCopyUtils() {}\n\n    public static <V> V copyBean(Object source, Class<V> clazz) {\n\n        //创建目标对象\n        V result = null;\n        try {\n            result = clazz.newInstance();\n            //实现属性拷贝\n            BeanUtils.copyProperties(source, result);\n            //返回结果\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        //返回结果\n        return result;\n    }\n\n    public static <O,V> List<V> copyBeanList(List<O> list, Class<V> clazz) {\n        return list.stream()\n                .map(o -> copyBean(o, clazz))\n                .collect(Collectors.toList());\n    }\n\n}\n\npackage com.lzh.common.utils;\n\nimport org.springframework.beans.BeanUtils;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class BeanCopyUtils {\n\n    private BeanCopyUtils() {}\n\n    public static <V> V copyBean(Object source, Class<V> clazz) {\n\n        //创建目标对象\n        V result = null;\n        try {\n            result = clazz.newInstance();\n            //实现属性拷贝\n            BeanUtils.copyProperties(source, result);\n            //返回结果\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        //返回结果\n        return result;\n    }\n\n    public static <O,V> List<V> copyBeanList(List<O> list, Class<V> clazz) {\n        return list.stream()\n                .map(o -> copyBean(o, clazz))\n                .collect(Collectors.toList());\n    }\n\n}\n```\n', NULL, NULL, '', '0', '0', 1, 0, 0, 0, '1', 1, '2022-11-07 18:46:48', NULL, '2022-11-07 18:46:53', 0);
INSERT INTO `lzh_article` VALUES (1589570183937167361, 'alkjsdklj', NULL, '```java\npackage com.lzh.common.utils;\n\nimport org.springframework.beans.BeanUtils;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class BeanCopyUtils {\n\n    private BeanCopyUtils() {}\n\n    public static <V> V copyBean(Object source, Class<V> clazz) {\n\n        //创建目标对象\n        V result = null;\n        try {\n            result = clazz.newInstance();\n            //实现属性拷贝\n            BeanUtils.copyProperties(source, result);\n            //返回结果\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        //返回结果\n        return result;\n    }\n\n    public static <O,V> List<V> copyBeanList(List<O> list, Class<V> clazz) {\n        return list.stream()\n                .map(o -> copyBean(o, clazz))\n                .collect(Collectors.toList());\n    }\n\n}\n\npackage com.lzh.common.utils;\n\nimport org.springframework.beans.BeanUtils;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class BeanCopyUtils {\n\n    private BeanCopyUtils() {}\n\n    public static <V> V copyBean(Object source, Class<V> clazz) {\n\n        //创建目标对象\n        V result = null;\n        try {\n            result = clazz.newInstance();\n            //实现属性拷贝\n            BeanUtils.copyProperties(source, result);\n            //返回结果\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        //返回结果\n        return result;\n    }\n\n    public static <O,V> List<V> copyBeanList(List<O> list, Class<V> clazz) {\n        return list.stream()\n                .map(o -> copyBean(o, clazz))\n                .collect(Collectors.toList());\n    }\n\n}\n```', NULL, 1, '', '0', '0', 1, 1, 0, 1, '1', 1, '2022-11-07 18:47:19', NULL, '2022-11-07 18:48:36', 0);
INSERT INTO `lzh_article` VALUES (1589570781973614594, 'ddddddddddd', NULL, 'slkjlfksdf', NULL, 1, '', '0', '0', 1, 0, 0, 0, '1', 1, '2022-11-07 18:49:42', NULL, '2022-11-07 18:51:37', 0);
INSERT INTO `lzh_article` VALUES (1589616657802788866, 'javadaima', NULL, '<p>```java package com.lzh.lzhblog.service.impl; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.lzh.common.domain.ResponseResult; import com.lzh.common.domain.dto.UpdateEmailDTO; import com.lzh.common.domain.dto.UpdatePwdDTO; import com.lzh.common.domain.dto.UserDTO; import com.lzh.common.domain.entity.Article; import com.lzh.common.domain.entity.Subscribe; import com.lzh.common.domain.entity.User; import com.lzh.common.domain.enums.AppHttpCodeEnum; import com.lzh.common.utils.BeanCopyUtils; import com.lzh.common.utils.JwtUtil; import com.lzh.common.utils.RedisCache; import com.lzh.lzhblog.constants.SysConstants; import com.lzh.lzhblog.dao.SubscribeMapper; import com.lzh.lzhblog.dao.UserMapper; import com.lzh.lzhblog.security.LoginUser; import com.lzh.lzhblog.exception.SystemException; import com.lzh.lzhblog.service.ArticleService; import com.lzh.lzhblog.service.UserService; import com.lzh.lzhblog.utils.SecurityUtils; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSender; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.stereotype.Service; import org.springframework.util.StringUtils; import javax.annotation.Resource; import java.util.HashMap; import java.util.Map; import java.util.Objects; import java.util.concurrent.TimeUnit; import static com.lzh.lzhblog.constants.SysConstants.*; /** * 用户表(User)表服务实现类 * * @author makejava * @since 2022-09-26 16:50:18 */ @Slf4j @Service(“userService”) public class UserServiceImpl extends ServiceImpl implements UserService { @Value(&quot;${spring.mail.username}&quot;) private String fromEmail; @Autowired private ArticleService articleService; @Autowired private AuthenticationManager authenticationManager; @Resource private RedisCache redisCache; @Resource private JavaMailSender javaMailSender; @Resource private SubscribeMapper subscribeMapper; @Override public ResponseResult login(User user) { //用户名不能为空 if (!StringUtils.hasText(user.getUserName())) { throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME); } UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if (Objects.isNull(authenticate)) { throw new RuntimeException(“用户名或密码错误”); } LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String token = JwtUtil.createJWT(userId); redisCache.setCacheObject(PRE_LOGIN_USER_REDIS + userId, loginUser, 30, TimeUnit.MINUTES); UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null); SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken); User userInfo = loginUser.getUser(); userInfo.setPassword(&quot;&quot;); Map map = new HashMap&lt;&gt;(); map.put(“token”, token); map.put(“userInfo”, userInfo); return ResponseResult.okResult(map); } @Override public ResponseResult getEmailCode(String email) { //验证码是否已经发送 String emailKey = EMAIL_CODE + email; String emailCode = redisCache.getCacheObject(emailKey); if (StringUtils.hasText(emailCode)) { return ResponseResult.errorResult(309, “验证码已发送”); } //发送验证码 String sendEmailCode = sendCode(email); //将验证码存入redis redisCache.setCacheObject(emailKey, sendEmailCode, 1, TimeUnit.MINUTES); return ResponseResult.okResult(); } @Override public ResponseResult regist(UserDTO userDTO) { if (Objects.isNull(userDTO)) { return ResponseResult.errorResult(303, “注册失败”); } if (!StringUtils.hasText(userDTO.getEmail())) { return ResponseResult.errorResult(304, “邮箱不能为空”); } if (!StringUtils.hasText(userDTO.getPassword())) { return ResponseResult.errorResult(305, “密码不能为空”); } if (!StringUtils.hasText(userDTO.getUserName())) { return ResponseResult.errorResult(306, “用户名不能为空”); } boolean isRegisted = isRegisted(userDTO.getEmail()); if (isRegisted) { return ResponseResult.errorResult(308, “该邮箱已经注册”); } //验证码校验 String redisEmailCode = redisCache.getCacheObject(EMAIL_CODE + userDTO.getEmail()); if (!StringUtils.hasText(redisEmailCode)) { return ResponseResult.errorResult(309, “验证码失效”); } if (!redisEmailCode.equals(userDTO.getCode())) { return ResponseResult.errorResult(310, “验证码输入错误”); } //保存用户信息 User user = BeanCopyUtils.copyBean(userDTO, User.class); user.setPassword(new BCryptPasswordEncoder().encode(user.getPassword())); user.setAvatar(“http://rkafz00mn.hd-bkt.clouddn.com/default.jpg”); save(user); return ResponseResult.okResult(); } @Override public ResponseResult logout() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long userId = loginUser.getUser().getId(); // String userId = SecurityUtils.getUserId().toString(); redisCache.deleteObject(PRE_LOGIN_USER_REDIS + userId); SecurityContextHolder.getContext().setAuthentication(null); return ResponseResult.okResult(); } @Override public User getUserByArticleId(Long articleId) { Article article = articleService.getArticleById(articleId); LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getId, article.getCreateBy()); queryWrapper.eq(User::getStatus, “0”); User user = getOne(queryWrapper); return user; } @Override public User getUserById(Long userId) { LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getStatus, “0”); queryWrapper.eq(User::getId, userId); return getOne(queryWrapper); } @Override public ResponseResult updateUserAvatar(Long userId, String avatar) { User user = User.builder().id(userId).avatar(avatar).build(); getBaseMapper().updateById(user); return ResponseResult.okResult(); } @Override public ResponseResult updatePasswordByUserId(UpdatePwdDTO updatePwdDTO) { User user = getById(updatePwdDTO.getUserId()); //判断用户是否存在 if (Objects.isNull(user)</p>\n', NULL, 15, '', '0', '0', 1, 0, 0, 0, '1', 1, '2022-11-07 21:52:00', NULL, '2023-02-21 09:24:38', 0);
INSERT INTO `lzh_article` VALUES (1589617423766585345, 'lkjlkjlkjllllllllllsssss', NULL, '<p># package com.lzh.lzhblog.service.impl; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.lzh.common.domain.ResponseResult; import com.lzh.common.domain.dto.UpdateEmailDTO; import com.lzh.common.domain.dto.UpdatePwdDTO; import com.lzh.common.domain.dto.UserDTO; import com.lzh.common.domain.entity.Article; import com.lzh.common.domain.entity.Subscribe; import com.lzh.common.domain.entity.User; import com.lzh.common.domain.enums.AppHttpCodeEnum; import com.lzh.common.utils.BeanCopyUtils; import com.lzh.common.utils.JwtUtil; import com.lzh.common.utils.RedisCache; import com.lzh.lzhblog.constants.SysConstants; import com.lzh.lzhblog.dao.SubscribeMapper; import com.lzh.lzhblog.dao.UserMapper; import com.lzh.lzhblog.security.LoginUser; import com.lzh.lzhblog.exception.SystemException; import com.lzh.lzhblog.service.ArticleService; import com.lzh.lzhblog.service.UserService; import com.lzh.lzhblog.utils.SecurityUtils; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSender; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.stereotype.Service; import org.springframework.util.StringUtils; import javax.annotation.Resource; import java.util.HashMap; import java.util.Map; import java.util.Objects; import java.util.concurrent.TimeUnit; import static com.lzh.lzhblog.constants.SysConstants.*; /** * 用户表(User)表服务实现类 * * @author makejava * @since 2022-09-26 16:50:18 */ @Slf4j @Service(“userService”) public class UserServiceImpl extends ServiceImpl implements UserService { @Value(&quot;${spring.mail.username}&quot;) private String fromEmail; @Autowired private ArticleService articleService; @Autowired private AuthenticationManager authenticationManager; @Resource private RedisCache redisCache; @Resource private JavaMailSender javaMailSender; @Resource private SubscribeMapper subscribeMapper; @Override public ResponseResult login(User user) { //用户名不能为空 if (!StringUtils.hasText(user.getUserName())) { throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME); } UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if (Objects.isNull(authenticate)) { throw new RuntimeException(“用户名或密码错误”); } LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String token = JwtUtil.createJWT(userId); redisCache.setCacheObject(PRE_LOGIN_USER_REDIS + userId, loginUser, 30, TimeUnit.MINUTES); UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null); SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken); User userInfo = loginUser.getUser(); userInfo.setPassword(&quot;&quot;); Map map = new HashMap&lt;&gt;(); map.put(“token”, token); map.put(“userInfo”, userInfo); return ResponseResult.okResult(map); } @Override public ResponseResult getEmailCode(String email) { //验证码是否已经发送 String emailKey = EMAIL_CODE + email; String emailCode = redisCache.getCacheObject(emailKey); if (StringUtils.hasText(emailCode)) { return ResponseResult.errorResult(309, “验证码已发送”); } //发送验证码 String sendEmailCode = sendCode(email); //将验证码存入redis redisCache.setCacheObject(emailKey, sendEmailCode, 1, TimeUnit.MINUTES); return ResponseResult.okResult(); } @Override public ResponseResult regist(UserDTO userDTO) { if (Objects.isNull(userDTO)) { return ResponseResult.errorResult(303, “注册失败”); } if (!StringUtils.hasText(userDTO.getEmail())) { return ResponseResult.errorResult(304, “邮箱不能为空”); } if (!StringUtils.hasText(userDTO.getPassword())) { return ResponseResult.errorResult(305, “密码不能为空”); } if (!StringUtils.hasText(userDTO.getUserName())) { return ResponseResult.errorResult(306, “用户名不能为空”); } boolean isRegisted = isRegisted(userDTO.getEmail()); if (isRegisted) { return ResponseResult.errorResult(308, “该邮箱已经注册”); } //验证码校验 String redisEmailCode = redisCache.getCacheObject(EMAIL_CODE + userDTO.getEmail()); if (!StringUtils.hasText(redisEmailCode)) { return ResponseResult.errorResult(309, “验证码失效”); } if (!redisEmailCode.equals(userDTO.getCode())) { return ResponseResult.errorResult(310, “验证码输入错误”); } //保存用户信息 User user = BeanCopyUtils.copyBean(userDTO, User.class); user.setPassword(new BCryptPasswordEncoder().encode(user.getPassword())); user.setAvatar(“http://rkafz00mn.hd-bkt.clouddn.com/default.jpg”); save(user); return ResponseResult.okResult(); } @Override public ResponseResult logout() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long userId = loginUser.getUser().getId(); // String userId = SecurityUtils.getUserId().toString(); redisCache.deleteObject(PRE_LOGIN_USER_REDIS + userId); SecurityContextHolder.getContext().setAuthentication(null); return ResponseResult.okResult(); } @Override public User getUserByArticleId(Long articleId) { Article article = articleService.getArticleById(articleId); LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getId, article.getCreateBy()); queryWrapper.eq(User::getStatus, “0”); User user = getOne(queryWrapper); return user; } @Override public User getUserById(Long userId) { LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getStatus, “0”); queryWrapper.eq(User::getId, userId); return getOne(queryWrapper); } @Override public ResponseResult updateUserAvatar(Long userId, String avatar) { User user = User.builder().id(userId).avatar(avatar).build(); getBaseMapper().updateById(user); return ResponseResult.okResult(); } @Override public ResponseResult updatePasswordByUserId(UpdatePwdDTO updatePwdDTO) { User user = getById(updatePwdDTO.getUserId()); //判断用户是否存在 if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } //校验当前密码 BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); if (!encoder.matches(updatePwdDTO.getCurPassword(), user.getPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.CUR_PASSWORD_ERROR); } //判断两次密码输入是否正确 if (!updatePwdDTO.getNewPassword().equals(updatePwdDTO.getConPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.NEW_CON_PASSWORD_NOT_MATCH); } //校验修改的密码是否为原密码 if (encoder.matches(updatePwdDTO.getNewPassword(), user.getPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.NEW_PASSWORD_REPEAT); } //更新密码 String newPwdEncode = encoder.encode(updatePwdDTO.getNewPassword()); user.setPassword(newPwdEncode); updateById(user); return ResponseResult.okResult(); } @Override public ResponseResult getUpdateEmailCode(UpdateEmailDTO updateEmailDTO) { User user = getById(updateEmailDTO.getUserId()); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); if (!passwordEncoder.matches(updateEmailDTO.getCurPassword(), user.getPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.CUR_PASSWORD_ERROR); } if (!user.getEmail().equals(updateEmailDTO.getEmail())) { return ResponseResult.errorResult(AppHttpCodeEnum.EMAIL_ERROR); } SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setFrom(fromEmail); mailMessage.setTo(updateEmailDTO.getEmail()); mailMessage.setSubject(“PERSEVERE BLOG 账号验证”); int sendEmailCode = (int) (Math.random() * ((999999 - 100000 + 1) + 100000)); log.info(“发送更新邮箱验证码-----------” + sendEmailCode); String context = &quot;账号验证码为: &quot; + sendEmailCode + “,一分钟内有效，请妥善保管!”; mailMessage.setText(context); javaMailSender.send(mailMessage); //保存到redis redisCache.setCacheObject(EMAIL_UPDATE + updateEmailDTO.getEmail(), sendEmailCode + “”, 1, TimeUnit.MINUTES); return ResponseResult.okResult(sendEmailCode + “”); } @Override public ResponseResult checkCode(String code, String email) { String emailUpdateCode = redisCache.getCacheObject(EMAIL_UPDATE + email); if (!StringUtils.hasText(emailUpdateCode)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE); } if (!emailUpdateCode.equals(code)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR); } return ResponseResult.okResult(); } @Override public ResponseResult getNewEmailCode(UpdateEmailDTO updateEmailDTO) { String code = sendEmailCode(updateEmailDTO.getEmail(), “PERSEVERE BLOG 新邮箱验证”, “验证码为：”); log.info(“新邮箱验证码----------------” + code); //保存到redis redisCache.setCacheObject(NEW_EMAIL_CODE + updateEmailDTO.getEmail(), code, 1, TimeUnit.MINUTES); return ResponseResult.okResult(); } @Override public ResponseResult finishEmailUpdate(UpdateEmailDTO updateEmailDTO) { String email = updateEmailDTO.getEmail(); //校验验证码 String code = redisCache.getCacheObject(NEW_EMAIL_CODE + email); if (!StringUtils.hasText(code)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE); } if (!code.equals(updateEmailDTO.getCode())) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR); } //更新用户邮箱 User user = User.builder().id(updateEmailDTO.getUserId()).email(updateEmailDTO.getEmail()).build(); updateById(user); return ResponseResult.okResult(); } @Override public ResponseResult checkEmail(UserDTO user) { String email = user.getEmail(); LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getEmail, email); User one = getOne(queryWrapper); if (Objects.isNull(one)) { return ResponseResult.errorResult(AppHttpCodeEnum.EMAIL_NOT_EXIT); } return ResponseResult.okResult(); } @Override public ResponseResult getRePasswordCode(String email) { String code = sendEmailCode(email, “PERSEVERE BLOG 找回密码 邮箱验证”, “验证码为：”); log.info(“找回密码，邮箱验证码----------------” + code); //保存到redis redisCache.setCacheObject(SysConstants.GET_PWD_CODE + email, code, 1, TimeUnit.MINUTES); return ResponseResult.okResult(); } @Override public ResponseResult rePassword(String email, String newPassword, String conPassword) { LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getEmail, email); User user = getOne(queryWrapper); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } if (!newPassword.equals(conPassword)) { return ResponseResult.errorResult(AppHttpCodeEnum.NEW_CON_PASSWORD_NOT_MATCH); } LambdaQueryWrapper queryWrapper1 = new LambdaQueryWrapper&lt;&gt;(); queryWrapper1.eq(User::getEmail, email); BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encode = passwordEncoder.encode(conPassword); User user1 = new User(); user1.setPassword(encode); update(user1, queryWrapper1); return ResponseResult.okResult(); } @Override public ResponseResult checkRePwdCode(String email, String code) { String value = redisCache.getCacheObject(GET_PWD_CODE + email); if (!StringUtils.hasText(value)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE); } if (!code.equals(value)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR); } return ResponseResult.okResult(); } @Override public ResponseResult cancelAccount(Long userId) { User user = getById(userId); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } removeById(userId); return ResponseResult.okResult(); } @Override public ResponseResult checkPassword(UserDTO userDTO) { User user = getById(userDTO.getId()); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); if (!passwordEncoder.matches(userDTO.getPassword(), user.getPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.CUR_PASSWORD_ERROR); } return ResponseResult.okResult(); } @Override public ResponseResult getCancelEmailCode(UserDTO userDTO) { User user = getById(userDTO.getId()); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_LOGIN); } String emailCode = sendEmailCode(userDTO.getEmail(), “PERSEVERE BLOG 注销账号验证”, “账号验证码为:”); redisCache.setCacheObject(SysConstants.ACCOUNT_CANCEL + user.getEmail(), emailCode, 1, TimeUnit.MINUTES); return ResponseResult.okResult(); } @Override public ResponseResult checkCancelEmailCode(UserDTO userDTO) { String code = redisCache.getCacheObject(ACCOUNT_CANCEL + userDTO.getEmail()); if (!StringUtils.hasText(code)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE); } if (!code.equals(userDTO.getCode())) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR); } return ResponseResult.okResult(); } @Override public Boolean isSubscribed(Long userId) { try { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long uid = loginUser.getUser().getId(); LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(Subscribe::getBeSubscribe, userId); queryWrapper.eq(Subscribe::getSubscribe, uid); Subscribe subscribe = subscribeMapper.selectOne(queryWrapper); if (Objects.isNull(subscribe)) { return false; } return true; } catch (Exception e) { return false; } } private String sendCode(String email) { SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setFrom(fromEmail); mailMessage.setTo(email); mailMessage.setSubject(“PERSEVERE BLOG”); int sendEmailCode = (int) (Math.random() * ((999999 - 100000 + 1) + 100000)); String context = &quot;注册验证码为: &quot; + sendEmailCode + “,一分钟内有效，请妥善保管!”; mailMessage.setText(context); javaMailSender.send(mailMessage); return sendEmailCode + “”; } private boolean isRegisted(String email) { LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getEmail, email); User user = getOne(queryWrapper); if (Objects.isNull(user)) { return false; } return true; } private String sendEmailCode(String email, String subject, String preContext) { SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setFrom(fromEmail); mailMessage.setTo(email); mailMessage.setSubject(subject); int sendEmailCode = (int) (Math.random() * ((999999 - 100000 + 1) + 100000)); log.info(“发送邮箱验证码-----------” + sendEmailCode); String context = preContext + sendEmailCode + “,一分钟内有效，请妥善保管!”; mailMessage.setText(context); javaMailSender.send(mailMessage); return sendEmailCode + “”; } }</p>\n', NULL, 1, '', '0', '0', 1, 0, 0, 0, '1', 1, '2022-11-07 21:55:02', NULL, '2023-02-21 09:24:14', 0);
INSERT INTO `lzh_article` VALUES (1589617612757729282, 'sssssssssssdfsdfxcvxcvxcv', NULL, '<p>package com.lzh.lzhblog.service.impl; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.lzh.common.domain.ResponseResult; import com.lzh.common.domain.dto.UpdateEmailDTO; import com.lzh.common.domain.dto.UpdatePwdDTO; import com.lzh.common.domain.dto.UserDTO; import com.lzh.common.domain.entity.Article; import com.lzh.common.domain.entity.Subscribe; import com.lzh.common.domain.entity.User; import com.lzh.common.domain.enums.AppHttpCodeEnum; import com.lzh.common.utils.BeanCopyUtils; import com.lzh.common.utils.JwtUtil; import com.lzh.common.utils.RedisCache; import com.lzh.lzhblog.constants.SysConstants; import com.lzh.lzhblog.dao.SubscribeMapper; import com.lzh.lzhblog.dao.UserMapper; import com.lzh.lzhblog.security.LoginUser; import com.lzh.lzhblog.exception.SystemException; import com.lzh.lzhblog.service.ArticleService; import com.lzh.lzhblog.service.UserService; import com.lzh.lzhblog.utils.SecurityUtils; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSender; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.stereotype.Service; import org.springframework.util.StringUtils; import javax.annotation.Resource; import java.util.HashMap; import java.util.Map; import java.util.Objects; import java.util.concurrent.TimeUnit; import static com.lzh.lzhblog.constants.SysConstants.*; /** * 用户表(User)表服务实现类 * * @author makejava * @since 2022-09-26 16:50:18 */ @Slf4j @Service(“userService”) public class UserServiceImpl extends ServiceImpl implements UserService { @Value(&quot;${spring.mail.username}&quot;) private String fromEmail; @Autowired private ArticleService articleService; @Autowired private AuthenticationManager authenticationManager; @Resource private RedisCache redisCache; @Resource private JavaMailSender javaMailSender; @Resource private SubscribeMapper subscribeMapper; @Override public ResponseResult login(User user) { //用户名不能为空 if (!StringUtils.hasText(user.getUserName())) { throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME); } UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if (Objects.isNull(authenticate)) { throw new RuntimeException(“用户名或密码错误”); } LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String token = JwtUtil.createJWT(userId); redisCache.setCacheObject(PRE_LOGIN_USER_REDIS + userId, loginUser, 30, TimeUnit.MINUTES); UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null); SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken); User userInfo = loginUser.getUser(); userInfo.setPassword(&quot;&quot;); Map map = new HashMap&lt;&gt;(); map.put(“token”, token); map.put(“userInfo”, userInfo); return ResponseResult.okResult(map); } @Override public ResponseResult getEmailCode(String email) { //验证码是否已经发送 String emailKey = EMAIL_CODE + email; String emailCode = redisCache.getCacheObject(emailKey); if (StringUtils.hasText(emailCode)) { return ResponseResult.errorResult(309, “验证码已发送”); } //发送验证码 String sendEmailCode = sendCode(email); //将验证码存入redis redisCache.setCacheObject(emailKey, sendEmailCode, 1, TimeUnit.MINUTES); return ResponseResult.okResult(); } @Override public ResponseResult regist(UserDTO userDTO) { if (Objects.isNull(userDTO)) { return ResponseResult.errorResult(303, “注册失败”); } if (!StringUtils.hasText(userDTO.getEmail())) { return ResponseResult.errorResult(304, “邮箱不能为空”); } if (!StringUtils.hasText(userDTO.getPassword())) { return ResponseResult.errorResult(305, “密码不能为空”); } if (!StringUtils.hasText(userDTO.getUserName())) { return ResponseResult.errorResult(306, “用户名不能为空”); } boolean isRegisted = isRegisted(userDTO.getEmail()); if (isRegisted) { return ResponseResult.errorResult(308, “该邮箱已经注册”); } //验证码校验 String redisEmailCode = redisCache.getCacheObject(EMAIL_CODE + userDTO.getEmail()); if (!StringUtils.hasText(redisEmailCode)) { return ResponseResult.errorResult(309, “验证码失效”); } if (!redisEmailCode.equals(userDTO.getCode())) { return ResponseResult.errorResult(310, “验证码输入错误”); } //保存用户信息 User user = BeanCopyUtils.copyBean(userDTO, User.class); user.setPassword(new BCryptPasswordEncoder().encode(user.getPassword())); user.setAvatar(“http://rkafz00mn.hd-bkt.clouddn.com/default.jpg”); save(user); return ResponseResult.okResult(); } @Override public ResponseResult logout() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long userId = loginUser.getUser().getId(); // String userId = SecurityUtils.getUserId().toString(); redisCache.deleteObject(PRE_LOGIN_USER_REDIS + userId); SecurityContextHolder.getContext().setAuthentication(null); return ResponseResult.okResult(); } @Override public User getUserByArticleId(Long articleId) { Article article = articleService.getArticleById(articleId); LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getId, article.getCreateBy()); queryWrapper.eq(User::getStatus, “0”); User user = getOne(queryWrapper); return user; } @Override public User getUserById(Long userId) { LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getStatus, “0”); queryWrapper.eq(User::getId, userId); return getOne(queryWrapper); } @Override public ResponseResult updateUserAvatar(Long userId, String avatar) { User user = User.builder().id(userId).avatar(avatar).build(); getBaseMapper().updateById(user); return ResponseResult.okResult(); } @Override public ResponseResult updatePasswordByUserId(UpdatePwdDTO updatePwdDTO) { User user = getById(updatePwdDTO.getUserId()); //判断用户是否存在 if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } //校验当前密码 BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); if (!encoder.matches(updatePwdDTO.getCurPassword(), user.getPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.CUR_PASSWORD_ERROR); } //判断两次密码输入是否正确 if (!updatePwdDTO.getNewPassword().equals(updatePwdDTO.getConPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.NEW_CON_PASSWORD_NOT_MATCH); } //校验修改的密码是否为原密码 if (encoder.matches(updatePwdDTO.getNewPassword(), user.getPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.NEW_PASSWORD_REPEAT); } //更新密码 String newPwdEncode = encoder.encode(updatePwdDTO.getNewPassword()); user.setPassword(newPwdEncode); updateById(user); return ResponseResult.okResult(); } @Override public ResponseResult getUpdateEmailCode(UpdateEmailDTO updateEmailDTO) { User user = getById(updateEmailDTO.getUserId()); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); if (!passwordEncoder.matches(updateEmailDTO.getCurPassword(), user.getPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.CUR_PASSWORD_ERROR); } if (!user.getEmail().equals(updateEmailDTO.getEmail())) { return ResponseResult.errorResult(AppHttpCodeEnum.EMAIL_ERROR); } SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setFrom(fromEmail); mailMessage.setTo(updateEmailDTO.getEmail()); mailMessage.setSubject(“PERSEVERE BLOG 账号验证”); int sendEmailCode = (int) (Math.random() * ((999999 - 100000 + 1) + 100000)); log.info(“发送更新邮箱验证码-----------” + sendEmailCode); String context = &quot;账号验证码为: &quot; + sendEmailCode + “,一分钟内有效，请妥善保管!”; mailMessage.setText(context); javaMailSender.send(mailMessage); //保存到redis redisCache.setCacheObject(EMAIL_UPDATE + updateEmailDTO.getEmail(), sendEmailCode + “”, 1, TimeUnit.MINUTES); return ResponseResult.okResult(sendEmailCode + “”); } @Override public ResponseResult checkCode(String code, String email) { String emailUpdateCode = redisCache.getCacheObject(EMAIL_UPDATE + email); if (!StringUtils.hasText(emailUpdateCode)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE); } if (!emailUpdateCode.equals(code)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR); } return ResponseResult.okResult(); } @Override public ResponseResult getNewEmailCode(UpdateEmailDTO updateEmailDTO) { String code = sendEmailCode(updateEmailDTO.getEmail(), “PERSEVERE BLOG 新邮箱验证”, “验证码为：”); log.info(“新邮箱验证码----------------” + code); //保存到redis redisCache.setCacheObject(NEW_EMAIL_CODE + updateEmailDTO.getEmail(), code, 1, TimeUnit.MINUTES); return ResponseResult.okResult(); } @Override public ResponseResult finishEmailUpdate(UpdateEmailDTO updateEmailDTO) { String email = updateEmailDTO.getEmail(); //校验验证码 String code = redisCache.getCacheObject(NEW_EMAIL_CODE + email); if (!StringUtils.hasText(code)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE); } if (!code.equals(updateEmailDTO.getCode())) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR); } //更新用户邮箱 User user = User.builder().id(updateEmailDTO.getUserId()).email(updateEmailDTO.getEmail()).build(); updateById(user); return ResponseResult.okResult(); } @Override public ResponseResult checkEmail(UserDTO user) { String email = user.getEmail(); LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getEmail, email); User one = getOne(queryWrapper); if (Objects.isNull(one)) { return ResponseResult.errorResult(AppHttpCodeEnum.EMAIL_NOT_EXIT); } return ResponseResult.okResult(); } @Override public ResponseResult getRePasswordCode(String email) { String code = sendEmailCode(email, “PERSEVERE BLOG 找回密码 邮箱验证”, “验证码为：”); log.info(“找回密码，邮箱验证码----------------” + code); //保存到redis redisCache.setCacheObject(SysConstants.GET_PWD_CODE + email, code, 1, TimeUnit.MINUTES); return ResponseResult.okResult(); } @Override public ResponseResult rePassword(String email, String newPassword, String conPassword) { LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getEmail, email); User user = getOne(queryWrapper); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } if (!newPassword.equals(conPassword)) { return ResponseResult.errorResult(AppHttpCodeEnum.NEW_CON_PASSWORD_NOT_MATCH); } LambdaQueryWrapper queryWrapper1 = new LambdaQueryWrapper&lt;&gt;(); queryWrapper1.eq(User::getEmail, email); BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encode = passwordEncoder.encode(conPassword); User user1 = new User(); user1.setPassword(encode); update(user1, queryWrapper1); return ResponseResult.okResult(); } @Override public ResponseResult checkRePwdCode(String email, String code) { String value = redisCache.getCacheObject(GET_PWD_CODE + email); if (!StringUtils.hasText(value)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE); } if (!code.equals(value)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR); } return ResponseResult.okResult(); } @Override public ResponseResult cancelAccount(Long userId) { User user = getById(userId); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } removeById(userId); return ResponseResult.okResult(); } @Override public ResponseResult checkPassword(UserDTO userDTO) { User user = getById(userDTO.getId()); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT); } BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); if (!passwordEncoder.matches(userDTO.getPassword(), user.getPassword())) { return ResponseResult.errorResult(AppHttpCodeEnum.CUR_PASSWORD_ERROR); } return ResponseResult.okResult(); } @Override public ResponseResult getCancelEmailCode(UserDTO userDTO) { User user = getById(userDTO.getId()); if (Objects.isNull(user)) { return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_LOGIN); } String emailCode = sendEmailCode(userDTO.getEmail(), “PERSEVERE BLOG 注销账号验证”, “账号验证码为:”); redisCache.setCacheObject(SysConstants.ACCOUNT_CANCEL + user.getEmail(), emailCode, 1, TimeUnit.MINUTES); return ResponseResult.okResult(); } @Override public ResponseResult checkCancelEmailCode(UserDTO userDTO) { String code = redisCache.getCacheObject(ACCOUNT_CANCEL + userDTO.getEmail()); if (!StringUtils.hasText(code)) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE); } if (!code.equals(userDTO.getCode())) { return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR); } return ResponseResult.okResult(); } @Override public Boolean isSubscribed(Long userId) { try { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long uid = loginUser.getUser().getId(); LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(Subscribe::getBeSubscribe, userId); queryWrapper.eq(Subscribe::getSubscribe, uid); Subscribe subscribe = subscribeMapper.selectOne(queryWrapper); if (Objects.isNull(subscribe)) { return false; } return true; } catch (Exception e) { return false; } } private String sendCode(String email) { SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setFrom(fromEmail); mailMessage.setTo(email); mailMessage.setSubject(“PERSEVERE BLOG”); int sendEmailCode = (int) (Math.random() * ((999999 - 100000 + 1) + 100000)); String context = &quot;注册验证码为: &quot; + sendEmailCode + “,一分钟内有效，请妥善保管!”; mailMessage.setText(context); javaMailSender.send(mailMessage); return sendEmailCode + “”; } private boolean isRegisted(String email) { LambdaQueryWrapper queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getEmail, email); User user = getOne(queryWrapper); if (Objects.isNull(user)) { return false; } return true; } private String sendEmailCode(String email, String subject, String preContext) { SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setFrom(fromEmail); mailMessage.setTo(email); mailMessage.setSubject(subject); int sendEmailCode = (int) (Math.random() * ((999999 - 100000 + 1) + 100000)); log.info(“发送邮箱验证码-----------” + sendEmailCode); String context = preContext + sendEmailCode + “,一分钟内有效，请妥善保管!”; mailMessage.setText(context); javaMailSender.send(mailMessage); return sendEmailCode + “”; } }</p>\n', NULL, 2, 'http://1.117.218.230:9000/test/img_1676894463650.png', '0', '0', 1, 0, 0, 0, '1', 1, '2022-11-07 21:55:47', NULL, '2023-02-20 20:01:07', 0);
INSERT INTO `lzh_article` VALUES (1589618311344226306, 'eeeeeeeeeeeee', NULL, '<p>dfsdfsdfdsdfsdfsdfd</p>\n', NULL, 16, 'http://1.117.218.230:9000/test/img_1676895581415.png', '0', '0', 1, 0, 0, 0, '1', 1, '2022-11-07 21:58:34', NULL, '2023-02-20 20:19:48', 0);
INSERT INTO `lzh_article` VALUES (1589618524242935810, 'qqqqqqqqqqqqqqqqqqqqqqqqq', NULL, 'package com.lzh.lzhblog.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.lzh.common.domain.ResponseResult;\nimport com.lzh.common.domain.dto.UpdateEmailDTO;\nimport com.lzh.common.domain.dto.UpdatePwdDTO;\nimport com.lzh.common.domain.dto.UserDTO;\nimport com.lzh.common.domain.entity.Article;\nimport com.lzh.common.domain.entity.Subscribe;\nimport com.lzh.common.domain.entity.User;\nimport com.lzh.common.domain.enums.AppHttpCodeEnum;\nimport com.lzh.common.utils.BeanCopyUtils;\nimport com.lzh.common.utils.JwtUtil;\nimport com.lzh.common.utils.RedisCache;\nimport com.lzh.lzhblog.constants.SysConstants;\nimport com.lzh.lzhblog.dao.SubscribeMapper;\nimport com.lzh.lzhblog.dao.UserMapper;\nimport com.lzh.lzhblog.security.LoginUser;\nimport com.lzh.lzhblog.exception.SystemException;\nimport com.lzh.lzhblog.service.ArticleService;\nimport com.lzh.lzhblog.service.UserService;\nimport com.lzh.lzhblog.utils.SecurityUtils;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.StringUtils;\n\nimport javax.annotation.Resource;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.lzh.lzhblog.constants.SysConstants.*;\n\n/**\n * 用户表(User)表服务实现类\n *\n * @author makejava\n * @since 2022-09-26 16:50:18\n */\n@Slf4j\n@Service(\"userService\")\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {\n\n    @Value(\"${spring.mail.username}\")\n    private String fromEmail;\n\n    @Autowired\n    private ArticleService articleService;\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Resource\n    private RedisCache redisCache;\n\n    @Resource\n    private JavaMailSender javaMailSender;\n\n    @Resource\n    private SubscribeMapper subscribeMapper;\n\n    @Override\n    public ResponseResult login(User user) {\n        //用户名不能为空\n        if (!StringUtils.hasText(user.getUserName())) {\n            throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME);\n        }\n\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword());\n\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\n\n        if (Objects.isNull(authenticate)) {\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        String userId = loginUser.getUser().getId().toString();\n        String token = JwtUtil.createJWT(userId);\n\n        redisCache.setCacheObject(PRE_LOGIN_USER_REDIS + userId, loginUser, 30, TimeUnit.MINUTES);\n\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken =\n                new UsernamePasswordAuthenticationToken(loginUser, null, null);\n        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);\n\n        User userInfo = loginUser.getUser();\n        userInfo.setPassword(\"\");\n\n\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"token\", token);\n        map.put(\"userInfo\", userInfo);\n\n        return ResponseResult.okResult(map);\n    }\n\n    @Override\n    public ResponseResult getEmailCode(String email) {\n\n        //验证码是否已经发送\n        String emailKey = EMAIL_CODE + email;\n        String emailCode = redisCache.getCacheObject(emailKey);\n        if (StringUtils.hasText(emailCode)) {\n            return ResponseResult.errorResult(309, \"验证码已发送\");\n        }\n\n        //发送验证码\n        String sendEmailCode = sendCode(email);\n\n        //将验证码存入redis\n        redisCache.setCacheObject(emailKey, sendEmailCode, 1, TimeUnit.MINUTES);\n\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult regist(UserDTO userDTO) {\n        if (Objects.isNull(userDTO)) {\n            return ResponseResult.errorResult(303, \"注册失败\");\n        }\n        if (!StringUtils.hasText(userDTO.getEmail())) {\n            return ResponseResult.errorResult(304, \"邮箱不能为空\");\n        }\n        if (!StringUtils.hasText(userDTO.getPassword())) {\n            return ResponseResult.errorResult(305, \"密码不能为空\");\n        }\n        if (!StringUtils.hasText(userDTO.getUserName())) {\n            return ResponseResult.errorResult(306, \"用户名不能为空\");\n        }\n\n        boolean isRegisted = isRegisted(userDTO.getEmail());\n        if (isRegisted) {\n            return ResponseResult.errorResult(308, \"该邮箱已经注册\");\n        }\n\n        //验证码校验\n        String redisEmailCode = redisCache.getCacheObject(EMAIL_CODE + userDTO.getEmail());\n        if (!StringUtils.hasText(redisEmailCode)) {\n            return ResponseResult.errorResult(309, \"验证码失效\");\n        }\n        if (!redisEmailCode.equals(userDTO.getCode())) {\n            return ResponseResult.errorResult(310, \"验证码输入错误\");\n        }\n\n        //保存用户信息\n        User user = BeanCopyUtils.copyBean(userDTO, User.class);\n        user.setPassword(new BCryptPasswordEncoder().encode(user.getPassword()));\n        user.setAvatar(\"http://rkafz00mn.hd-bkt.clouddn.com/default.jpg\");\n        save(user);\n\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult logout() {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        Long userId = loginUser.getUser().getId();\n//        String userId = SecurityUtils.getUserId().toString();\n\n        redisCache.deleteObject(PRE_LOGIN_USER_REDIS + userId);\n        SecurityContextHolder.getContext().setAuthentication(null);\n\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public User getUserByArticleId(Long articleId) {\n        Article article = articleService.getArticleById(articleId);\n\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        queryWrapper.eq(User::getId, article.getCreateBy());\n        queryWrapper.eq(User::getStatus, \"0\");\n\n        User user = getOne(queryWrapper);\n        return user;\n    }\n\n    @Override\n    public User getUserById(Long userId) {\n\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        queryWrapper.eq(User::getStatus, \"0\");\n        queryWrapper.eq(User::getId, userId);\n        return getOne(queryWrapper);\n    }\n\n    @Override\n    public ResponseResult updateUserAvatar(Long userId, String avatar) {\n        User user = User.builder().id(userId).avatar(avatar).build();\n        getBaseMapper().updateById(user);\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult updatePasswordByUserId(UpdatePwdDTO updatePwdDTO) {\n        User user = getById(updatePwdDTO.getUserId());\n        //判断用户是否存在\n        if (Objects.isNull(user)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT);\n        }\n        //校验当前密码\n        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();\n\n        if (!encoder.matches(updatePwdDTO.getCurPassword(), user.getPassword())) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CUR_PASSWORD_ERROR);\n        }\n        //判断两次密码输入是否正确\n        if (!updatePwdDTO.getNewPassword().equals(updatePwdDTO.getConPassword())) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.NEW_CON_PASSWORD_NOT_MATCH);\n        }\n\n        //校验修改的密码是否为原密码\n        if (encoder.matches(updatePwdDTO.getNewPassword(), user.getPassword())) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.NEW_PASSWORD_REPEAT);\n        }\n\n        //更新密码\n        String newPwdEncode = encoder.encode(updatePwdDTO.getNewPassword());\n        user.setPassword(newPwdEncode);\n        updateById(user);\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult getUpdateEmailCode(UpdateEmailDTO updateEmailDTO) {\n\n        User user = getById(updateEmailDTO.getUserId());\n        if (Objects.isNull(user)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT);\n        }\n        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();\n        if (!passwordEncoder.matches(updateEmailDTO.getCurPassword(), user.getPassword())) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CUR_PASSWORD_ERROR);\n        }\n        if (!user.getEmail().equals(updateEmailDTO.getEmail())) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.EMAIL_ERROR);\n        }\n\n        SimpleMailMessage mailMessage = new SimpleMailMessage();\n        mailMessage.setFrom(fromEmail);\n        mailMessage.setTo(updateEmailDTO.getEmail());\n        mailMessage.setSubject(\"PERSEVERE BLOG 账号验证\");\n        int sendEmailCode = (int) (Math.random() * ((999999 - 100000 + 1) + 100000));\n        log.info(\"发送更新邮箱验证码-----------\" + sendEmailCode);\n        String context = \"账号验证码为: \" + sendEmailCode + \",一分钟内有效，请妥善保管!\";\n        mailMessage.setText(context);\n        javaMailSender.send(mailMessage);\n\n        //保存到redis\n        redisCache.setCacheObject(EMAIL_UPDATE + updateEmailDTO.getEmail(), sendEmailCode + \"\", 1, TimeUnit.MINUTES);\n\n        return ResponseResult.okResult(sendEmailCode + \"\");\n    }\n\n    @Override\n    public ResponseResult checkCode(String code, String email) {\n        String emailUpdateCode = redisCache.getCacheObject(EMAIL_UPDATE + email);\n        if (!StringUtils.hasText(emailUpdateCode)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE);\n        }\n        if (!emailUpdateCode.equals(code)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR);\n        }\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult getNewEmailCode(UpdateEmailDTO updateEmailDTO) {\n        String code = sendEmailCode(updateEmailDTO.getEmail(), \"PERSEVERE BLOG 新邮箱验证\", \"验证码为：\");\n        log.info(\"新邮箱验证码----------------\" + code);\n\n        //保存到redis\n        redisCache.setCacheObject(NEW_EMAIL_CODE + updateEmailDTO.getEmail(), code, 1, TimeUnit.MINUTES);\n\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult finishEmailUpdate(UpdateEmailDTO updateEmailDTO) {\n\n        String email = updateEmailDTO.getEmail();\n        //校验验证码\n        String code = redisCache.getCacheObject(NEW_EMAIL_CODE + email);\n        if (!StringUtils.hasText(code)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE);\n        }\n        if (!code.equals(updateEmailDTO.getCode())) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR);\n        }\n        //更新用户邮箱\n        User user = User.builder().id(updateEmailDTO.getUserId()).email(updateEmailDTO.getEmail()).build();\n        updateById(user);\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult checkEmail(UserDTO user) {\n        String email = user.getEmail();\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        queryWrapper.eq(User::getEmail, email);\n        User one = getOne(queryWrapper);\n        if (Objects.isNull(one)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.EMAIL_NOT_EXIT);\n        }\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult getRePasswordCode(String email) {\n        String code = sendEmailCode(email, \"PERSEVERE BLOG 找回密码 邮箱验证\", \"验证码为：\");\n        log.info(\"找回密码，邮箱验证码----------------\" + code);\n\n        //保存到redis\n        redisCache.setCacheObject(SysConstants.GET_PWD_CODE + email, code, 1, TimeUnit.MINUTES);\n\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult rePassword(String email, String newPassword, String conPassword) {\n\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        queryWrapper.eq(User::getEmail, email);\n        User user = getOne(queryWrapper);\n        if (Objects.isNull(user)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT);\n        }\n\n        if (!newPassword.equals(conPassword)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.NEW_CON_PASSWORD_NOT_MATCH);\n        }\n\n        LambdaQueryWrapper<User> queryWrapper1 = new LambdaQueryWrapper<>();\n        queryWrapper1.eq(User::getEmail, email);\n\n        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();\n        String encode = passwordEncoder.encode(conPassword);\n        User user1 = new User();\n        user1.setPassword(encode);\n\n        update(user1, queryWrapper1);\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult checkRePwdCode(String email, String code) {\n\n        String value = redisCache.getCacheObject(GET_PWD_CODE + email);\n\n        if (!StringUtils.hasText(value)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE);\n        }\n        if (!code.equals(value)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR);\n        }\n\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult cancelAccount(Long userId) {\n        User user = getById(userId);\n        if (Objects.isNull(user)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT);\n        }\n        removeById(userId);\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult checkPassword(UserDTO userDTO) {\n        User user = getById(userDTO.getId());\n\n        if (Objects.isNull(user)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_EXIT);\n        }\n\n        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();\n        if (!passwordEncoder.matches(userDTO.getPassword(), user.getPassword())) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CUR_PASSWORD_ERROR);\n        }\n\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult getCancelEmailCode(UserDTO userDTO) {\n        User user = getById(userDTO.getId());\n        if (Objects.isNull(user)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.USER_NOT_LOGIN);\n        }\n        String emailCode = sendEmailCode(userDTO.getEmail(), \"PERSEVERE BLOG 注销账号验证\", \"账号验证码为:\");\n        redisCache.setCacheObject(SysConstants.ACCOUNT_CANCEL + user.getEmail(), emailCode, 1, TimeUnit.MINUTES);\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public ResponseResult checkCancelEmailCode(UserDTO userDTO) {\n        String code = redisCache.getCacheObject(ACCOUNT_CANCEL + userDTO.getEmail());\n        if (!StringUtils.hasText(code)) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CODE_EXPIRE);\n        }\n        if (!code.equals(userDTO.getCode())) {\n            return ResponseResult.errorResult(AppHttpCodeEnum.CODE_ERROR);\n        }\n        return ResponseResult.okResult();\n    }\n\n    @Override\n    public Boolean isSubscribed(Long userId) {\n        try {\n            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n            LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n            Long uid = loginUser.getUser().getId();\n\n            LambdaQueryWrapper<Subscribe> queryWrapper = new LambdaQueryWrapper<>();\n            queryWrapper.eq(Subscribe::getBeSubscribe, userId);\n            queryWrapper.eq(Subscribe::getSubscribe, uid);\n\n            Subscribe subscribe = subscribeMapper.selectOne(queryWrapper);\n            if (Objects.isNull(subscribe)) {\n                return false;\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private String sendCode(String email) {\n        SimpleMailMessage mailMessage = new SimpleMailMessage();\n        mailMessage.setFrom(fromEmail);\n        mailMessage.setTo(email);\n        mailMessage.setSubject(\"PERSEVERE BLOG\");\n        int sendEmailCode = (int) (Math.random() * ((999999 - 100000 + 1) + 100000));\n        String context = \"注册验证码为: \" + sendEmailCode + \",一分钟内有效，请妥善保管!\";\n        mailMessage.setText(context);\n        javaMailSender.send(mailMessage);\n\n        return sendEmailCode + \"\";\n    }\n\n    private boolean isRegisted(String email) {\n        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n        queryWrapper.eq(User::getEmail, email);\n        User user = getOne(queryWrapper);\n        if (Objects.isNull(user)) {\n            return false;\n        }\n        return true;\n    }\n\n    private String sendEmailCode(String email, String subject, String preContext) {\n        SimpleMailMessage mailMessage = new SimpleMailMessage();\n        mailMessage.setFrom(fromEmail);\n        mailMessage.setTo(email);\n        mailMessage.setSubject(subject);\n        int sendEmailCode = (int) (Math.random() * ((999999 - 100000 + 1) + 100000));\n        log.info(\"发送邮箱验证码-----------\" + sendEmailCode);\n        String context = preContext + sendEmailCode + \",一分钟内有效，请妥善保管!\";\n        mailMessage.setText(context);\n        javaMailSender.send(mailMessage);\n\n        return sendEmailCode + \"\";\n    }\n\n}\n\n', NULL, NULL, '', '0', '0', 1, 0, 0, 0, '1', 1, '2022-11-07 21:59:25', NULL, '2023-02-02 14:13:21', 1);
INSERT INTO `lzh_article` VALUES (1627142236512735233, 'mdFile', NULL, '<h1><a id=\"AJAXAsynchronous_Javascript_And_Xml_0\"></a>AJAX（Asynchronous Javascript And Xml）</h1>\n<h2><a id=\"_3\"></a>传统请求及缺点</h2>\n<ul>\n<li>传统的请求都有哪些？\n<ul>\n<li>直接在浏览器地址栏上输入URL。</li>\n<li>点击超链接</li>\n<li>提交form表单</li>\n<li>使用JS代码发送请求\n<ul>\n<li>window.open(url)</li>\n<li>document.location.href = url</li>\n<li>window.location.href = url</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>传统请求存在的问题\n<ul>\n<li>页面全部刷新导致了用户的体验较差。</li>\n<li>传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）</li>\n<li><img src=\"http://1.117.218.230:9000/test/img_AJAX%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%821676775899388.png\" alt=\"AJAX同步请求\" /></li>\n</ul>\n</li>\n</ul>\n<h2><a id=\"AJAX_20\"></a>AJAX概述</h2>\n<ul>\n<li>AJAX不能称为一种技术，它是多种技术的综合产物。</li>\n<li>AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。</li>\n<li>什么是异步，什么是同步？\n<ul>\n<li>假设有t1和t2线程，t1和t2线程并发，就是异步。</li>\n<li>假设有t1和t2线程，t2在执行的时候，必须等待t1线程执行到某个位置之后t2才能执行，那么t2在等t1，显然他们是排队的，排队的就是同步。</li>\n<li>AJAX是可以发送异步请求的。也就是说，在同一个浏览器页面当中，可以发送多个ajax请求，这些ajax请求之间不需要等待，是并发的。</li>\n</ul>\n</li>\n<li>AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。</li>\n<li>AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。</li>\n<li>AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）</li>\n<li>AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。</li>\n<li><img src=\"http://1.117.218.230:9000/test/img_AJAX%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%821676775899388.png\" alt=\"\" /></li>\n<li><img src=\"http://1.117.218.230:9000/test/img_%E5%AF%B9AJAX%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E7%90%86%E8%A7%A31676775899388.png\" alt=\"\" /></li>\n</ul>\n<h2><a id=\"XMLHttpRequest_36\"></a>XMLHttpRequest对象</h2>\n<ul>\n<li>\n<p>XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。</p>\n</li>\n<li>\n<p>XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。</p>\n</li>\n<li>\n<p>创建XMLHttpRequest对象</p>\n<ul>\n<li>\n<pre><code>  var xhr = new XMLHttpRequest();\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>XMLHttpRequest对象的方法</p>\n</li>\n</ul>\n<p>| 方法 | 描述 | | :-------------------------------------------- | :----------------------------------------------------------- | | abort() | 取消当前请求 | | getAllResponseHeaders() | 返回头部信息 | | getResponseHeader() | 返回特定的头部信息 | | open(<em>method</em>, <em>url</em>, <em>async</em>, <em>user</em>, <em>psw</em>) | 规定请求method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 | | send() | 将请求发送到服务器，用于 GET 请求 | | send(<em>string</em>) | 将请求发送到服务器，用于 POST 请求 | | setRequestHeader() | 向要发送的报头添加标签/值对 |</p>\n<ul>\n<li>XMLHttpRequest对象的属性</li>\n</ul>\n<p>| 属性 | 描述 | | :----------------- | :----------------------------------------------------------- | | onreadystatechange | 定义当 readyState 属性发生变化时被调用的函数 | | readyState | 保存 XMLHttpRequest 的状态。0：请求未初始化 1：服务器连接已建立 2：请求已收到 3：正在处理请求 4：请求已完成且响应已就绪 | | responseText | 以字符串返回响应数据 | | responseXML | 以 XML 数据返回响应数据 | | status | 返回请求的状态号200: &quot;OK&quot;403: &quot;Forbidden&quot;404: “Not Found” | | statusText | 返回状态文本（比如 “OK” 或 “Not Found”） |</p>\n<h2><a id=\"AJAX_GET_57\"></a>AJAX GET请求</h2>\n<ul>\n<li>\n<p>发送AJAX get请求，前端代码：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;发送ajax get请求&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () {\n        document.getElementById(&quot;btn&quot;).onclick = function () {\n            //1. 创建AJAX核心对象\n            var xhr = new XMLHttpRequest();\n            //2. 注册回调函数\n            xhr.onreadystatechange = function(){\n                if (this.readyState == 4) {\n                    if (this.status == 200) {\n                        // 通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容。\n                        // 并且不管服务器响应回来的是什么，都以普通文本的形势获取。（服务器可能响应回来：普通文本、XML、JSON、HTML...）\n                        // innerHTML属性是javascript中的语法，和ajax的XMLHttpRequest对象无关。\n                        // innerHTML可以设置元素内部的HTML代码。（innerHTML可以将后面的内容当做一段HTML代码解释并执行）\n                        //document.getElementById(&quot;myspan&quot;).innerHTML = this.responseText\n                        document.getElementById(&quot;mydiv&quot;).innerHTML = this.responseText\n                        // innerText也不是AJAX中的，是javascript中的元素属性，和XMLHttpRequest无关。\n                        // innerText也是设置元素中的内容，但是即使后面是一段HTML代码，也是将其看做一个普通字符串设置进去。\n                        //document.getElementById(&quot;myspan&quot;).innerText = this.responseText\n                    }else{\n                        alert(this.status)\n                    }\n                }\n            }\n            //3. 开启通道\n            xhr.open(&quot;GET&quot;, &quot;/ajax/ajaxrequest2&quot;, true)\n            //4. 发送请求\n            xhr.send()\n        }\n    }\n&lt;/script&gt;\n&lt;button id=&quot;btn&quot;&gt;发送ajax get请求&lt;/button&gt;\n&lt;span id=&quot;myspan&quot;&gt;&lt;/span&gt;\n&lt;div id=&quot;mydiv&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n<li>\n<p>发送AJAX get请求，后端代码：</p>\n<pre><code>package com.bjpowernode.ajax.servlet;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * @program: 代码\n * @ClassName: AjaxRequest2Servlet\n * @version: 1.0\n * @description:\n * @author: bjpowernode\n * @create: 2022-05-13 10:46\n **/\n\n@WebServlet(&quot;/ajaxrequest2&quot;)\npublic class AjaxRequest2Servlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // 设置响应的内容类型以及字符集\n        response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n        // 获取响应流\n        PrintWriter out = response.getWriter();\n        // 响应\n        out.print(&quot;&lt;font color=\'red\'&gt;用户名已存在！！！&lt;/font&gt;&quot;);\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>AJAX get请求如何提交数据呢？</p>\n<ul>\n<li>get请求提交数据是在“请求行”上提交，格式是：url?name=value&amp;name=value&amp;name=value…</li>\n<li>其实这个get请求提交数据的格式是HTTP协议中规定的，遵循协议即可。</li>\n</ul>\n</li>\n</ul>\n<h2><a id=\"AJAX_GET_149\"></a>AJAX GET请求的缓存问题</h2>\n<ul>\n<li>对于低版本的IE浏览器来说，AJAX的get请求可能会走缓存。存在缓存问题。对于现代的浏览器来说，大部分浏览器都已经不存在AJAX get缓存问题了。</li>\n<li>什么是AJAX GET请求缓存问题呢？\n<ul>\n<li>在HTTP协议中是这样规定get请求的：get请求会被缓存起来。</li>\n<li>发送AJAX GET请求时，在同一个浏览器上，前后发送的AJAX请求路径一样的话，对于低版本的IE来说，第二次的AJAX GET请求会走缓存，不走服务器。</li>\n</ul>\n</li>\n<li>POST请求在HTTP协议中规定的是：POST请求不会被浏览器缓存。</li>\n<li>GET请求缓存的优缺点：\n<ul>\n<li>优点：直接从浏览器缓存中获取资源，不需要从服务器上重新加载资源，速度较快，用户体验好。</li>\n<li>缺点：无法实时获取最新的服务器资源。</li>\n</ul>\n</li>\n<li>浏览器什么时候会走缓存？\n<ul>\n<li>第一：是一个GET请求</li>\n<li>第二：请求路径已经被浏览器缓存过了。第二次发送请求的时候，这个路径没有变化，会走浏览器缓存。</li>\n</ul>\n</li>\n<li>如果是低版本的IE浏览器，怎么解决AJAX GET请求的缓存问题呢？\n<ul>\n<li>可以在请求路径url后面添加一个时间戳，这个时间戳是随时变化的。所以每一次发送的请求路径都是不一样的，这样就不会走浏览器的缓存问题了。</li>\n<li>可以采用时间戳：“url?t=” + new Date().getTime()</li>\n<li>或者可以通过随机数：“url?t=” + Math.random()</li>\n<li>也可以随机数+时间戳…</li>\n</ul>\n</li>\n</ul>\n<h2><a id=\"AJAX_POST_169\"></a>AJAX POST请求</h2>\n<ul>\n<li>\n<p>AJAX POST请求和GET请求的代码区别在哪里？就是前端代码有区别。后端代码没有区别。</p>\n<pre><code>// 4. 发送AJAX POST请求\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) // 设置请求头的内容类型。模拟form表单提交数据。\n// 获取表单中的数据\nvar username = document.getElementById(&quot;username&quot;).value;\nvar password = document.getElementById(&quot;password&quot;).value;\n// send函数中的参数就是发送的数据，这个数据在“请求体”当中发送。\nxhr.send(&quot;username=&quot;+username+&quot;&amp;password=&quot;+password)\n</code></pre>\n</li>\n<li>\n<p>实现一个案例：使用AJAX POST请求实现用户注册的时候，用户名是否可用。（验证用户名是否可以注册）实现步骤如下：</p>\n<ul>\n<li>在前端，用户输入用户名之后，失去焦点事件blur发生，然后发送AJAX POST请求，提交用户名</li>\n<li>在后端，接收到用户名，连接数据库，根据用户名去表中搜索</li>\n<li>如果用户名已存在\n<ul>\n<li>后端响应消息：对不起，用户名已存在（在前端页面以红色字体展示）</li>\n</ul>\n</li>\n<li>如果用户名不存在\n<ul>\n<li>后端响应消息：用户名可以使用（在前端页面以绿色字体展示）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>实现一个案例：用户点击按钮之后，发送AJAX请求，显示学生列表。</p>\n<ul>\n<li>在后端java程序中拼接HTML代码，然后将HTML代码直接响应到浏览器客户端。这种方式不好，不应该在java代码中编写HTML代码，能否在java程序中直接向前端响应数据？可以，可以在后端拼接JSON格式的字符串，或者XML格式的字符串，将这个字符串发送给前端，前端解析即可。</li>\n</ul>\n</li>\n</ul>\n<h2><a id=\"JSON_195\"></a>基于JSON的数据交换</h2>\n<ul>\n<li>\n<p>在WEB前端中，如何将一个json格式的字符串转换成json对象</p>\n<pre><code>var jsonStr = &quot;{\\&quot;username\\&quot; : \\&quot;zhangsan\\&quot;, \\&quot;password\\&quot; : \\&quot;1233344\\&quot;}&quot;\nvar jsonObj = JSON.parse(jsonStr)\nconsole.log(jsonObj.username)\nconsole.log(jsonObj.password)\n</code></pre>\n</li>\n<li>\n<p>在后端拼接JSON格式的字符串，响应给前端的浏览器</p>\n<pre><code>json.append(&quot;[&quot;);\nwhile (rs.next()) {\n    // 获取每个学生的信息\n    String name = rs.getString(&quot;name&quot;);\n    String age = rs.getString(&quot;age&quot;);\n    String addr = rs.getString(&quot;addr&quot;);\n    // 拼接json格式的字符串\n    // {&quot;name&quot;:&quot;   王五    &quot;,&quot;age&quot;:    20      ,&quot;addr&quot;:&quot;      北京大兴区     &quot;},\n    json.append(&quot;{\\&quot;name\\&quot;:\\&quot;&quot;);\n    json.append(name);\n    json.append(&quot;\\&quot;,\\&quot;age\\&quot;:&quot;);\n    json.append(age);\n    json.append(&quot;,\\&quot;addr\\&quot;:\\&quot;&quot;);\n    json.append(addr);\n    json.append(&quot;\\&quot;},&quot;);\n}\njsonStr = json.substring(0, json.length() - 1) + &quot;]&quot;;\n</code></pre>\n</li>\n<li>\n<p>拼接JSON格式的字符串太痛苦，可以使用阿里巴巴的fastjson组件，它可以将java对象转换成json格式的字符串</p>\n<pre><code>List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();\nwhile (rs.next()) {\n    // 取出数据\n    String name = rs.getString(&quot;name&quot;);\n    int age = rs.getInt(&quot;age&quot;);\n    String addr = rs.getString(&quot;addr&quot;);\n    // 将以上数据封装成Student对象\n    Student s = new Student(name, age, addr);\n    // 将Student对象放到List集合\n    studentList.add(s);\n}\n// 将List集合转换成json字符串\njsonStr = JSON.toJSONString(studentList);\n</code></pre>\n<p>注意：使用fastjson需要引入fastjson-1.2.2.jar</p>\n</li>\n</ul>\n<h2><a id=\"XML_247\"></a>基于XML的数据交换</h2>\n<ul>\n<li>\n<p>注意：如果服务器端响应XML的话，响应的内容类型需要写成：</p>\n<pre><code>response.setContentType(&quot;text/xml;charset=UTF-8&quot;);\n</code></pre>\n</li>\n<li>\n<p>xml和JSON都是常用的数据交换格式</p>\n<ul>\n<li>XML体积大，解析麻烦。较少用。</li>\n<li>JSON体积小，解析简单，较常用。</li>\n</ul>\n</li>\n<li>\n<p>基于XML的数据交换，前端代码</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;使用XML完成数据交换&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function(){\n        document.getElementById(&quot;btn&quot;).onclick = function(){\n            // 1.创建XMLHTTPRequest对象\n            var xhr = new XMLHttpRequest();\n            // 2.注册回调函数\n            xhr.onreadystatechange = function () {\n                if (this.readyState == 4) {\n                    if (this.status == 200) {\n                        // 服务器端响应了一个XML字符串，这里怎么接收呢？\n                        // 使用XMLHTTPRequest对象的responseXML属性，接收返回之后，可以自动封装成document对象（文档对象）\n                        var xmlDoc = this.responseXML\n                        //console.log(xmlDoc)\n                        // 获取所有的&lt;student&gt;元素，返回了多个对象，应该是数组。\n                        var students = xmlDoc.getElementsByTagName(&quot;student&quot;)\n                        //console.log(students[0].nodeName)\n                        var html = &quot;&quot;;\n                        for (var i = 0; i &lt; students.length; i++) {\n                            var student = students[i]\n                            // 获取&lt;student&gt;元素下的所有子元素\n                            html += &quot;&lt;tr&gt;&quot;\n                            html += &quot;&lt;td&gt;&quot;+(i+1)+&quot;&lt;/td&gt;&quot;\n                            var nameOrAge = student.childNodes\n                            for (var j = 0; j &lt; nameOrAge.length; j++) {\n                                var node = nameOrAge[j]\n                                if (node.nodeName == &quot;name&quot;) {\n                                    //console.log(&quot;name = &quot; + node.textContent)\n                                    html += &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;/td&gt;&quot;\n                                }\n                                if (node.nodeName == &quot;age&quot;) {\n                                    //console.log(&quot;age = &quot; + node.textContent)\n                                    html += &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;/td&gt;&quot;\n                                }\n                            }\n                            html += &quot;&lt;/tr&gt;&quot;\n                        }\n                        document.getElementById(&quot;stutbody&quot;).innerHTML = html\n                    }else{\n                        alert(this.status)\n                    }\n                }\n            }\n            // 3.开启通道\n            xhr.open(&quot;GET&quot;, &quot;/ajax/ajaxrequest6?t=&quot; + new Date().getTime(), true)\n            // 4.发送请求\n            xhr.send()\n        }\n    }\n&lt;/script&gt;\n&lt;button id=&quot;btn&quot;&gt;显示学生列表&lt;/button&gt;\n&lt;table width=&quot;500px&quot; border=&quot;1px&quot;&gt;\n    &lt;thead&gt;\n    &lt;tr&gt;\n        &lt;th&gt;序号&lt;/th&gt;\n        &lt;th&gt;姓名&lt;/th&gt;\n        &lt;th&gt;年龄&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody id=&quot;stutbody&quot;&gt;\n    &lt;!--&lt;tr&gt;\n        &lt;td&gt;1&lt;/td&gt;\n        &lt;td&gt;zhangsan&lt;/td&gt;\n        &lt;td&gt;20&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;2&lt;/td&gt;\n        &lt;td&gt;lisi&lt;/td&gt;\n        &lt;td&gt;22&lt;/td&gt;\n    &lt;/tr&gt;--&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n<li>\n<p>基于XML的数据交换，后端java程序：</p>\n<pre><code>package com.bjpowernode.ajax.servlet;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * @program: 代码\n * @ClassName: AjaxRequest6Servlet\n * @version: 1.0\n * @description: 服务器端返回XML字符串\n * @author: bjpowernode\n * @create: 2022-05-15 11:48\n **/\n@WebServlet(&quot;/ajaxrequest6&quot;)\npublic class AjaxRequest6Servlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // 注意：响应的内容类型是XML。\n        response.setContentType(&quot;text/xml;charset=UTF-8&quot;);\n        PrintWriter out = response.getWriter();\n\n        /*\n        &lt;students&gt;\n            &lt;student&gt;\n                &lt;name&gt;zhangsan&lt;/name&gt;\n                &lt;age&gt;20&lt;/age&gt;\n            &lt;/student&gt;\n            &lt;student&gt;\n                &lt;name&gt;lisi&lt;/name&gt;\n                &lt;age&gt;22&lt;/age&gt;\n            &lt;/student&gt;\n        &lt;/students&gt;\n         */\n\n        StringBuilder xml = new StringBuilder();\n        xml.append(&quot;&lt;students&gt;&quot;);\n        xml.append(&quot;&lt;student&gt;&quot;);\n        xml.append(&quot;&lt;name&gt;zhangsan&lt;/name&gt;&quot;);\n        xml.append(&quot;&lt;age&gt;20&lt;/age&gt;&quot;);\n        xml.append(&quot;&lt;/student&gt;&quot;);\n        xml.append(&quot;&lt;student&gt;&quot;);\n        xml.append(&quot;&lt;name&gt;lisi&lt;/name&gt;&quot;);\n        xml.append(&quot;&lt;age&gt;22&lt;/age&gt;&quot;);\n        xml.append(&quot;&lt;/student&gt;&quot;);\n        xml.append(&quot;&lt;/students&gt;&quot;);\n\n        out.print(xml);\n    }\n}\n</code></pre>\n</li>\n</ul>\n<h2><a id=\"AJAX_405\"></a>AJAX乱码问题</h2>\n<ul>\n<li>\n<p>测试内容：</p>\n<ul>\n<li>发送ajax get请求\n<ul>\n<li>发送数据到服务器，服务器获取的数据是否乱码？</li>\n<li>服务器响应给前端的中文，会不会乱码？</li>\n</ul>\n</li>\n<li>发送ajax post请求\n<ul>\n<li>发送数据到服务器，服务器获取的数据是否乱码？</li>\n<li>服务器响应给前端的中文，会不会乱码？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>包括还要测试tomcat服务器的版本：</p>\n<ul>\n<li>tomcat10和tomcat9都要进行测试。</li>\n</ul>\n</li>\n<li>\n<p>测试结果：</p>\n<ul>\n<li>\n<p>对于tomcat10来说，关于字符集，我们程序员不需要干涉，不会出现乱码。</p>\n</li>\n<li>\n<p>对于tomcat9来说呢？</p>\n<ul>\n<li>\n<p>响应中文的时候，会出现乱码，怎么解决？</p>\n<pre><code>response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n</code></pre>\n</li>\n<li>\n<p>发送ajax post请求的时候，发送给服务器的数据，服务器接收之后乱码，怎么解决？</p>\n<pre><code>request.setCharacterEncoding(&quot;UTF-8&quot;);\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2><a id=\"AJAX_436\"></a>AJAX的异步与同步</h2>\n<ul>\n<li>\n<p>什么是异步？什么是同步？</p>\n<ul>\n<li>ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）</li>\n<li>如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。）</li>\n</ul>\n</li>\n<li>\n<p>异步和同步在代码上如何实现？</p>\n<pre><code>// 假设这个是ajax请求1\n// 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。\n// false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。\nxhr1.open(&quot;请求方式&quot;, &quot;URL&quot;, false)\nxhr1.send()\n\n// 假设这个是ajax请求2\n// 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。\nxhr2.open(&quot;请求方式&quot;, &quot;URL&quot;, true) \nxhr2.send()\n</code></pre>\n</li>\n<li>\n<p>什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）</p>\n<ul>\n<li>举一个例子\n<ul>\n<li>用户注册\n<ul>\n<li>用户名需要发送ajax请求进行校验</li>\n<li>邮箱地址也需要发送ajax请求校验</li>\n<li>其他的也可能需要发送ajax请求。。。</li>\n<li>并且最终注册按钮的时候，也是发送ajax请求进行注册。</li>\n<li>那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2><a id=\"AJAX_467\"></a>AJAX代码封装</h2>\n<ul>\n<li>\n<p>AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。</p>\n</li>\n<li>\n<p>接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）</p>\n</li>\n<li>\n<p>手动开发jQuery，源代码</p>\n<pre><code>function jQuery(selector){\n    if (typeof selector == &quot;string&quot;) {\n        if (selector.charAt(0) == &quot;#&quot;) {\n            domObj = document.getElementById(selector.substring(1))\n            return new jQuery()\n        }\n    }\n    if (typeof selector == &quot;function&quot;) {\n        window.onload = selector\n    }\n    this.html = function(htmlStr){\n        domObj.innerHTML = htmlStr\n    }\n    this.click = function(fun){\n        domObj.onclick = fun\n    }\n    this.focus = function (fun){\n        domObj.onfocus = fun\n    }\n    this.blur = function(fun) {\n        domObj.onblur = fun\n    }\n    this.change = function (fun){\n        domObj.onchange = fun\n    }\n    this.val = function(v){\n        if (v == undefined) {\n            return domObj.value\n        }else{\n            domObj.value = v\n        }\n    }\n\n    // 静态的方法，发送ajax请求\n    /**\n     * 分析：使用ajax函数发送ajax请求的时候，需要程序员给我们传过来什么？\n     *      请求的方式(type)：GET/POST\n     *      请求的URL(url)：url\n     *      请求时提交的数据(data)：data\n     *      请求时发送异步请求还是同步请求(async)：true表示异步，false表示同步。\n     */\n    jQuery.ajax = function(jsonArgs){\n        // 1.\n        var xhr = new XMLHttpRequest();\n        // 2.\n        xhr.onreadystatechange = function(){\n            if (this.readyState == 4) {\n                if (this.status == 200) {\n                    // 我们这个工具类在封装的时候，先不考虑那么多，假设服务器返回的都是json格式的字符串。\n                    var jsonObj = JSON.parse(this.responseText)\n                    // 调用函数\n                    jsonArgs.success(jsonObj)\n                }\n            }\n        }\n\n        if (jsonArgs.type.toUpperCase() == &quot;POST&quot;) {\n            // 3.\n            xhr.open(&quot;POST&quot;, jsonArgs.url, jsonArgs.async)\n            // 4.\n            xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)\n            xhr.send(jsonArgs.data)\n        }\n\n        if (jsonArgs.type.toUpperCase() == &quot;GET&quot;) {\n            xhr.open(&quot;GET&quot;, jsonArgs.url + &quot;?&quot; + jsonArgs.data, jsonArgs.async)\n            xhr.send()\n        }\n\n    }\n}\n$ = jQuery\n\n// 这里有个细节，执行这个目的是为了让静态方法ajax生效。\nnew jQuery()\n</code></pre>\n</li>\n<li>\n<p>使用以上库，怎么用？</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/ajax/js/jQuery-1.0.0.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $(function(){\n        $(&quot;#btn1&quot;).click(function(){\n            $.ajax({\n                type : &quot;POST&quot;,\n                url : &quot;/ajax/ajaxrequest11&quot;,\n                data : &quot;username=&quot; + $(&quot;#username&quot;).val(),\n                async : true,\n                success : function(json){\n                    $(&quot;#div1&quot;).html(json.uname)\n                }\n            })\n        })\n    })\n&lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n<h2><a id=\"AJAX_576\"></a>AJAX实现省市联动</h2>\n<ul>\n<li>\n<p>什么是省市联动？</p>\n<ul>\n<li>在网页上，选择对应的省份之后，动态的关联出该省份对应的市。选择对应的市之后，动态的关联出该市对应的区。（首先要清楚需求）</li>\n</ul>\n</li>\n<li>\n<p>进行数据库表的设计</p>\n<ul>\n<li>\n<pre><code>  t_area （区域表）\n  id(PK-自增)	  code		name		pcode\n  ---------------------------------------------\n  1				001		 河北省		null\n  2				002		 河南省		null\n  3				003		 石家庄	    001\n  4				004		 邯郸			 001\n  5				005		 郑州			 002\n  6				006		 洛阳			 002\n  7				007		 丛台区	    004  \n  \n  将全国所有的省、市、区、县等信息都存储到一张表当中。\n  采用的存储方式实际上是code pcode形势。\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>建表t_area，模拟好数据。</p>\n</li>\n<li>\n<p>首先实现第一个功能：</p>\n<ul>\n<li>页面加载完毕之后，先把省份全部展现出来。</li>\n</ul>\n</li>\n</ul>\n<h2><a id=\"AJAX_605\"></a>AJAX跨域问题</h2>\n<h2><a id=\"AJAX__608\"></a>AJAX实现搜索联想 自动补全</h2>\n<h2><a id=\"HTTP_611\"></a>附录：HTTP状态信息</h2>\n<h3><a id=\"1xx__614\"></a>1xx: 信息</h3>\n<p>| 消息: | 描述: | | :---------------------- | :----------------------------------------------------------- | | 100 Continue | 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 | | 101 Switching Protocols | 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 |</p>\n<h3><a id=\"2xx__618\"></a>2xx: 成功</h3>\n<p>| 消息: | 描述: | | :-------------------------------- | :----------------------------------------------------------- | | 200 OK | 请求成功（其后是对GET和POST请求的应答文档。） | | 201 Created | 请求被创建完成，同时新的资源被创建。 | | 202 Accepted | 供处理的请求已被接受，但是处理未完成。 | | 203 Non-authoritative Information | 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 | | 204 No Content | 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 | | 205 Reset Content | 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 | | 206 Partial Content | 客户发送了一个带有Range头的GET请求，服务器完成了它。 |</p>\n<h3><a id=\"3xx__622\"></a>3xx: 重定向</h3>\n<p>| 消息: | 描述: | | :--------------------- | :----------------------------------------------------------- | | 300 Multiple Choices | 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 | | 301 Moved Permanently | 所请求的页面已经转移至新的url。 | | 302 Found | 所请求的页面已经临时转移至新的url。 | | 303 See Other | 所请求的页面可在别的url下被找到。 | | 304 Not Modified | 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 | | 305 Use Proxy | 客户请求的文档应该通过Location头所指明的代理服务器提取。 | | 306 <em>Unused</em> | 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。 | | 307 Temporary Redirect | 被请求的页面已经临时移至新的url。 |</p>\n<h3><a id=\"4xx__626\"></a>4xx: 客户端错误</h3>\n<p>| 消息: | 描述: | | :-------------------------------- | :----------------------------------------------------------- | | 400 Bad Request | 服务器未能理解请求。 | | 401 Unauthorized | 被请求的页面需要用户名和密码。 | | 402 Payment Required | 此代码尚无法使用。 | | 403 Forbidden | 对被请求页面的访问被禁止。 | | 404 Not Found | 服务器无法找到被请求的页面。 | | 405 Method Not Allowed | 请求中指定的方法不被允许。 | | 406 Not Acceptable | 服务器生成的响应无法被客户端所接受。 | | 407 Proxy Authentication Required | 用户必须首先使用代理服务器进行验证，这样请求才会被处理。 | | 408 Request Timeout | 请求超出了服务器的等待时间。 | | 409 Conflict | 由于冲突，请求无法被完成。 | | 410 Gone | 被请求的页面不可用。 | | 411 Length Required | “Content-Length” 未被定义。如果无此内容，服务器不会接受请求。 | | 412 Precondition Failed | 请求中的前提条件被服务器评估为失败。 | | 413 Request Entity Too Large | 由于所请求的实体的太大，服务器不会接受请求。 | | 414 Request-url Too Long | 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 | | 415 Unsupported Media Type | 由于媒介类型不被支持，服务器不会接受请求。 | | 416 | 服务器不能满足客户在请求中指定的Range头。 | | 417 Expectation Failed | |</p>\n<h3><a id=\"5xx__630\"></a>5xx: 服务器错误</h3>\n<p>| 消息: | 描述: | | :----------------------------- | :------------------------------------------------- | | 500 Internal Server Error | 请求未完成。服务器遇到不可预知的情况。 | | 501 Not Implemented | 请求未完成。服务器不支持所请求的功能。 | | 502 Bad Gateway | 请求未完成。服务器从上游服务器收到一个无效的响应。 | | 503 Service Unavailable | 请求未完成。服务器临时过载或当机。 | | 504 Gateway Timeout | 网关超时。 | | 505 HTTP Version Not Supported | 服务器不支持请求中指明的HTTP协议版本。 |</p>\n', 'mdFile', 16, 'http://1.117.218.230:9000/test/img_1676895526126.png', '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-19 11:05:15', 1, '2023-02-20 20:18:48', 0);
INSERT INTO `lzh_article` VALUES (1627145535857119233, 'MongoDB', NULL, '<p>反反复复烦烦烦</p>\n', 'MongoDB', 1, 'http://1.117.218.230:9000/test/img_1676895062572.png', '0', '2', 0, 0, 0, 0, '1', 30, '2023-02-19 11:18:21', 30, '2023-02-20 20:18:13', 0);
INSERT INTO `lzh_article` VALUES (1627154063468548097, 'SpringBoot整合邮箱服务实现登录验证功能', NULL, '<h1>SpringBoot整合邮箱服务实现登录验证功能</h1>\n<blockquote>\n<p>参考网址：https://blog.csdn.net/a648119398/article/details/125290931?spm=1001.2014.3001.5501</p>\n</blockquote>\n<h1>SpringBoot整合邮箱服务实现注册功能</h1>\n<h2>1.导入依赖</h2>\n<pre><code class=\"language-xml\">&lt;!-- 邮件服务 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!-- Thymeleaf 模版，用于发送模版邮件 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2>2.配置application.yml</h2>\n<pre><code class=\"language-yaml\">server:\n  port: 8082\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3307/test?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false\n    username: root\n    password: abc123\n  #邮箱配置\n  mail:\n    # 发送邮件的服务器地址\n    host: smtp.qq.com\n    #填写自己的qq邮箱账号 # 开启 IMAP/SMTP服务 的qq邮箱的账号\n    username: 1203464373@qq.com\n    #填写自己的授权码  # 开启 IMAP/SMTP服务 获得的授权码,而不是qq邮箱的登录密码\n    password: wkfoakhphgsvhieh\n    default-encoding: UTF-8\n  redis:\n    host: 1.117.218.230\n    port: 7001\n    database: 0\n    password: qfedu123\n</code></pre>\n<h2>3.使用MybatisX生成mapper\\service\\entity</h2>\n<h2>4.controller</h2>\n<pre><code class=\"language-java\">@RestController\n@RequestMapping(&quot;/user&quot;)\npublic class UserController {\n\n    @Resource\n    private UserService userService;\n\n    /**\n     * 注册\n     * @param userRegistForm\n     * @return\n     */\n    @PostMapping(&quot;/email/regist&quot;)\n    public ResponseResult regist(@RequestBody UserRegistForm userRegistForm) {\n        return userService.regist(userRegistForm);\n    }\n\n    /**\n     * 获取验证码\n     * @param email\n     * @return\n     */\n    @PostMapping(&quot;/email/getCode/{email}&quot;)\n    public ResponseResult getCode(@PathVariable String email) {\n        return userService.getEmailCode(email);\n    }\n}\n</code></pre>\n<h2>5.service</h2>\n<pre><code class=\"language-java\">package com.lzh.email.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.lzh.email.domain.ResponseResult;\nimport com.lzh.email.domain.User;\nimport com.lzh.email.pojo.UserRegistForm;\nimport com.lzh.email.service.UserService;\nimport com.lzh.email.mapper.UserMapper;\nimport com.lzh.email.utils.JwtUtil;\nimport com.lzh.email.utils.PwdUtil;\nimport org.apache.tomcat.util.security.MD5Encoder;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.StringUtils;\nimport sun.security.provider.MD5;\n\nimport javax.annotation.Resource;\nimport java.security.MessageDigest;\nimport java.util.Objects;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author ASUS\n * @description 针对表【my_user】的数据库操作Service实现\n * @createDate 2022-07-28 21:13:51\n */\n@Service\npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {\n\n    @Value(&quot;${spring.mail.username}&quot;)\n    private String from;\n\n    @Resource\n    private JavaMailSender javaMailSender;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    public ResponseResult regist(UserRegistForm userRegistForm) {\n\n        if (Objects.isNull(userRegistForm)) {\n            return ResponseResult.errorResult(303, &quot;注册失败&quot;);\n        }\n        if (!StringUtils.hasText(userRegistForm.getEmail())) {\n            return ResponseResult.errorResult(305, &quot;邮箱不能为空&quot;);\n        }\n        if (!StringUtils.hasText(userRegistForm.getPassword())) {\n            return ResponseResult.errorResult(306, &quot;密码不能为空&quot;);\n        }\n        if (!StringUtils.hasText(userRegistForm.getInputCode())) {\n            return ResponseResult.errorResult(307, &quot;验证码不能为空&quot;);\n        }\n\n        //判断该邮箱是否已经注册\n        if (isRegisted(userRegistForm.getEmail())) {\n            return ResponseResult.errorResult(308, &quot;该邮箱已经注册&quot;);\n        }\n\n        //从redis中获取，判断是否过期\n        String value = stringRedisTemplate.opsForValue().get(&quot;email:&quot; + userRegistForm.getEmail());\n        if (!StringUtils.hasText(value)) {\n            //验证码不存在\n            return ResponseResult.errorResult(303, &quot;验证码过期，请重新发送&quot;);\n        }\n\n        //验证码存在\n        //判断输入的验证码是否正确\n        if (!userRegistForm.getInputCode().equals(value)) {\n            return ResponseResult.errorResult(304, &quot;验证码输入错误&quot;);\n        }\n\n        //存入数据库\n        User user = new User();\n        user.setEmail(userRegistForm.getEmail());\n        String password = userRegistForm.getPassword();\n        String encode = PwdUtil.encode(password);\n        user.setPassword(encode);\n        this.save(user);\n\n        return ResponseResult.okResult(200, &quot;注册成功&quot;);\n    }\n\n    private boolean isRegisted(String email) {\n        //判断该邮箱是否已经注册\n        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();\n        queryWrapper.eq(User::getEmail, email);\n        User user = this.getOne(queryWrapper);\n        if (!Objects.isNull(user)) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public ResponseResult getEmailCode(String email) {\n\n        //判断该邮箱是否已经注册\n        if (isRegisted(email)) {\n            return ResponseResult.errorResult(308, &quot;该邮箱已经注册&quot;);\n        }\n\n        String redisKey = &quot;email:&quot; + email;\n        //判断redis是否存在key\n        String value = stringRedisTemplate.opsForValue().get(redisKey);\n        if (StringUtils.hasText(value)) {\n            return ResponseResult.errorResult(303, &quot;验证码已发送&quot;);\n        }\n\n        //发送验证码\n        SimpleMailMessage mailMessage = new SimpleMailMessage();\n        mailMessage.setFrom(from);\n        mailMessage.setTo(email);\n        mailMessage.setSubject(&quot;注册验证码&quot;);\n        int emailCode = (int) (Math.random() * ((9999 - 1000 + 1) + 1000));\n        String context = &quot;注册验证码为: &quot; + emailCode + &quot;,二分钟内有效，请妥善保管!&quot;;\n        mailMessage.setText(context);\n        javaMailSender.send(mailMessage);\n\n        //存入redis\n        stringRedisTemplate.opsForValue().set(redisKey, emailCode + &quot;&quot;, 2, TimeUnit.MINUTES);\n\n        return ResponseResult.okResult(200, &quot;验证码发送成功&quot;);\n    }\n}\n</code></pre>\n', 'SpringBoot整合邮箱服务实现登录验证功能', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-19 11:52:14', 1, '2023-02-19 11:52:14', 1);
INSERT INTO `lzh_article` VALUES (1627503573914947586, '测试文章', NULL, NULL, '顶顶顶顶顶', NULL, 'http://1.117.218.230:9000/test/img_1676861941642.jpg', '1', '2', 0, 0, 0, 0, '1', NULL, '2023-02-20 11:01:04', NULL, '2023-02-20 11:01:04', 0);
INSERT INTO `lzh_article` VALUES (1627534326015000578, 'SpringBoot测试文章', NULL, '<h1><a id=\"SpringBoot_0\"></a>SpringBoot整合邮箱服务实现登录验证功能</h1>\n<blockquote>\n<p>参考网址：https://blog.csdn.net/a648119398/article/details/125290931?spm=1001.2014.3001.5501</p>\n</blockquote>\n<h1><a id=\"SpringBoot_4\"></a>SpringBoot整合邮箱服务实现注册功能</h1>\n<h2><a id=\"1_6\"></a>1.导入依赖</h2>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-comment\">&lt;!-- 邮件服务 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-mail<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- Thymeleaf 模版，用于发送模版邮件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<h2><a id=\"2applicationyml_21\"></a>2.配置application.yml</h2>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">server:</span>\n  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">8082</span>\n<span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">datasource:</span>\n    <span class=\"hljs-attr\">driver-class-name:</span> <span class=\"hljs-string\">com.mysql.cj.jdbc.Driver</span>\n    <span class=\"hljs-attr\">url:</span> <span class=\"hljs-string\">jdbc:mysql://127.0.0.1:3307/test?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span>\n    <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">root</span>\n    <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">abc123</span>\n  <span class=\"hljs-comment\">#邮箱配置</span>\n  <span class=\"hljs-attr\">mail:</span>\n    <span class=\"hljs-comment\"># 发送邮件的服务器地址</span>\n    <span class=\"hljs-attr\">host:</span> <span class=\"hljs-string\">smtp.qq.com</span>\n    <span class=\"hljs-comment\">#填写自己的qq邮箱账号 # 开启 IMAP/SMTP服务 的qq邮箱的账号</span>\n    <span class=\"hljs-attr\">username:</span> <span class=\"hljs-number\">1203464373</span><span class=\"hljs-string\">@qq.com</span>\n    <span class=\"hljs-comment\">#填写自己的授权码  # 开启 IMAP/SMTP服务 获得的授权码,而不是qq邮箱的登录密码</span>\n    <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">wkfoakhphgsvhieh</span>\n    <span class=\"hljs-attr\">default-encoding:</span> <span class=\"hljs-string\">UTF-8</span>\n  <span class=\"hljs-attr\">redis:</span>\n    <span class=\"hljs-attr\">host:</span> <span class=\"hljs-number\">1.117</span><span class=\"hljs-number\">.218</span><span class=\"hljs-number\">.230</span>\n    <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">7001</span>\n    <span class=\"hljs-attr\">database:</span> <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">qfedu123</span>\n</code></div></pre>\n<h2><a id=\"3MybatisXmapperserviceentity_48\"></a>3.使用MybatisX生成mapper\\service\\entity</h2>\n<h2><a id=\"4controller_50\"></a>4.controller</h2>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping(&quot;/user&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserController</span> {\n\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> UserService userService;\n\n    <span class=\"hljs-comment\">/**\n     * 注册\n     * <span class=\"hljs-doctag\">@param</span> userRegistForm\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-meta\">@PostMapping(&quot;/email/regist&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> ResponseResult <span class=\"hljs-title function_\">regist</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestBody</span> UserRegistForm userRegistForm)</span> {\n        <span class=\"hljs-keyword\">return</span> userService.regist(userRegistForm);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 获取验证码\n     * <span class=\"hljs-doctag\">@param</span> email\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-meta\">@PostMapping(&quot;/email/getCode/{email}&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> ResponseResult <span class=\"hljs-title function_\">getCode</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@PathVariable</span> String email)</span> {\n        <span class=\"hljs-keyword\">return</span> userService.getEmailCode(email);\n    }\n}\n</code></div></pre>\n<h2><a id=\"5service_82\"></a>5.service</h2>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.lzh.email.service.impl;\n\n<span class=\"hljs-keyword\">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\n<span class=\"hljs-keyword\">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\n<span class=\"hljs-keyword\">import</span> com.lzh.email.domain.ResponseResult;\n<span class=\"hljs-keyword\">import</span> com.lzh.email.domain.User;\n<span class=\"hljs-keyword\">import</span> com.lzh.email.pojo.UserRegistForm;\n<span class=\"hljs-keyword\">import</span> com.lzh.email.service.UserService;\n<span class=\"hljs-keyword\">import</span> com.lzh.email.mapper.UserMapper;\n<span class=\"hljs-keyword\">import</span> com.lzh.email.utils.JwtUtil;\n<span class=\"hljs-keyword\">import</span> com.lzh.email.utils.PwdUtil;\n<span class=\"hljs-keyword\">import</span> org.apache.tomcat.util.security.MD5Encoder;\n<span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;\n<span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Value;\n<span class=\"hljs-keyword\">import</span> org.springframework.data.redis.core.StringRedisTemplate;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.ResponseEntity;\n<span class=\"hljs-keyword\">import</span> org.springframework.mail.SimpleMailMessage;\n<span class=\"hljs-keyword\">import</span> org.springframework.mail.javamail.JavaMailSender;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Service;\n<span class=\"hljs-keyword\">import</span> org.springframework.util.StringUtils;\n<span class=\"hljs-keyword\">import</span> sun.security.provider.MD5;\n\n<span class=\"hljs-keyword\">import</span> javax.annotation.Resource;\n<span class=\"hljs-keyword\">import</span> java.security.MessageDigest;\n<span class=\"hljs-keyword\">import</span> java.util.Objects;\n<span class=\"hljs-keyword\">import</span> java.util.Random;\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.TimeUnit;\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@author</span> ASUS\n * <span class=\"hljs-doctag\">@description</span> 针对表【my_user】的数据库操作Service实现\n * <span class=\"hljs-doctag\">@createDate</span> 2022-07-28 21:13:51\n */</span>\n<span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserServiceImpl</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">ServiceImpl</span>&lt;UserMapper, User&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">UserService</span> {\n\n    <span class=\"hljs-meta\">@Value(&quot;${spring.mail.username}&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> String from;\n\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> JavaMailSender javaMailSender;\n\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> StringRedisTemplate stringRedisTemplate;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> ResponseResult <span class=\"hljs-title function_\">regist</span><span class=\"hljs-params\">(UserRegistForm userRegistForm)</span> {\n\n        <span class=\"hljs-keyword\">if</span> (Objects.isNull(userRegistForm)) {\n            <span class=\"hljs-keyword\">return</span> ResponseResult.errorResult(<span class=\"hljs-number\">303</span>, <span class=\"hljs-string\">&quot;注册失败&quot;</span>);\n        }\n        <span class=\"hljs-keyword\">if</span> (!StringUtils.hasText(userRegistForm.getEmail())) {\n            <span class=\"hljs-keyword\">return</span> ResponseResult.errorResult(<span class=\"hljs-number\">305</span>, <span class=\"hljs-string\">&quot;邮箱不能为空&quot;</span>);\n        }\n        <span class=\"hljs-keyword\">if</span> (!StringUtils.hasText(userRegistForm.getPassword())) {\n            <span class=\"hljs-keyword\">return</span> ResponseResult.errorResult(<span class=\"hljs-number\">306</span>, <span class=\"hljs-string\">&quot;密码不能为空&quot;</span>);\n        }\n        <span class=\"hljs-keyword\">if</span> (!StringUtils.hasText(userRegistForm.getInputCode())) {\n            <span class=\"hljs-keyword\">return</span> ResponseResult.errorResult(<span class=\"hljs-number\">307</span>, <span class=\"hljs-string\">&quot;验证码不能为空&quot;</span>);\n        }\n\n        <span class=\"hljs-comment\">//判断该邮箱是否已经注册</span>\n        <span class=\"hljs-keyword\">if</span> (isRegisted(userRegistForm.getEmail())) {\n            <span class=\"hljs-keyword\">return</span> ResponseResult.errorResult(<span class=\"hljs-number\">308</span>, <span class=\"hljs-string\">&quot;该邮箱已经注册&quot;</span>);\n        }\n\n        <span class=\"hljs-comment\">//从redis中获取，判断是否过期</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">value</span> <span class=\"hljs-operator\">=</span> stringRedisTemplate.opsForValue().get(<span class=\"hljs-string\">&quot;email:&quot;</span> + userRegistForm.getEmail());\n        <span class=\"hljs-keyword\">if</span> (!StringUtils.hasText(value)) {\n            <span class=\"hljs-comment\">//验证码不存在</span>\n            <span class=\"hljs-keyword\">return</span> ResponseResult.errorResult(<span class=\"hljs-number\">303</span>, <span class=\"hljs-string\">&quot;验证码过期，请重新发送&quot;</span>);\n        }\n\n        <span class=\"hljs-comment\">//验证码存在</span>\n        <span class=\"hljs-comment\">//判断输入的验证码是否正确</span>\n        <span class=\"hljs-keyword\">if</span> (!userRegistForm.getInputCode().equals(value)) {\n            <span class=\"hljs-keyword\">return</span> ResponseResult.errorResult(<span class=\"hljs-number\">304</span>, <span class=\"hljs-string\">&quot;验证码输入错误&quot;</span>);\n        }\n\n        <span class=\"hljs-comment\">//存入数据库</span>\n        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>();\n        user.setEmail(userRegistForm.getEmail());\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">password</span> <span class=\"hljs-operator\">=</span> userRegistForm.getPassword();\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">encode</span> <span class=\"hljs-operator\">=</span> PwdUtil.encode(password);\n        user.setPassword(encode);\n        <span class=\"hljs-built_in\">this</span>.save(user);\n\n        <span class=\"hljs-keyword\">return</span> ResponseResult.okResult(<span class=\"hljs-number\">200</span>, <span class=\"hljs-string\">&quot;注册成功&quot;</span>);\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isRegisted</span><span class=\"hljs-params\">(String email)</span> {\n        <span class=\"hljs-comment\">//判断该邮箱是否已经注册</span>\n        LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LambdaQueryWrapper</span>&lt;&gt;();\n        queryWrapper.eq(User::getEmail, email);\n        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.getOne(queryWrapper);\n        <span class=\"hljs-keyword\">if</span> (!Objects.isNull(user)) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> ResponseResult <span class=\"hljs-title function_\">getEmailCode</span><span class=\"hljs-params\">(String email)</span> {\n\n        <span class=\"hljs-comment\">//判断该邮箱是否已经注册</span>\n        <span class=\"hljs-keyword\">if</span> (isRegisted(email)) {\n            <span class=\"hljs-keyword\">return</span> ResponseResult.errorResult(<span class=\"hljs-number\">308</span>, <span class=\"hljs-string\">&quot;该邮箱已经注册&quot;</span>);\n        }\n\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">redisKey</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;email:&quot;</span> + email;\n        <span class=\"hljs-comment\">//判断redis是否存在key</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">value</span> <span class=\"hljs-operator\">=</span> stringRedisTemplate.opsForValue().get(redisKey);\n        <span class=\"hljs-keyword\">if</span> (StringUtils.hasText(value)) {\n            <span class=\"hljs-keyword\">return</span> ResponseResult.errorResult(<span class=\"hljs-number\">303</span>, <span class=\"hljs-string\">&quot;验证码已发送&quot;</span>);\n        }\n\n        <span class=\"hljs-comment\">//发送验证码</span>\n        <span class=\"hljs-type\">SimpleMailMessage</span> <span class=\"hljs-variable\">mailMessage</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleMailMessage</span>();\n        mailMessage.setFrom(from);\n        mailMessage.setTo(email);\n        mailMessage.setSubject(<span class=\"hljs-string\">&quot;注册验证码&quot;</span>);\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">emailCode</span> <span class=\"hljs-operator\">=</span> (<span class=\"hljs-type\">int</span>) (Math.random() * ((<span class=\"hljs-number\">9999</span> - <span class=\"hljs-number\">1000</span> + <span class=\"hljs-number\">1</span>) + <span class=\"hljs-number\">1000</span>));\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">context</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;注册验证码为: &quot;</span> + emailCode + <span class=\"hljs-string\">&quot;,二分钟内有效，请妥善保管!&quot;</span>;\n        mailMessage.setText(context);\n        javaMailSender.send(mailMessage);\n\n        <span class=\"hljs-comment\">//存入redis</span>\n        stringRedisTemplate.opsForValue().set(redisKey, emailCode + <span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-number\">2</span>, TimeUnit.MINUTES);\n\n        <span class=\"hljs-keyword\">return</span> ResponseResult.okResult(<span class=\"hljs-number\">200</span>, <span class=\"hljs-string\">&quot;验证码发送成功&quot;</span>);\n    }\n}\n</code></div></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_1676869296416.jpg\" alt=\"nb_d_23.jpg\" /></p>\n', '哈哈哈', NULL, 'http://1.117.218.230:9000/test/img_1676869256172.jpg', '1', '0', 0, 0, 0, 0, '1', NULL, '2023-02-20 13:03:16', NULL, '2023-02-20 13:03:16', 0);
INSERT INTO `lzh_article` VALUES (1627535444652646402, 'Redistribution测试', NULL, '<h3><a id=\"122_Redis_0\"></a>1.2.2 Redis是什么？</h3>\n<p><strong>Redis就是一个用C语言开发的、基于内存结构进行<code>键值对</code>数据存储的、高性能的、非关系型NoSQL数据库</strong></p>\n<h3><a id=\"123_Redis_4\"></a>1.2.3 Redis支持的数据类型</h3>\n<blockquote>\n<p>Redis是基于键值对进行数据存储的，但是value可以是多种数据类型：</p>\n<ul>\n<li>string字符串</li>\n<li>hash 映射</li>\n<li>list 列表（队列）</li>\n<li>set 集合</li>\n<li>zset 无序集合</li>\n</ul>\n</blockquote>\n<h3><a id=\"124_Redis_14\"></a>1.2.4 Redis特点</h3>\n<ul>\n<li>基于内存存储，数据读写效率很高</li>\n<li>Redis本身支持持久化</li>\n<li>Redis虽然基于key-value存储，但是支持多种数据类型</li>\n<li>Redis支持集群、支持主从模式</li>\n</ul>\n', 'testtest', 1, 'http://1.117.218.230:9000/test/img_1676869648440.png', '0', '0', 0, 0, 0, 0, '0', 1, '2023-02-20 13:07:43', NULL, '2023-02-20 20:07:33', 0);
INSERT INTO `lzh_article` VALUES (1627856294656397313, 'Ajax', NULL, '<h1>第一章 Ajax 前端技术</h1>\n<p>前端技术： 在浏览器中执行的程序都是前端， html ， css，js等等</p>\n<p>后端技术：在服务器中执行的程序， 使用java语言开发的后端程序。  servlet,jsp, jdbc,mysql,tomcat等等</p>\n<h1>1 全局刷新和局部刷新</h1>\n<p>1）全局刷新： 使用form， href等发起的请求是全局刷新。</p>\n<p>​    用户发起请求， 视图改变了， 跳转视图，使用新的数据添加到页面。</p>\n<p>缺点：</p>\n<pre><code> 1. 传递数据量比较大。 占用网络的带宽\n    2. 浏览器需要重新的渲染整个页面。 \n    3. 用户的体验不是那么好\n</code></pre>\n<p>2）局部刷新： 在当前页面中，发起请求，获取数据，更新当前页面的dom对象。  对视图部分刷新。</p>\n<p>​     特点：</p>\n<pre><code> 1. 数量比较小， 在网络中传输速度快。\n    2. 更新页面内容， 是部分更新页面， 浏览器不用全部渲染视图。\n    3. 在一个页面中，可以做多个 局部刷新\n    4. 从服务器获取的是数据， 拿到更新视图\n</code></pre>\n<h1>2 异步请求对象</h1>\n<p>在局部刷新中，使用异步请求对象，在浏览器内部发起请求，获取数据。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010120922181131676946152415.png\" alt=\"image-20201012092218113\" /></p>\n<p>异步对象是在浏览器内部的一种  javascript对象。 各大浏览器都能支持异步对象的使用。chrome ,firework, ie, opper ,</p>\n<p>异步对象  XMLHttpRequest</p>\n<h1>3. 异步对象XMLHttpRequest介绍</h1>\n<p>js中的一种对象， 使用js语法创建和使用这个对象。</p>\n<p>var xhr = new XMLHttpRequest();</p>\n<p>之后就可以 使用xhr对象的属性或者函数，进行异步对象的操作。</p>\n<p>使用异步对象实现局部刷新， 异步对象主要负责发起请求，传递请求的参数，并从服务器接收数据。</p>\n<p>局部刷新需要使用那些技术：</p>\n<p>1）javascript ： 创建XMLHttpRequest对象， 调用它的属性或者方法</p>\n<p>2）dom：处理dom，更新select的数据</p>\n<p>3）css:  处理视图， 更新，美化。</p>\n<p>4）servlet：服务器端技术</p>\n<p>5）数据格式：json。 它之前是xml</p>\n<p>把上面这些技术的综合使用叫做ajax（阿贾克斯）。</p>\n<h1>4 Ajax</h1>\n<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和XML）。\nAJAX 是一种在无需重新加载整个网页的情况下，能够更新部分页面内容的新方法</p>\n<p>AJAX不是新的编程语言，它是多种技术的综合使用。 包含了javascript, dom</p>\n<p>,css, 服务器端技术， servlet ，jsp ，jdbc等等， 还有 json数据格式。</p>\n<p>使用AJAX实现局部刷新。</p>\n<p>Ajax核心是 javascript 和  xml （json）：使用javascript操作异步对象XMLHttpRequest.   和服务器交换使用json数据格式。</p>\n<h1>5. 异步对象XMLHttpRequest属性和方法</h1>\n<ol>\n<li>\n<p>创建异步对象，使用js的语法</p>\n<p>var xhr  = new XMLHttpRequest();</p>\n</li>\n<li>\n<p>XMLHttpRequest方法</p>\n<p>①）open(请求方式, 服务器端的访问地址，异步还是同步)</p>\n<p>例如：xhr.open(&quot;get&quot;,&quot;loginServlet&quot;,true);</p>\n<p>②）send(): 使用异步对象发送请求</p>\n</li>\n<li>\n<p>XMLHttpRequest属性</p>\n<p>readyState属性：请求的状态</p>\n<p>​        0：表示创建异步对象时，new XMLHttpRequest();</p>\n<p>​        1：表示初始异步对象的请求参数。 执行open()方法</p>\n<p>​	    2：使用send()方法发送请求。</p>\n<p>​	    3：使用异步对象从服务器接收了数据</p>\n<p>​		4：异步对象接收了数据，并在异步对象内部处理完成后。</p>\n<p>status属性：网络的状态，和Http的状态码对应</p>\n<p>​     200：请求成功</p>\n<p>​     404： 服务器资源没有找到</p>\n<p>​     500： 服务器内部代码有错误</p>\n<p>responseText属性：表示服务器端返回的数据</p>\n<p>​    例如： var data = xhr.responseText;</p>\n</li>\n</ol>\n<h1>6. 异步对象XMLHttpRequest使用步骤</h1>\n<p>1）使用js创建异步对象</p>\n<p>​    var xhr = new XMLHttpRequest();</p>\n<p>2)给异步对象绑定事件。事件名称  onreadystatechange</p>\n<p>例如button增加单击事件 onclick</p>\n<p>xhr绑定事件</p>\n<p>xhr.onreadysatechange=function() {    当事件发生时执行的代码   }</p>\n<pre><code class=\"language-xml\">&lt;input type=&quot;button&quot; onclick=&quot;btnClick()&quot; /&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function btnClick(){\n       按钮单击的处理代码\n     \n    }\n&lt;/script&gt;\n</code></pre>\n<p>在绑定事件中做什么，根据readyState值做请求的处理</p>\n<pre><code class=\"language-xml\">\nxhr.readystatechagne=function(){\n   if( xhr.readyState==4 &amp;&amp; xhr.status==200 ){\n        从服务器获取了数据， 更新当前页面的dom对象，完成请求的处理\n        var data = xhr.responseText;\n        更新dom对象\n        document.getElementById(&quot;#mydiv&quot;).innertHTML = data;\n   }\n\n}\n</code></pre>\n<ol start=\"3\">\n<li>\n<p>初始请求的参数，执行open()函数</p>\n<p>xhr.open(&quot;get&quot;,&quot;loginServlet&quot;,true)</p>\n</li>\n</ol>\n<p>4)发送请求，执行send()</p>\n<p>xhr.send()</p>\n<h1>7. 第一个例子</h1>\n<p>使用全局刷新， 实现计算bmi</p>\n<p>可以使用jsp显示request作用域中的数据，使用el表达式</p>\n<p>也可以使用HttpServletResponse对象输出数据， 数据给了浏览器。 浏览器可以接收HttpServletResponse对象print的数据</p>\n<h1>8 同步请求和异步请求</h1>\n<p>看open(请求方式， 访问uri地址，boolean是不是异步的)</p>\n<p>true：异步请求</p>\n<p>false：同步请求</p>\n<h1>第二章 jQuery</h1>\n<ol>\n<li>\n<p>jquery的介绍</p>\n<p>jquery就是js函数库， 里面有大量的js函数， 使用这些函数操作dom对象， 做事件，动画， ajax处理</p>\n<p>地址： https://jquery.com/</p>\n</li>\n<li>\n<p>下载</p>\n<p>下载地址：https://jquery.com/download/</p>\n<p>压缩版本： 文件体积比较小，适合项目上线后使用。   jquery-3.4.1.min.js</p>\n<p>未压缩：体积比较大，可读性比较好，适合开发阶段使用  jquery-3.4.1.js</p>\n</li>\n</ol>\n<h2>2.1 使用jquery</h2>\n<p>步骤：</p>\n<ol>\n<li>\n<p>需要在你的项目中加入jquery的文件， idea中是把jquery放在webapp目录。一般是创建一个js目录。存放js文件的。 对于hbuilder工具， 放在项目的js目录中就可以了</p>\n</li>\n<li>\n<p>创建一个html文件或者jsp都可以， 在文件中使用</p>\n<pre><code class=\"language-xml\">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery的文件的相对路径&quot; /&gt; 这样是不行的\n&lt;script type=&quot;text/javascript&quot; src=&quot;jquery的文件的相对路径&quot; /&gt;&lt;/script&gt;这样是可以的\n</code></pre>\n</li>\n<li>\n<p>在js代码中，调用jquery中函数</p>\n</li>\n</ol>\n<pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n	&lt;head&gt;\n		&lt;meta charset=&quot;utf-8&quot;&gt;\n		&lt;title&gt;第一个jquery例子&lt;/title&gt;\n		&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt;\n		&lt;script type=&quot;text/javascript&quot;&gt;\n			\n			/*\n			  $:jquery中的函数名\n			  document:是参数\n			  $(document): 把js中的document对象变成jquery可以使用的对象。\n			               然后调用ready()的函数。 这个ready()是jquery中的函数\n						   \n						   ready()的执行时间在页面dom对象加载后执行的。相当于js中onload事件\n					\n			  ready(函数):表示在页面对象加载后执行 这个函数\n			*/\n			/* $(document).ready(function(){\n				alert(&quot;使用jquery了&quot;)\n			}) */\n			\n			/* $(document).ready( myinit() )\n			function myinit(){\n				alert(&quot;====相当于onload==&quot;)\n			} */\n			\n			//jquery提供了简单方式,使用ready()\n			//$(  参数是一个函数 )\n			$( function(){\n				alert(&quot;简单的方式使用ready&quot;)\n			} )\n			\n		&lt;/script&gt;\n	&lt;/head&gt;\n	&lt;body&gt;\n	&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2>2.2 对象的分类</h2>\n<p>dom对象和jquery对象。 在一个文件中同时存在两种对象</p>\n<p>dom对象： 使用js的代码获取，创建的对象。  html中的对象都是dom对象。</p>\n<p>jquery对象： 使用jquery获取获取的对象。</p>\n<p>为什么要使用dom对象，还有jquery对象？</p>\n<p>目的是要dom对象的函数或者属性， 以及使用使用jquery中提供的函数或者属性。</p>\n<p>要 dom中的内容就需要使用dom对象， 要使用jquery函数库中的函数需要使用jquery对象。</p>\n<p>dom对象和jquery对象可以相互转换的</p>\n<h3>2.2.1. dom对象转为jquery对象。</h3>\n<p>语法： $( dom对象 ) 得到的是一个jquery对象， 可以调用jquery中提供的函数</p>\n<pre><code class=\"language-javascript\">&lt;input type=&quot;text&quot; id=&quot;t1&quot; /&gt;\n//通过js的函数，获取dom对象\nvar dom= document.getElementById(&quot;t1&quot;);\n//把dom转为jquery\nvar jqueryObj = $(dom);\n//调用jquery中的函数\njqueryObject.val();//获取dom对象的value属性的值\n\n提示：为了区分dom对象和jquery对象，可以在jquery对象变量名上，加一个$ , 例如 $obj \n</code></pre>\n<h3>2.2.2 jquery对象转为dom对象。</h3>\n<p>语法： jquery对象是一个数组， 数组成员是dom对象。 使用 [下标] 或 get(下标)</p>\n<pre><code class=\"language-javascript\">&lt;input type=&quot;text&quot; id=&quot;txt1&quot;/&gt;\n使用jquery的方式表示这个dom对象\n$(&quot;#txt1&quot;):获取id是txt1的dom对象。 \nvar  obj = $(&quot;#txt1&quot;); //obj是一个jquery对象，是一个包含了一个成员的dom数组。  obj[0]就是dom对象\n\nvar dom = obj[0]; 或者 obj.get(0)\n\n//使用dom对象的函数或者属性\nalert(dom.value)\n</code></pre>\n<h2>2.3 选择器</h2>\n<p>什么是选择器： 选择器就是一个字符串， 是一个定位dom对象的字符串。 使用这个字符串作为条件定位dom对象。 可以使用 id ，class样式名称， 标签名称等作为选择器使用，定位dom对象</p>\n<h3>2.3.1 基本选择器</h3>\n<p>使用dom对象的id， class名称， 标签名称等作为条件定位dom对象。</p>\n<ol>\n<li>\n<p>使用dom对象的id作为条件</p>\n<p>语法： $(&quot;#id&quot;)   document.getElementById(&quot;id&quot;)</p>\n</li>\n<li>\n<p>class选择器，使用对象的class名称定位dom对象</p>\n<p>语法：$(&quot;.class名称&quot;)  document.getElementsByClassName()</p>\n</li>\n<li>\n<p>标签选择器，使用标签名称作为条件定位dom对象</p>\n<p>语法：$(&quot;标签名称&quot;)  document.getElementsByTagName()</p>\n</li>\n<li>\n<p>所有选择器</p>\n<p>语法： $(&quot;*&quot;)</p>\n</li>\n<li>\n<p>组合选择器</p>\n<p>语法：$(&quot;#id,.class,标签名称&quot;)</p>\n<p>组合选择器使用 id 或者class名称或者标签名称定位dom对象， id，class，标签名称可以任意组合。</p>\n</li>\n</ol>\n<h3>2.3.2 表单选择器</h3>\n<p>表单选择器使用 dom对象的type属性值定位dom对象的， 和form标签无关。</p>\n<p>语法： $(&quot;:type属性值&quot;)</p>\n<p>例如：</p>\n<pre><code class=\"language-javascript\">&lt;input type=&quot;text&quot; /&gt;\n&lt;input type=&quot;text&quot; /&gt;\n    \n使用表单选择器： $(&quot;:text&quot;)\n</code></pre>\n<h2>2.4 过滤器</h2>\n<p>过滤器是一个字符串，用了筛选dom对象的， 过滤器是和选择器一起使用的。 在选择了dom对象后，在进行过滤筛选。</p>\n<h3>2.4.1 基本过滤器</h3>\n<p>使用dom对象在数组中的位置，作为过滤条件的。</p>\n<p>1）选择数组中第一个dom成员</p>\n<p>语法：$(&quot;选择器:first&quot;)</p>\n<ol start=\"2\">\n<li>选择数组中最后一个成员</li>\n</ol>\n<p>语法：$(&quot;选择器:last&quot;)</p>\n<ol start=\"3\">\n<li>选择等于指定下标的dom成员</li>\n</ol>\n<p>语法：$(&quot;选择器:eq(下标)&quot;)</p>\n<p>4）选择大于某个下标的所有成员</p>\n<p>语法：$(&quot;选择器:gt(下标)&quot;)</p>\n<p>5）选择小于某个下标的所有成员</p>\n<p>语法：$(&quot;选择器:lt(下标)&quot;)</p>\n<h3>2.4.2 表单过滤器</h3>\n<p>根据对象的状态作为条件，筛选dom对象</p>\n<p>1）获取可用的文本框</p>\n<p>语法：$(&quot;:text:enabled&quot;)</p>\n<ol start=\"2\">\n<li>获取不可用的文本框</li>\n</ol>\n<p>语法： $(&quot;:text:disabled&quot;)</p>\n<p>3）获取选中的复选框</p>\n<p>语法：$(&quot;:checkbox:checked&quot;)</p>\n<ol start=\"4\">\n<li>获取选中下拉列表框</li>\n</ol>\n<p>语法： $(&quot;选择器 &gt; option:selected&quot;)</p>\n<pre><code class=\"language-html\">&lt;select id=&quot;lang&quot;&gt;\n    &lt;option value=&quot;java&quot;&gt;java&lt;/option&gt;\n    &lt;option value=&quot;sql&quot;&gt;sql&lt;/option&gt;\n&lt;/select&gt;\n</code></pre>\n<h2>2.5 函数</h2>\n<h3>2.5.1 第一组函数</h3>\n<p>1）val()：操作dom对象的value值</p>\n<p>val(): 没有参数， 获取dom数组中第一个dom对象的value值</p>\n<p>val(参数)： 有参数， 给dom数组中所有dom对象的value属性赋值</p>\n<p>2）text() : 操作标签的文本内容，标签开始和结束之间的内容</p>\n<p>text(): 没有参数， 把dom数组中所有dom对象的文本内容链接起来，形成一个字符串，并返回这个这个字符串。</p>\n<p>text(参数)：给dom数组中的所有成员统一赋予新的文本</p>\n<p>3）attr(): 操作value ，文本以外的属性时。</p>\n<p>attr(&quot;属性名&quot;)：获取dom数组中第一个dom成员的此属性值</p>\n<p>attr(&quot;属性名&quot;,&quot;属性值&quot;)：给dom数组中所有dom成员此属性赋值</p>\n<h3>2.5.2 第二组函数</h3>\n<p>1） remove()</p>\n<p>删除选择的dom对象和他的子对象</p>\n<p>语法： $(”选择器“).remove()</p>\n<p>2） empty()</p>\n<p>删除dom对象的子对象</p>\n<p>语法： $(&quot;选择器&quot;).empty()</p>\n<ol start=\"3\">\n<li>append()</li>\n</ol>\n<p>给dom对象在他的后面增加新的dom对象</p>\n<p>语法： $(&quot;选择器&quot;).append( 子dom 对象 )</p>\n<ol start=\"4\">\n<li>html()</li>\n</ol>\n<p>html(): 获取dom数组中第一个dom对象的文本值（ html()返回结果相当于innertHTML ）</p>\n<p>html(参数)：给dom数组中所有成员设置新的文本内容。 （html()返回结果相当于innertHTML ）</p>\n<p>5)each()</p>\n<p>each是循环函数， 可以循环数组， json ， dom对象数组</p>\n<p>① $.each( 要循环的内容， function(index,element ){  处理函数} )</p>\n<p>要循环的内容: 可以是数组， json对象， dom对象数组。</p>\n<p>function： 循环的处理函数， 每个成员都会执行函数一次。</p>\n<p>​                     index：是循环变量的值， 名称自定义</p>\n<p>​                    element： 和index对应的成员， element名称是自定义的</p>\n<p>例如</p>\n<p>doArrayContent： function(index,element ){  处理函数} )</p>\n<p>② $(&quot;选择器&quot;).each(function(index,element){ 处理函数} )</p>\n<p>可以对jquery对象进行循环处理。 jquery对象就是dom数组</p>\n<h2>2.6 事件</h2>\n<p>jquery可以给dom对象绑定事件，在程序执行期间动态的处理事件</p>\n<h3>2.6.1 第一种事件绑定语法</h3>\n<p>语法： $(&quot;选择器&quot;).事件名称(事件的处理函数)</p>\n<p>$(&quot;选择器&quot;)：选择0或多个dom对象。给他们绑定事件</p>\n<p>事件名称： 就是js中的 去掉on的部分。 例如单击事件onclick, 这里的事件名称就是 click</p>\n<p>事件的处理函数: 函数定义， 当事件发生时，执行这个函数。</p>\n<pre><code class=\"language-javascript\">例如：\n&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;绑定事件&quot;/&gt;\n\n 绑定事件\n$(&quot;#btn&quot;).click( function(){ 单击的处理代码 } )\n\n$(&quot;:button&quot;).click(function(){ 单击处理代码})\n</code></pre>\n<pre><code class=\"language-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n			\n			$(function(){\n				//页面dom对象加载后执行, 相当于onload事件\n				//绑定事件\n				$(&quot;#btn&quot;).click(function(){\n					alert(&quot;==button单击了，执行处理函数==&quot;)\n				})\n			})\n			\n		\n		&lt;/script&gt;\n&lt;body&gt;\n    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;绑定事件&quot; /&gt;&lt;br/&gt;\n&lt;/body&gt;\n</code></pre>\n<h3>2.6.2 第二种事件绑定方式， on</h3>\n<p>语法： $(&quot;选择器&quot;).on( 事件名称, function(){事件处理函数})</p>\n<p>事件： 就是js中去掉on的部分。</p>\n<p>function： 事件处理函数</p>\n<pre><code class=\"language-javascript\">\n&lt;body&gt;\n    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;绑定事件&quot; /&gt;&lt;br/&gt;\n&lt;/body&gt;\n&lt;script&gt;\n    $(&quot;#btn&quot;).on(&quot;click&quot;,function(){ alert(&quot;按钮单击了&quot;)})\n&lt;/script&gt;        \n</code></pre>\n<h2>2.7 Ajax</h2>\n<p>使用jquery提供的函数实现ajax请求的处理。 代替直接使用XMLHttpRequest.  但是jquery实际还是使用的异步对象。</p>\n<h3>2.7.1 $.ajax() 核心的函数</h3>\n<p>语法： $.ajax( { json格式的参数}  )</p>\n<p>json格式的参数：key是定义好的， 需要开发人员给key赋值。  这些key是用来表示ajax请求必须的参数</p>\n<p>例如，请求的uri地址， 是不是异步请求， 请求的方式等等。</p>\n<pre><code class=\"language-javascript\">\n$.ajax(\n  {\n      url:&quot;queryProvinceServlet&quot;,\n      type:&quot;get&quot;,\n      data:{&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:20},\n      dataType:&quot;json&quot;,\n      success:function(resp) { 开发人员获取数据，更新dom对象 },\n      error:function(){ alert(&quot;请求错误&quot;)}\n  }\n\n)\n</code></pre>\n<p>url：服务器的地址，例如某个servlet的访问地址。  queryProvinceServlet</p>\n<p>type:表示请求的方式，get，post。 默认是get。   这个值不用区分大小写</p>\n<p>data：表示提交的请求参数。 可以是string， 数组， json类型的。 推荐使用json格式。</p>\n<p>​            例如： data: {&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:20}</p>\n<p>​            jquery在发送请求时，会把json中的key作为请求的参数使用， key对应的值作为参数数据。</p>\n<p>​           转为的结果： http://localhost:8080/myweb/queryProvinceServlet?name=李四&amp;age=20</p>\n<p>dataType: 数据格式， 可以是 html， text ， xml ，json等等。 表示发起请求后，希望服务器端返回的数据格式。  jquery可以尝试使用对应格式处理返回的数据。 比如你指定了 dataType:json,表示希望服务器返回的是json格式数据。 然后jquery把json数据转为json对象。服务器代码可以获取到 dataType的内容。</p>\n<p>​         例如： 请求中 dataType:&quot;json&quot;,  jquery发起请求后，</p>\n<p>​                      在请求头中 Accept: application/json, text/javascript, <em>/</em>; q=0.01</p>\n<p>​                    如果dataType:&quot;text&quot;, 请求中</p>\n<p>​                      Accept: text/plain, <em>/</em>; q=0.01</p>\n<p>success: 函数function。 当服务器端返回了数据，jquery处理完数据后，执行这个函数。 等同于异步对象的        readyState==4 $$ status=200的情况</p>\n<p>​                例如： success:function( data){  开发人员处理服务器返回的数据  }</p>\n<p>​                            data是自定义形参， 相当于  data= xhr.responseText</p>\n<p>error:function(), 当请求错误时，执行这个函数。</p>\n<p>contentType:表示请求的参数数据格式。例如 application/json , 这个内容可以不写。</p>\n<p>async: 是一个boolean表示请求是同步的还是异步的。 true是异步的，默认是true； false同步的.</p>\n<h3>2.7.2 $.get()</h3>\n<p>$.get()这个函数就是执行get请求方式的ajax</p>\n<p>语法： $.get(url, 请求参数， success函数， dataType)</p>\n<p>例如：</p>\n<pre><code class=\"language-javascript\">$.get(&quot;queryName&quot;,{&quot;proid&quot;:1}, function(resp){ 获取省份名称 }, &quot;text&quot;)\n</code></pre>\n<h3>2.7.3 $.post()</h3>\n<p>$.post() 执行post请求的ajax。</p>\n<p>语法： $.post(url, 请求参数， success函数， dataType)</p>\n<p>例如：</p>\n<pre><code class=\"language-javascript\">$.post(&quot;queryName&quot;,{&quot;proid&quot;:1}, function(resp){ 获取省份名称 }, &quot;text&quot;)\n</code></pre>\n<h2>2.8 级联查询</h2>\n<p>思路：有两个数据库的查询 1： 查询所有的省份名称和id  ； 2 根据提交的省份id ，查询city表，得到城市列表</p>\n<p>​            有两个servlet接收请求， 一个查询所有的省份 ；一个是接收省份id的参数，查询省份对应的城市列表。</p>\n<p>​            数据格式使用 json</p>\n<p>​            发起请求使用 $.ajax, $.get, $.post</p>\n<p>​            事件： onChange()</p>\n<p>实现步骤：</p>\n<p>1.数据表province( 获取全部的id和name列的值)，</p>\n<p>city表根据provinceid的值，得到id，name列</p>\n<p>2.创建web应用。 加入mysql驱动的jar 和jackson的jar</p>\n<p>3.创建实体类， Province , City</p>\n<p>4.创建Dao类， QueryDao类，有两个方法</p>\n<p>5.创建Servlet， 两个servlet ，一个是查询所有的省份名称， 一个是查询城市列表</p>\n<p>6.创建jsp， 发起两个ajax请求。</p>\n', 'Ajax', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 10:22:39', 1, '2023-02-21 10:22:39', 1);
INSERT INTO `lzh_article` VALUES (1627862187783540737, '正则表达式', NULL, '<h1>一、正则表达式语法</h1>\n<h2>1.1 元字符——转义符 <code>\\\\</code></h2>\n<p>需要用到转义符号的字符有以下：</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207082300562431676947553307.png\" alt=\"image-20220708230056243\" /></p>\n<h2>1.2 元字符——字符匹配符</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207082301473111676947553307.png\" alt=\"image-20220708230147311\" /></p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207082302317431676947553307.png\" alt=\"image-20220708230231743\" /></p>\n<h2>1.3 选择匹配符 <code>|</code></h2>\n<blockquote>\n<p>表示既可以匹配这个，又可以匹配那个</p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207091858421441676947553309.png\" alt=\"image-20220709185842144\" /></p>\n<h2>1.4 元字符——限定符</h2>\n<blockquote>\n<p>用于指定其前面的字符和组合项连续出现多少次</p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207091901543811676947553310.png\" alt=\"image-20220709190154381\" /></p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207091905367301676947553312.png\" alt=\"image-20220709190536730\" /></p>\n<p><code>{n}</code>：表示匹配指定的n个字符</p>\n<p><code>细节：Java匹配默认贪婪匹配，即尽可能匹配多的</code></p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207091921148471676947553315.png\" alt=\"image-20220709192114847\" /></p>\n<h2>1.5 元字符——定位符</h2>\n<blockquote>\n<p>定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置</p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207102002357951676947553314.png\" alt=\"image-20220710200235795\" /></p>\n<h2>1.6 分组</h2>\n<h3>1.6.1 常用分组</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207102047359031676947553314.png\" alt=\"image-20220710204735903\" /></p>\n<pre><code class=\"language-java\">/**\n * 非命名分组\n * 1.matcher.group(0) 得到匹配到的字符串\n * 2.matcher.group(1) 得到匹配的字符串的第1个分组内容\n * 3.matcher.group(1) 得到匹配的字符串的第2个分组内容\n */\n\nString content = &quot;hanshunping s7789 nn1189han&quot;;\nString regStr = &quot;(\\\\d\\\\d)(\\\\d)(\\\\d)&quot;;\n\nPattern pattern = Pattern.compile(regStr);\nMatcher matcher = pattern.matcher(content);\nwhile (matcher.find()) {\n    System.out.println(matcher.group(0));\n    System.out.println(&quot;分组1&quot; + matcher.group(1));\n    System.out.println(&quot;分组2&quot; + matcher.group(2));\n    System.out.println(&quot;分组3&quot; + matcher.group(3));\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * 命名分组：既可以给分组取名\n *\n */\nString content = &quot;hanshunping s7789 nn1189han&quot;;\nString regStr = &quot;(?&lt;g1&gt;\\\\d\\\\d)(?&lt;g2&gt;\\\\d\\\\d)&quot;;\n\nPattern pattern = Pattern.compile(regStr);\nMatcher matcher = pattern.matcher(content);\nwhile (matcher.find()) {\n    System.out.println(matcher.group(0));\n    System.out.println(&quot;分组1 &quot; + matcher.group(&quot;g1&quot;));\n    System.out.println(&quot;分组2 &quot; + matcher.group(&quot;g2&quot;));\n}\n</code></pre>\n<h3>1.6.2 特别分组</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207102049558991676947553315.png\" alt=\"image-20220710204955899\" /></p>\n<ul>\n<li>\n<p><code>(?:pattern)</code></p>\n<pre><code class=\"language-java\">String content = &quot;hello韩顺平教育 Jack韩顺平老师 韩顺平同学hello&quot;;\n// String regStr = &quot;韩顺平教育|韩顺平老师|韩顺平同学&quot;;\nString regStr = &quot;韩顺平(?:教育|老师|同学)&quot;; //等价于上面的写法\n\nPattern pattern = Pattern.compile(regStr);\nMatcher matcher = pattern.matcher(content);\nwhile (matcher.find()) {\n    System.out.println(matcher.group(0));\n}\n//------------------输出\n韩顺平教育\n韩顺平老师\n韩顺平同学\n</code></pre>\n</li>\n<li>\n<p><code>(?=pattern)</code></p>\n<pre><code class=\"language-java\">String content = &quot;hello韩顺平教育 Jack韩顺平老师 韩顺平同学hello&quot;;\n    String regStr = &quot;韩顺平(?=教育|老师)&quot;; //等价于上面的写法\n\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) {\n        System.out.println(matcher.group(0));\n    }\n}\n//---------------------输出\n韩顺平\n韩顺平\n</code></pre>\n</li>\n<li>\n<p><code>(?!pattern)</code></p>\n<pre><code class=\"language-java\">String content = &quot;hello韩顺平教育 Jack韩顺平老师 韩顺平同学hello&quot;;\nString regStr = &quot;韩顺平(?!教育|老师)&quot;;\n\nPattern pattern = Pattern.compile(regStr);\nMatcher matcher = pattern.matcher(content);\nwhile (matcher.find()) {\n    System.out.println(matcher.group(0));\n}\n//-------------------输出\n韩顺平\n</code></pre>\n</li>\n</ul>\n<h2>1.7 贪婪和非贪婪匹配 <code>?</code></h2>\n<blockquote>\n<p>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的“。</p>\n</blockquote>\n<pre><code class=\"language-java\">String content = &quot;hello11111111&quot;;\nString regStr1 = &quot;\\\\d+&quot;; //默认是贪婪匹配\nString regStr2 = &quot;\\\\d+？&quot;; //非贪婪匹配\n\nPattern pattern = Pattern.compile(regStr);\nMatcher matcher = pattern.matcher(content);\nwhile (matcher.find()) {\n    System.out.println(matcher.group(0));\n}\n</code></pre>\n<h1>二、案例</h1>\n<h2>2.1 <code>[a-z]</code> / <code>[A-Z]</code> / <code>0-9</code></h2>\n<blockquote>\n<p>可以匹配a~z / A~Z / 0~9中任意一个字符</p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207091815518881676947553309.png\" alt=\"image-20220709181551888\" /></p>\n<h2>2.2 <code>(?i)</code></h2>\n<ul>\n<li><code>(?i)abc</code>：abc都不区分大小写</li>\n<li><code>a(?i)bc</code>：bc不区分大小写</li>\n<li><code>a(b(?i))c</code>：只有b不区分大小写</li>\n</ul>\n<h2>2.3 <code>Pattern.CASE_INSENSITIVE</code></h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207091827493211676947553309.png\" alt=\"image-20220709182749321\" /></p>\n<h2>2.4 <code>[^A-Z]</code></h2>\n<blockquote>\n<p>表示匹配不是A-Z中的任意一个字符，<code>[^0-9]</code>类似</p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207091840499051676947553309.png\" alt=\"image-20220709184049905\" /></p>\n<h2>2.5 <code>[abcd]</code></h2>\n<blockquote>\n<p>表示匹配a b c d 中任意一个字符</p>\n</blockquote>\n<h2>2.6 <code>\\\\D</code></h2>\n<blockquote>\n<p>表示匹配不是0-9的任意一个字符</p>\n</blockquote>\n<h2>2.7 <code>\\\\w</code></h2>\n<blockquote>\n<p>匹配任意一个英文字符、数字和下划线，相当于[a-zA-Z0-9_]</p>\n</blockquote>\n<h2>2.8 <code>[^a-zA-Z0-9_]</code></h2>\n<blockquote>\n<p>匹配任意一个不是英文字符、数字和下划线</p>\n</blockquote>\n<h2>2.9 <code>\\\\s</code></h2>\n<blockquote>\n<p>匹配任何空白字符（空格、制表符）</p>\n</blockquote>\n<h2>2.10 <code>\\\\S</code></h2>\n<blockquote>\n<p>匹配任何非空白字符（空格、制表符）</p>\n</blockquote>\n<h2>2.11 <code>.</code></h2>\n<blockquote>\n<p>匹配任意一个非<code>\\n</code>的字符，如果要匹配<code>.</code>本身，则需要使用<code>\\\\.</code></p>\n</blockquote>\n<h1>三、应用实例</h1>\n<pre><code class=\"language-java\">public class RegExp03 {\n    public static void main(String[] args) {\n\n        //汉字\n//        String content = &quot;韩顺平教育&quot;;\n//        String regStr = &quot;^[\\u0391-\\uffe5]+$&quot;;\n\n        //邮政编码：要求是1-9开头的一个六位数\n//        String content = &quot;123456&quot;;\n//        String regStr = &quot;^[1-9]\\\\d{5}$&quot;;\n\n        //QQ号码：要求1-9开头的一个5到10位数\n//        String content = &quot;123456&quot;;\n//        String regStr = &quot;^[1-9]\\\\d{4,9}$&quot;;\n\n        //手机号码\n        String content = &quot;13345689879&quot;;\n        String regStr = &quot;^1[3|4|5|8]\\\\d{9}$&quot;;\n\n        Pattern pattern = Pattern.compile(regStr);\n        Matcher matcher = pattern.matcher(content);\n        if (matcher.find()) {\n            System.out.println(&quot;满足格式&quot;);\n        } else {\n            System.out.println(&quot;不满足格式&quot;);\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">    String content = &quot;https://www.bilibili.com/video/BU1fewaffewa?from=search&amp;seid=1341231352&quot;;\n\n    String regStr = &quot;^((http|https)://)?([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w-?=&amp;/%.]*)?$&quot;;\n\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    if (matcher.find()) {\n        System.out.println(&quot;满足格式&quot;);\n    } else {\n        System.out.println(&quot;不满足格式&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n\n    //验证整数和小数\n    String content = &quot;-12.34&quot;;\n    String regStr = &quot;^[-+]?([1-9]\\\\d*|0)(\\\\.\\\\d+)?$&quot;;\n\n    if (content.matches(regStr)) {\n        System.out.println(&quot;匹配成功&quot;);\n    } else {\n        System.out.println(&quot;匹配失败&quot;);\n    }\n}\n</code></pre>\n<h1>四、Pattern类/Matcher类</h1>\n<ul>\n<li>\n<p>Matcher类方法</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207111528246671676947553315.png\" alt=\"image-20220711152824667\" /></p>\n</li>\n</ul>\n<h2>4.1 Pattern.matches()</h2>\n<pre><code class=\"language-java\">String content = &quot;hello edu jack tom smith hello&quot;;\nString regStr = &quot;hello.*&quot;;\n\n//如果使用 Pattern.matches()方法整体匹配 比较简洁\nboolean matches = Pattern.matches(regStr, content);\nSystem.out.println(&quot;整体匹配= &quot; + matches);\n//----------------------------------输出\n整体匹配= true\n</code></pre>\n<h2>4.2 matcher.start()/matcher.end()</h2>\n<pre><code class=\"language-java\">String content = &quot;hello edu jack hello tom smith hello&quot;;\nString regStr = &quot;hello&quot;;\n\n//如果使用 Pattern.matches()方法整体匹配 比较简洁\nPattern pattern = Pattern.compile(regStr);\nMatcher matcher = pattern.matcher(content);\nwhile (matcher.find()) {\n    System.out.println(&quot;===================&quot;);\n    System.out.println(matcher.start());\n    System.out.println(matcher.end());\n}\n//------------------------输出\n===================\n0\n5\n===================\n15\n20\n===================\n31\n36\n</code></pre>\n<h2>4.3 matcher.replaceAll()</h2>\n<pre><code class=\"language-java\">public class RegExp03 {\n    public static void main(String[] args) {\n\n        String content = &quot;hello edu jack hspedu hspedu world&quot;;\n\n        //将hspedu替换成 韩顺平教育\n        String regStr = &quot;hspedu&quot;;\n\n        Pattern pattern = Pattern.compile(regStr);\n        Matcher matcher = pattern.matcher(content);\n        //注意：返回的字符串才是替换后的字符串，原来的content不变化\n        String newContent = matcher.replaceAll(&quot;韩顺平教育&quot;);\n        System.out.println(newContent);\n        System.out.println(content);\n    }\n}\n//---------------------------------------输出\nhello edu jack 韩顺平教育 韩顺平教育 world\nhello edu jack hspedu hspedu world\n</code></pre>\n<h1>五、反向引用</h1>\n<h2>5.1 分组、捕获、反向引用概念</h2>\n<p>1.分组\n我们可以用圆括号组成一个比较复杂的四配模式，那么一个圆括号的部分我们可以看作是一个子表达式/一个分组。</p>\n<p>2.捕获\n把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。组0代表的是整个正则式</p>\n<p>3.反向引用\n圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为<code>反向引用</code>，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，内部反向引用<code>\\\\分组号</code>，外部反向引用<code>$分组号</code></p>\n<h2>5.2 案例</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202207111540164901676947553309.png\" alt=\"image-20220711154016490\" /></p>\n<ol start=\"4\">\n<li>\n<p>请在字符串中检索商品编号,形式如:12321-333999111这样的号码,要求满足前面是一个五位数,然后一个-号,然后是一个九位数,连续的每三位要相同</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n\n    String content = &quot;12312-888999444&quot;;\n\n    String regStr = &quot;\\\\d{5}-(\\\\d)\\\\1{2}(\\\\d)\\\\2{2}(\\\\d)\\\\3{2}&quot;;\n\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) {\n        System.out.println(matcher.group(0));\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>结巴去重案例</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    String content = &quot;我....我要.....学学学学.....编程Java！&quot;;\n\n    //        去掉所有的 .\n    String regStr = &quot;\\\\.&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    content = matcher.replaceAll(&quot;&quot;);\n\n    //        //2.去掉重复的字\n    //        //(1)使用(.)\\\\1+\n    //        pattern = Pattern.compile(&quot;(.)\\\\1+&quot;);\n    //        matcher = pattern.matcher(content);\n    //        while (matcher.find()) {\n    //            System.out.println(matcher.group(0));\n    //        }\n    //        //(2)使用反向引用$1 来替换匹配到的内容\n    //        content = matcher.replaceAll(&quot;$1&quot;);\n    //        System.out.println(content);\n\n    //3.使用一条语句去掉重复的字\n    content = Pattern.compile(&quot;(.)\\\\1+&quot;).matcher(content).replaceAll(&quot;$1&quot;);\n    System.out.println(content);\n}\n</code></pre>\n</li>\n</ol>\n<h1>六、String类中使用正则表达式</h1>\n<pre><code class=\"language-java\">public class RegExp03 {\n    public static void main(String[] args) {\n\n        //验证电话号码\n        String content = &quot;13836473829&quot;;\n        if (content.matches(&quot;13[8|9]\\\\d{8}&quot;)) {\n            System.out.println(&quot;success&quot;);\n        } else {\n            System.out.println(&quot;fail&quot;);\n        }\n\n        //将JDK1.x 替换成 JDK\n        content = &quot;JDK1.3 JDK1.4 JDK1.3&quot;;\n        content = content.replaceAll(&quot;JDK1\\\\.[3|4]&quot;, &quot;JDK&quot;);\n        System.out.println(content);\n\n        //分割字符\n        content = &quot;hello#abc~jack12smith~北京&quot;;\n        String[] split = content.split(&quot;#|~|\\\\d+&quot;);\n        for (String s : split) {\n            System.out.println(s);\n        }\n    }\n}\n//-------------------------------------------输出\nsuccess\n\nJDK JDK JDK\n\nhello\nabc\njack\nsmith\n北京\n</code></pre>\n', '正则表达式', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 10:46:04', 1, '2023-02-21 10:46:04', 1);
INSERT INTO `lzh_article` VALUES (1627899980027076609, '如何定义统一返回结果对象', '<h1><a id=\"_0\"></a>定义统一返回结果对象</h1>\n<h2><a id=\"_2\"></a>一、</h2>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.atguigu.common.result;\n\n\n<span class=\"hljs-keyword\">import</span> lombok.Data;\n\n<span class=\"hljs-comment\">/**\n * 全局统一返回结果类\n *\n */</span>\n<span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Result</span>&lt;T&gt; {\n\n    <span class=\"hljs-comment\">//返回码</span>\n    <span class=\"hljs-keyword\">private</span> Integer code;\n\n    <span class=\"hljs-comment\">//返回消息</span>\n    <span class=\"hljs-keyword\">private</span> String message;\n\n    <span class=\"hljs-comment\">//返回数据</span>\n    <span class=\"hljs-keyword\">private</span> T data;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Result</span><span class=\"hljs-params\">()</span>{}\n\n    <span class=\"hljs-comment\">// 返回数据</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; Result&lt;T&gt; <span class=\"hljs-title function_\">build</span><span class=\"hljs-params\">(T data)</span> {\n        Result&lt;T&gt; result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Result</span>&lt;T&gt;();\n        <span class=\"hljs-keyword\">if</span> (data != <span class=\"hljs-literal\">null</span>)\n            result.setData(data);\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; Result&lt;T&gt; <span class=\"hljs-title function_\">build</span><span class=\"hljs-params\">(T body, Integer code, String message)</span> {\n        Result&lt;T&gt; result = build(body);\n        result.setCode(code);\n        result.setMessage(message);\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; Result&lt;T&gt; <span class=\"hljs-title function_\">build</span><span class=\"hljs-params\">(T body, ResultCodeEnum resultCodeEnum)</span> {\n        Result&lt;T&gt; result = build(body);\n        result.setCode(resultCodeEnum.getCode());\n        result.setMessage(resultCodeEnum.getMessage());\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span>&lt;T&gt; Result&lt;T&gt; <span class=\"hljs-title function_\">ok</span><span class=\"hljs-params\">()</span>{\n        <span class=\"hljs-keyword\">return</span> Result.ok(<span class=\"hljs-literal\">null</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 操作成功\n     * <span class=\"hljs-doctag\">@param</span> data  baseCategory1List\n     * <span class=\"hljs-doctag\">@param</span> &lt;T&gt;\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span>&lt;T&gt; Result&lt;T&gt; <span class=\"hljs-title function_\">ok</span><span class=\"hljs-params\">(T data)</span>{\n        Result&lt;T&gt; result = build(data);\n        <span class=\"hljs-keyword\">return</span> build(data, ResultCodeEnum.SUCCESS);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span>&lt;T&gt; Result&lt;T&gt; <span class=\"hljs-title function_\">fail</span><span class=\"hljs-params\">()</span>{\n        <span class=\"hljs-keyword\">return</span> Result.fail(<span class=\"hljs-literal\">null</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 操作失败\n     * <span class=\"hljs-doctag\">@param</span> data\n     * <span class=\"hljs-doctag\">@param</span> &lt;T&gt;\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span>&lt;T&gt; Result&lt;T&gt; <span class=\"hljs-title function_\">fail</span><span class=\"hljs-params\">(T data)</span>{\n        Result&lt;T&gt; result = build(data);\n        <span class=\"hljs-keyword\">return</span> build(data, ResultCodeEnum.FAIL);\n    }\n\n    <span class=\"hljs-keyword\">public</span> Result&lt;T&gt; <span class=\"hljs-title function_\">message</span><span class=\"hljs-params\">(String msg)</span>{\n        <span class=\"hljs-built_in\">this</span>.setMessage(msg);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>;\n    }\n\n    <span class=\"hljs-keyword\">public</span> Result&lt;T&gt; <span class=\"hljs-title function_\">code</span><span class=\"hljs-params\">(Integer code)</span>{\n        <span class=\"hljs-built_in\">this</span>.setCode(code);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>;\n    }\n}\n</code></div></pre>\n<p>统一返回结果状态信息类</p>\n<p>下面的状态后续都会用到，所以直接引入了</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.atguigu.common.result;\n\n<span class=\"hljs-keyword\">import</span> lombok.Getter;\n\n<span class=\"hljs-comment\">/**\n * 统一返回结果状态信息类\n *\n */</span>\n<span class=\"hljs-meta\">@Getter</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">ResultCodeEnum</span> {\n\n    SUCCESS(<span class=\"hljs-number\">200</span>,<span class=\"hljs-string\">&quot;成功&quot;</span>),\n    FAIL(<span class=\"hljs-number\">201</span>, <span class=\"hljs-string\">&quot;失败&quot;</span>),\n    SERVICE_ERROR(<span class=\"hljs-number\">2012</span>, <span class=\"hljs-string\">&quot;服务异常&quot;</span>),\n    DATA_ERROR(<span class=\"hljs-number\">204</span>, <span class=\"hljs-string\">&quot;数据异常&quot;</span>),\n    ILLEGAL_REQUEST(<span class=\"hljs-number\">205</span>, <span class=\"hljs-string\">&quot;非法请求&quot;</span>),\n    REPEAT_SUBMIT(<span class=\"hljs-number\">206</span>, <span class=\"hljs-string\">&quot;重复提交&quot;</span>),\n    ARGUMENT_VALID_ERROR(<span class=\"hljs-number\">210</span>, <span class=\"hljs-string\">&quot;参数校验异常&quot;</span>),\n\n    LOGIN_AUTH(<span class=\"hljs-number\">208</span>, <span class=\"hljs-string\">&quot;未登陆&quot;</span>),\n    PERMISSION(<span class=\"hljs-number\">209</span>, <span class=\"hljs-string\">&quot;没有权限&quot;</span>),\n    ACCOUNT_ERROR(<span class=\"hljs-number\">214</span>, <span class=\"hljs-string\">&quot;账号不正确&quot;</span>),\n    PASSWORD_ERROR(<span class=\"hljs-number\">215</span>, <span class=\"hljs-string\">&quot;密码不正确&quot;</span>),\n    LOGIN_MOBLE_ERROR( <span class=\"hljs-number\">216</span>, <span class=\"hljs-string\">&quot;账号不正确&quot;</span>),\n    ACCOUNT_STOP( <span class=\"hljs-number\">217</span>, <span class=\"hljs-string\">&quot;账号已停用&quot;</span>),\n    NODE_ERROR( <span class=\"hljs-number\">218</span>, <span class=\"hljs-string\">&quot;该节点下有子节点，不可以删除&quot;</span>)\n    ;\n\n    <span class=\"hljs-keyword\">private</span> Integer code;\n\n    <span class=\"hljs-keyword\">private</span> String message;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title function_\">ResultCodeEnum</span><span class=\"hljs-params\">(Integer code, String message)</span> {\n        <span class=\"hljs-built_in\">this</span>.code = code;\n        <span class=\"hljs-built_in\">this</span>.message = message;\n    }\n}\n</code></div></pre>\n', '# 定义统一返回结果对象\n\n## 一、\n\n```java\npackage com.atguigu.common.result;\n\n\nimport lombok.Data;\n\n/**\n * 全局统一返回结果类\n *\n */\n@Data\npublic class Result<T> {\n\n    //返回码\n    private Integer code;\n\n    //返回消息\n    private String message;\n\n    //返回数据\n    private T data;\n\n    public Result(){}\n\n    // 返回数据\n    protected static <T> Result<T> build(T data) {\n        Result<T> result = new Result<T>();\n        if (data != null)\n            result.setData(data);\n        return result;\n    }\n\n    public static <T> Result<T> build(T body, Integer code, String message) {\n        Result<T> result = build(body);\n        result.setCode(code);\n        result.setMessage(message);\n        return result;\n    }\n\n    public static <T> Result<T> build(T body, ResultCodeEnum resultCodeEnum) {\n        Result<T> result = build(body);\n        result.setCode(resultCodeEnum.getCode());\n        result.setMessage(resultCodeEnum.getMessage());\n        return result;\n    }\n\n    public static<T> Result<T> ok(){\n        return Result.ok(null);\n    }\n\n    /**\n     * 操作成功\n     * @param data  baseCategory1List\n     * @param <T>\n     * @return\n     */\n    public static<T> Result<T> ok(T data){\n        Result<T> result = build(data);\n        return build(data, ResultCodeEnum.SUCCESS);\n    }\n\n    public static<T> Result<T> fail(){\n        return Result.fail(null);\n    }\n\n    /**\n     * 操作失败\n     * @param data\n     * @param <T>\n     * @return\n     */\n    public static<T> Result<T> fail(T data){\n        Result<T> result = build(data);\n        return build(data, ResultCodeEnum.FAIL);\n    }\n\n    public Result<T> message(String msg){\n        this.setMessage(msg);\n        return this;\n    }\n\n    public Result<T> code(Integer code){\n        this.setCode(code);\n        return this;\n    }\n}\n```\n\n统一返回结果状态信息类\n\n下面的状态后续都会用到，所以直接引入了\n\n```java\npackage com.atguigu.common.result;\n\nimport lombok.Getter;\n\n/**\n * 统一返回结果状态信息类\n *\n */\n@Getter\npublic enum ResultCodeEnum {\n\n    SUCCESS(200,\"成功\"),\n    FAIL(201, \"失败\"),\n    SERVICE_ERROR(2012, \"服务异常\"),\n    DATA_ERROR(204, \"数据异常\"),\n    ILLEGAL_REQUEST(205, \"非法请求\"),\n    REPEAT_SUBMIT(206, \"重复提交\"),\n    ARGUMENT_VALID_ERROR(210, \"参数校验异常\"),\n\n    LOGIN_AUTH(208, \"未登陆\"),\n    PERMISSION(209, \"没有权限\"),\n    ACCOUNT_ERROR(214, \"账号不正确\"),\n    PASSWORD_ERROR(215, \"密码不正确\"),\n    LOGIN_MOBLE_ERROR( 216, \"账号不正确\"),\n    ACCOUNT_STOP( 217, \"账号已停用\"),\n    NODE_ERROR( 218, \"该节点下有子节点，不可以删除\")\n    ;\n\n    private Integer code;\n\n    private String message;\n\n    private ResultCodeEnum(Integer code, String message) {\n        this.code = code;\n        this.message = message;\n    }\n}\n```\n\n', '统一返回结果', 1, 'http://1.117.218.230:9000/test/img_1677044278056.png', '1', '0', 0, 0, 0, 0, '1', 1, '2023-02-21 13:16:15', NULL, '2023-02-22 13:38:03', 0);
INSERT INTO `lzh_article` VALUES (1627901753999536130, 'Docker_1', '<h1>Docker</h1>\n<ul>\n<li>\n<p>官方文档地址:https://www.docker.com/get-started</p>\n</li>\n<li>\n<p>中文参考手册:https://docker_practice.gitee.io/zh-cn/</p>\n</li>\n</ul>\n<hr />\n<h2>1.什么是 Docker</h2>\n<h3>1.1 官方定义</h3>\n<ul>\n<li>最新官网首页</li>\n</ul>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202133061281676956796385.png\" alt=\"image-20201220213306128\" /></p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202142109941676956796385.png\" alt=\"image-20201220214210994\" /></p>\n<pre><code class=\"language-markdown\"># 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n</code></pre>\n<h3>1.2 Docker的起源</h3>\n<pre><code class=\"language-markdown\">Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n</code></pre>\n<h2>2.为什么是Docker</h2>\n<ul>\n<li>\n<p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p>\n<p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p>\n<p><strong>优势1:  一致的运行环境,更轻松的迁移</strong></p>\n</li>\n<li>\n<p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p>\n<p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p>\n<p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p>\n</li>\n<li>\n<p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p>\n<p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p>\n<p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p>\n</li>\n</ul>\n<hr />\n<h2>3.Docker和虚拟机区别</h2>\n<blockquote>\n<p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202224566751676956796393.png\" alt=\"image-20201220222456675\" /></p>\n<p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p>\n<p>|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |</p>\n<hr />\n<h2>4.Docker的安装</h2>\n<h3>4.1 安装docker(centos7.x)</h3>\n<ul>\n<li>\n<p>卸载原始docker</p>\n<pre><code class=\"language-sh\">$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n</code></pre>\n</li>\n<li>\n<p>安装docker依赖</p>\n<pre><code class=\"language-shell\">$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre>\n</li>\n<li>\n<p>设置docker的yum源</p>\n<pre><code class=\"language-bash\">$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n</code></pre>\n</li>\n<li>\n<p>安装最新版的docker</p>\n<pre><code class=\"language-bash\">$ sudo yum install docker-ce docker-ce-cli containerd.io\n</code></pre>\n</li>\n<li>\n<p>指定版本安装docker</p>\n<pre><code class=\"language-bash\">$ yum list docker-ce --showduplicates | sort -r\n$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>关闭docker</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo systemctl stop docker\n</code></pre>\n<ul>\n<li>\n<p>测试docker安装</p>\n<pre><code class=\"language-bash\">$ sudo docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h3>4.2 bash安装(通用所有平台)</h3>\n<ul>\n<li>\n<p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>\n<pre><code class=\"language-bash\">$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>创建docker用户组</p>\n<pre><code class=\"language-bash\">$ sudo groupadd docker\n</code></pre>\n</li>\n<li>\n<p>将当前用户加入docker组</p>\n<pre><code class=\"language-bash\">$ sudo usermod -aG docker $USER\n</code></pre>\n</li>\n<li>\n<p>测试docker安装是否正确</p>\n<pre><code class=\"language-bash\">$ docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h2>5.Docker 的核心架构</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-20200404111908085-02913231676956795993.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>\n<li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>\n<li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>\n<li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>\n<li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li>\n</ul>\n<h2>6. Docker 配置阿里镜像加速服务</h2>\n<h3>6.1 docker 运行流程</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202004041203567841676956795994.png\" alt=\"image-20200404120356784\" /></p>\n<h3>6.2 docker配置阿里云镜像加速</h3>\n<ul>\n<li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li>\n</ul>\n<pre><code class=\"language-shell\">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-\'EOF\'\n{\n  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre>\n<ul>\n<li><code>验证docker的镜像加速是否生效</code></li>\n</ul>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n</code></pre>\n<hr />\n<h2>7.Docker的入门应用</h2>\n<h3>7.1 docker 的第一个程序</h3>\n<blockquote>\n<p>docker  run hello-world</p>\n</blockquote>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>\n<hr />\n<h2>8.常用命令</h2>\n<h3>6.1 辅助命令</h3>\n<pre><code class=\"language-markdown\"># 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n</code></pre>\n<h3>6.2 Images 镜像命令</h3>\n<pre><code class=\"language-markdown\"># 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n</code></pre>\n<h3>6.3 Contrainer 容器命令</h3>\n<pre><code class=\"language-markdown\"># 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签\n</code></pre>\n<hr />\n<h2>7.docker的镜像原理</h2>\n<h3>7.1 镜像是什么？</h3>\n<blockquote>\n<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>\n</blockquote>\n<h3>7.2 为什么一个镜像会那么大？</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202004041429500681676956795994.png\" alt=\"image-20200404142950068\" /></p>\n<p><code>镜像就是花卷</code></p>\n<ul>\n<li>\n<p>UnionFS（联合文件系统）:</p>\n<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p>\n</li>\n</ul>\n<h3>7.3 Docker镜像原理</h3>\n<blockquote>\n<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>\n</blockquote>\n<ul>\n<li>\n<p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>\n</li>\n<li>\n<p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>\n</li>\n<li>\n<p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p>\n</li>\n</ul>\n<p><img src=\"http://1.117.218.230:9000/test/img_1567585172(1)1676956795992.jpg\" alt=\"\" /></p>\n<h3>7.4 为什么docker镜像要采用这种分层结构呢?</h3>\n<blockquote>\n<p><code>最大的一个好处就是资源共享</code></p>\n</blockquote>\n<ul>\n<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>\n</ul>\n<hr />\n<h2>8.Docker安装常用服务</h2>\n<h3>8.1 安装mysql</h3>\n<pre><code class=\"language-markdown\"># 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &lt; /root/xxx.sql\n</code></pre>\n<h3>8.2 安装Redis服务</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n</code></pre>\n<h3>8.3 安装Nginx</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n</code></pre>\n<hr />\n<h3>8.4 安装Tomcat</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n</code></pre>\n<hr />\n<h3>8.5 安装MongoDB数据库</h3>\n<pre><code class=\"language-markdown\"># 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n</code></pre>\n<h3>8.6 安装ElasticSearch</h3>\n<ul>\n<li><code>注意:</code><strong>调高JVM线程数限制数量</strong></li>\n</ul>\n<h4>0.拉取镜像运行elasticsearch</h4>\n<pre><code class=\"language-markdown\"># 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n</code></pre>\n<ul>\n<li>启动出现如下错误</li>\n<li><img src=\"http://1.117.218.230:9000/test/img_image-202006021843217901676956795996.png\" alt=\"image-20200602184321790\" /></li>\n</ul>\n<h4>1. 预先配置</h4>\n<pre><code class=\"language-markdown\"># 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n</code></pre>\n<h4>2.启动EleasticSearch容器</h4>\n<pre><code class=\"language-markdown\"># 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n</code></pre>\n<h4>3.安装IK分词器</h4>\n<pre><code class=\"language-markdown\"># 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	&lt;properties&gt;\n		&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;\n		&lt;!--用户可以在这里配置自己的扩展字典 --&gt;\n		&lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;\n		&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;\n		&lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;\n	&lt;/properties&gt;\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2\n</code></pre>\n<h4>4. 安装Kibana</h4>\n<pre><code class=\"language-markdown\"># 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n</code></pre>\n<hr />\n<h2>10.Docker中出现如下错误解决方案</h2>\n<pre><code class=\"language-powershell\">[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid\n</code></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006021834292861676956795995.png\" alt=\"image-20200602183429286\" /></p>\n<ul>\n<li>注意:<strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></li>\n</ul>\n<pre><code class=\"language-markdown\"># 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n</code></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006021837186231676956795996.png\" alt=\"image-20200602183718623\" /></p>\n<h2>9.Dockerfile</h2>\n<h3>9.1 什么是Dockerfile</h3>\n<p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202004041119080851676956795992.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>\n</ul>\n<h3>9.2 Dockerfile解析过程</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006031812538041676956795996.png\" alt=\"image-20200603181253804\" /></p>\n<h3>9.3 Dockerfile的保留命令</h3>\n<p>官方说明:https://docs.docker.com/engine/reference/builder/</p>\n<p>| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| <strong>FROM</strong>       | <strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code>          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| <strong>RUN</strong>        | <strong>构建镜像时需要运行的指令</strong>                                 |\n| <strong>EXPOSE</strong>     | <strong>当前容器对外暴露出的端口号</strong>                               |\n| <strong>WORKDIR</strong>    | <strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong> |\n| <strong>ENV</strong>        | <strong>用来在构建镜像过程中设置环境变量</strong>                         |\n| <strong>ADD</strong>        | <strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong> |\n| <strong>COPY</strong>       | <strong>类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong> |\n| <strong>VOLUME</strong>     | <strong>容器数据卷，用于数据保存和持久化工作</strong>                     |\n| <strong>CMD</strong>        | <strong>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong> |\n| <strong>ENTRYPOINT</strong> | <strong>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong> |</p>\n<h4>9.3.1 FROM 命令</h4>\n<ul>\n<li>\n<p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">FROM  &lt;image&gt;\nFROM  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest\nFROM  &lt;image&gt;[@&lt;digest&gt;]  使用摘要\n</code></pre>\n</li>\n</ul>\n<h4>9.3.2 MAINTAINER  命令</h4>\n<ul>\n<li>\n<p>镜像维护者的姓名和邮箱地址[废弃]</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">MAINTAINER &lt;name&gt;\n</code></pre>\n</li>\n</ul>\n<h4>9.3.3 RUN 命令</h4>\n<ul>\n<li>\n<p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\nRUN echo hello\n\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)\nRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.4 EXPOSE 命令</h4>\n<ul>\n<li>\n<p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\nEXPOSE 80/udp\n</code></pre>\n</li>\n</ul>\n<h4>9.3.5 CMD 命令</h4>\n<ul>\n<li>\n<p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>\n</li>\n<li>\n<p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)\nCMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)\nCMD command param1 param2 (shell form)\n</code></pre>\n</li>\n</ul>\n<h4>9.3.6 WORKDIR 命令</h4>\n<ul>\n<li>\n<p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">WORKDIR /path/to/workdir\n\nWORKDIR /a\nWORKDIR b\nWORKDIR c\n`注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n</code></pre>\n</li>\n</ul>\n<h4>9.3.7 ENV 命令</h4>\n<ul>\n<li>\n<p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>\n</li>\n<li>\n<p>语法：</p>\n<pre><code class=\"language-dockerfile\">ENV &lt;key&gt; &lt;value&gt;\nENV &lt;key&gt;=&lt;value&gt; ...\n</code></pre>\n</li>\n</ul>\n<h4>9.3.8 ADD 命令</h4>\n<ul>\n<li>\n<p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">ADD hom* /mydir/       通配符添加多个文件\nADD hom?.txt /mydir/   通配符添加\nADD test.txt relativeDir/  可以指定相对路径\nADD test.txt /absoluteDir/ 也可以指定绝对路径\nADD url \n</code></pre>\n</li>\n</ul>\n<h4>9.3.9 COPY 命令</h4>\n<ul>\n<li>\n<p>用来将context目录中指定文件复制到镜像的指定目录中</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">COPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.10 VOLUME 命令</h4>\n<ul>\n<li>\n<p>用来定义容器运行时可以挂在到宿主机的目录</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">VOLUME [&quot;/data&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<ul>\n<li>\n<p>用来指定容器启动时执行命令和CMD类似</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2\n</code></pre>\n<p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。\nCMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<h3>9.4 Dockerfile构建springboot项目部署</h3>\n<h5>1.准备springboot可运行项目</h5>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006051721512661676956795996.png\" alt=\"image-20200605172151266\" /></p>\n<h5>2.将可运行项目放入linux虚拟机中</h5>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006051723403801676956795997.png\" alt=\"image-20200605172340380\" /></p>\n<h5>3.编写Dockerfile</h5>\n<pre><code class=\"language-dockerfile\">FROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]\nCMD [&quot;ems.jar&quot;]\n</code></pre>\n<h5>4.构建镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker build -t ems .\n</code></pre>\n<h5>5.运行镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker run -p 8989:8989 ems\n</code></pre>\n<h5>6.访问项目</h5>\n<pre><code class=\"language-http\">http://10.15.0.8:8989/ems/login.html\n</code></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006051731416361676956796166.png\" alt=\"image-20200605173141636\" /></p>\n<hr />\n<h2>10.高级网络配置</h2>\n<h3>10.1 说明</h3>\n<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href=\"https://tools.ietf.org/html/rfc1918\">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>\n<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202011251058478961676956796324.png\" alt=\"image-20201125105847896\" /></p>\n<h3>10.2 查看网络信息</h3>\n<pre><code class=\"language-markdown\"># docker network ls\n</code></pre>\n<h3>10.3 创建一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network create -d bridge 网桥名称\n</code></pre>\n<h3>10.4 删除一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network rm 网桥名称\n</code></pre>\n<h3>10.5 容器之前使用网络通信</h3>\n<pre><code class=\"language-markdown\"># 1.查询当前网络配置\n- docker network ls\n</code></pre>\n<pre><code class=\"language-shell\">NETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n</code></pre>\n<pre><code class=\"language-markdown\"># 2.创建桥接网络\n- docker network create -d bridge info\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n</code></pre>\n<pre><code class=\"language-markdown\"># 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002\nc315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001\nb63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n.....\n</code></pre>\n<hr />\n<h2>11.高级数据卷配置</h2>\n<h3>11.1 说明</h3>\n<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>\n<ul>\n<li><code>数据卷</code> 可以在容器之间共享和重用</li>\n<li>对 <code>数据卷</code> 的修改会立马生效</li>\n<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>\n<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>\n</ul>\n<blockquote>\n<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>\n</blockquote>\n<h3>11.2 创建数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume create my-vol\nmy-vol\n</code></pre>\n<h3>11.3 查看数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: {},\n        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n        &quot;Name&quot;: &quot;my-vol&quot;,\n        &quot;Options&quot;: {},\n        &quot;Scope&quot;: &quot;local&quot;\n    }\n]\n</code></pre>\n<h3>11.4 挂载数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				&quot;Mounts&quot;: [\n            {\n                &quot;Type&quot;: &quot;volume&quot;,\n                &quot;Name&quot;: &quot;my-vol&quot;,\n                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,\n                &quot;Driver&quot;: &quot;local&quot;,\n                &quot;Mode&quot;: &quot;z&quot;,\n                &quot;RW&quot;: true,\n                &quot;Propagation&quot;: &quot;&quot;\n            }\n        ],\n</code></pre>\n<h3>11.5 删除数据卷</h3>\n<pre><code class=\"language-shell\">docker volume rm my-vol\n</code></pre>\n<hr />\n<h2>12.Docker Compose</h2>\n<h3>12.1 简介</h3>\n<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>\n<p>其代码目前在 https://github.com/docker/compose 上开源。</p>\n<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>\n<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>\n<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>\n<p><code>Compose</code> 中有两个重要的概念：</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>\n</ul>\n<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>\n<h3>12.2 安装与卸载</h3>\n<h6>1.linux</h6>\n<ul>\n<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n</code></pre>\n<h6>2.macos、window</h6>\n<ul>\n<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>\n</ul>\n<h6>3.bash命令补全</h6>\n<pre><code class=\"language-shell\">$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose\n</code></pre>\n<h6>4.卸载</h6>\n<ul>\n<li>如果是二进制包方式安装的，删除二进制文件即可。</li>\n</ul>\n<pre><code class=\"language-shell\">$ sudo rm /usr/local/bin/docker-compose\n</code></pre>\n<h6>5.测试安装成功</h6>\n<pre><code class=\"language-shell\">$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n</code></pre>\n<h3>12.3 docker compose使用</h3>\n<pre><code class=\"language-markdown\"># 1.相关概念\n</code></pre>\n<p>首先介绍几个术语。</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>\n</ul>\n<pre><code class=\"language-markdown\"># 2.场景\n</code></pre>\n<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>\n<ul>\n<li>springboot应用</li>\n<li>mysql服务</li>\n<li>redis服务</li>\n<li>elasticsearch服务</li>\n<li>.......</li>\n</ul>\n<pre><code class=\"language-markdown\"># 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n</code></pre>\n<pre><code class=\"language-yml\">version: &quot;3.0&quot;\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - &quot;3306:3306&quot;\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - &quot;6379:6379&quot;\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n</code></pre>\n<pre><code class=\"language-markdown\"># 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n</code></pre>\n<pre><code class=\"language-bash\">[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n</code></pre>\n<hr />\n<h3>12.4 docker-compose 模板文件</h3>\n<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>\n<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      - &quot;/data&quot;\n</code></pre>\n<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>\n<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>\n<p>下面分别介绍各个指令的用法。</p>\n<h4><code>build</code></h4>\n<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n</code></pre>\n<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>\n<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>\n<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n</code></pre>\n<h4><code>command</code></h4>\n<p>覆盖容器启动后默认执行的命令。</p>\n<pre><code class=\"language-yaml\">command: echo &quot;hello world&quot;\n</code></pre>\n<h4><code>container_name</code></h4>\n<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>\n<pre><code class=\"language-yaml\">container_name: docker-web-container\n</code></pre>\n<blockquote>\n<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>\n</blockquote>\n<h4><code>depends_on</code></h4>\n<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>\n<pre><code class=\"language-yaml\">version: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n</code></pre>\n<blockquote>\n<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>\n</blockquote>\n<h4><code>env_file</code></h4>\n<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>\n<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>\n<pre><code class=\"language-bash\">env_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n</code></pre>\n<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>\n<pre><code class=\"language-bash\"># common.env: Set development environment\nPROG_ENV=development\n</code></pre>\n<h4><code>environment</code></h4>\n<p>设置环境变量。你可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>\n<pre><code class=\"language-yaml\">environment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n</code></pre>\n<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href=\"https://yaml.org/type/bool.html\">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>\n<pre><code class=\"language-bash\">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n</code></pre>\n<h4><code>healthcheck</code></h4>\n<p>通过命令检查容器是否健康运行。</p>\n<pre><code class=\"language-yaml\">healthcheck:\n  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n</code></pre>\n<h4><code>image</code></h4>\n<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>\n<pre><code class=\"language-yaml\">image: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n</code></pre>\n<h4><code>networks</code></h4>\n<p>配置容器连接的网络。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n</code></pre>\n<h4><code>ports</code></h4>\n<p>暴露端口信息。</p>\n<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>\n<pre><code class=\"language-yaml\">ports:\n - &quot;3000&quot;\n - &quot;8000:8000&quot;\n - &quot;49100:22&quot;\n - &quot;127.0.0.1:8001:8001&quot;\n</code></pre>\n<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>\n<h4><code>sysctls</code></h4>\n<p>配置容器内核参数。</p>\n<pre><code class=\"language-yaml\">sysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n</code></pre>\n<h4><code>ulimits</code></h4>\n<p>指定容器的 ulimits 限制值。</p>\n<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>\n<pre><code class=\"language-yaml\">  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n</code></pre>\n<h4><code>volumes</code></h4>\n<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>\n<p>该指令中路径支持相对路径。</p>\n<pre><code class=\"language-yaml\">volumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n</code></pre>\n<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n</code></pre>\n<hr />\n<h3>12.5 docker-compose 常用命令</h3>\n<h5>1. 命令对象与格式</h5>\n<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>\n<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>\n<p><code>docker-compose</code> 命令的基本的使用格式是</p>\n<pre><code class=\"language-bash\">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]\n</code></pre>\n<h5>2. 命令选项</h5>\n<ul>\n<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>\n<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>\n<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>\n<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>\n<li><code>--verbose</code> 输出更多调试信息。</li>\n<li><code>-v, --version</code> 打印版本并退出。</li>\n</ul>\n<h5>3.命令使用说明</h5>\n<h5><code>up</code></h5>\n<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>\n<ul>\n<li>\n<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>\n</li>\n<li>\n<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>\n</li>\n<li>\n<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\n</li>\n<li>\n<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>\n</li>\n<li>\n<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>\n</li>\n<li>\n<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>\n</li>\n<li>\n<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>\n</li>\n</ul>\n<hr />\n<h5><code>down</code></h5>\n<ul>\n<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>\n</ul>\n<hr />\n<h5><code>exec</code></h5>\n<ul>\n<li>进入指定的容器。</li>\n</ul>\n<hr />\n<h5><code>ps</code></h5>\n<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>\n<p>列出项目中目前的所有容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-q</code> 只打印容器的 ID 信息。</li>\n</ul>\n<hr />\n<h5><code>restart</code></h5>\n<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>\n<p>重启项目中的服务。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>rm</code></h5>\n<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>\n<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>\n<li><code>-v</code> 删除容器所挂载的数据卷。</li>\n</ul>\n<hr />\n<h5><code>start</code></h5>\n<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>\n<p>启动已经存在的服务容器。</p>\n<hr />\n<h5><code>stop</code></h5>\n<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>\n<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>top</code></h5>\n<p>查看各个服务容器内运行的进程。</p>\n<hr />\n<h5><code>unpause</code></h5>\n<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>\n<p>恢复处于暂停状态中的服务。</p>\n<hr />\n<h2>13.docker可视化工具</h2>\n<h4>13.1 安装Portainer</h4>\n<p>官方安装说明：<a href=\"http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=\">https://www.portainer.io/installation/</a></p>\n<pre><code class=\"language-shell\">[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer\n</code></pre>\n<h4>13.2 登录和使用Portainer</h4>\n<blockquote>\n<p>用浏览器访问：<code>http://localhost:9000</code></p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012232317077381676956796402.png\" alt=\"image-20201223231707738\" /></p>\n<hr />\n', '# Docker\n\n- 官方文档地址:https://www.docker.com/get-started\n\n- 中文参考手册:https://docker_practice.gitee.io/zh-cn/\n\n-----\n\n## 1.什么是 Docker\n\n### 1.1 官方定义\n\n- 最新官网首页\n\n![image-20201220213306128](Docker_1.assets/image-20201220213306128.png)\n\n![image-20201220214210994](Docker_1.assets/image-20201220214210994.png)\n\n```markdown\n# 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n```\n\n### 1.2 Docker的起源\n\n```markdown\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n```\n\n## 2.为什么是Docker\n\n- `在开发的时候，在本机测试环境可以跑，生产环境跑不起来`\n\n  这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。\n\n  **优势1:  一致的运行环境,更轻松的迁移**\n\n  \n\n- `服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了`\n\n  这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。\n\n  **优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源**\n\n  \n\n- `公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器`\n\n  在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。\n  \n  **优势3: 通过镜像复制N多个环境一致容器**\n\n----\n\n## 3.Docker和虚拟机区别\n\n> 关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。\n\n![image-20201220222456675](Docker_1.assets/image-20201220222456675.png)\n\n`比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重`。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存->虚拟物理内存->真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存->真正物理内存。\n\n|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |\n\n---\n\n## 4.Docker的安装\n\n### 4.1 安装docker(centos7.x)\n\n- 卸载原始docker\n\n  ```sh\n  $ sudo yum remove docker \\\n                    docker-client \\\n                    docker-client-latest \\\n                    docker-common \\\n                    docker-latest \\\n                    docker-latest-logrotate \\\n                    docker-logrotate \\\n                    docker-engine\n  ```\n\n- 安装docker依赖\n\n  ```shell\n  $ sudo yum install -y yum-utils \\\n    device-mapper-persistent-data \\\n    lvm2\n  ```\n\n- 设置docker的yum源\n\n  ```bash\n  $ sudo yum-config-manager \\\n      --add-repo \\\n      https://download.docker.com/linux/centos/docker-ce.repo\n  ```\n\n- 安装最新版的docker\n\n  ```bash\n  $ sudo yum install docker-ce docker-ce-cli containerd.io\n  ```\n\n- 指定版本安装docker\n\n  ```bash\n  $ yum list docker-ce --showduplicates | sort -r\n  $ sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\n  $ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n-  关闭docker\n\n  ```bash\n  $ sudo systemctl stop docker\n  ```\n\n- 测试docker安装\n\n  ```bash\n  $ sudo docker run hello-world\n  ```\n\n### 4.2 bash安装(通用所有平台)\n\n- 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\n\n  ```bash\n  $ curl -fsSL get.docker.com -o get-docker.sh\n  $ sudo sh get-docker.sh --mirror Aliyun\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n- 创建docker用户组\n\n  ```bash\n  $ sudo groupadd docker\n  ```\n\n- 将当前用户加入docker组\n\n  ```bash\n  $ sudo usermod -aG docker $USER\n  ```\n\n- 测试docker安装是否正确\n\n  ```bash\n  $ docker run hello-world\n  ```\n\n## 5.Docker 的核心架构\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085-0291323.png)\n\n- `镜像:` 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等\n- `容器:` 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写\n- `仓库:`用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置\n- `dockerFile:`docker生成镜像配置文件,用来书写自定义镜像的一些配置\n- `tar:`一个对镜像打包的文件,日后可以还原成镜像\n\n## 6. Docker 配置阿里镜像加速服务\n\n### 6.1 docker 运行流程\n\n![image-20200404120356784](Docker_1.assets/image-20200404120356784.png)\n\n### 6.2 docker配置阿里云镜像加速\n\n- `访问阿里云登录自己账号查看docker镜像加速服务`\n\n```shell\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  \"registry-mirrors\": [\"https://lz2nib3q.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n- `验证docker的镜像加速是否生效`\n\n```shell\n[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n```\n\n-----\n\n## 7.Docker的入门应用\n\n### 7.1 docker 的第一个程序\n\n> docker  run hello-world\n\n```shell\n[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n\n----\n\n## 8.常用命令\n\n### 6.1 辅助命令\n\n~~~markdown\n# 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n~~~\n\n### 6.2 Images 镜像命令\n\n~~~markdown\n# 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n~~~\n\n### 6.3 Contrainer 容器命令\n\n~~~markdown\n# 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m \"描述信息\" -a \"作者信息\"   （容器id或者名称）打包的镜像名称:标签\n~~~\n\n----\n\n## 7.docker的镜像原理\n\n### 7.1 镜像是什么？\n\n> 镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。\n\n### 7.2 为什么一个镜像会那么大？\n\n![image-20200404142950068](Docker_1.assets/image-20200404142950068.png)\n\n`镜像就是花卷`\n\n- UnionFS（联合文件系统）:\n\n  Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。	\n\n### 7.3 Docker镜像原理\n\n> `docker的镜像实际是由一层一层的文件系统组成。`\n\n- bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。\n\n- rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。\n\n- 我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。\n\n\n\n![](Docker_1.assets/1567585172(1).jpg)\n\n### 7.4 为什么docker镜像要采用这种分层结构呢?\n\n> `最大的一个好处就是资源共享`\n\n- 比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。\n\n---\n\n## 8.Docker安装常用服务\n\n### 8.1 安装mysql\n\n```markdown\n# 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' < /root/xxx.sql\n```\n\n### 8.2 安装Redis服务\n\n```markdown\n# 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n```\n\n### 8.3 安装Nginx\n\n```markdown\n# 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n```\n\n----\n\n### 8.4 安装Tomcat\n\n```markdown\n# 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n```\n\n-----\n\n### 8.5 安装MongoDB数据库\n\n```markdown\n# 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:\"root\",pwd:\"root\",roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n```\n\n### 8.6 安装ElasticSearch\n\n- `注意:`**调高JVM线程数限制数量**\n\n#### 0.拉取镜像运行elasticsearch\n\n```markdown\n# 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n```\n\n- 启动出现如下错误\n- ![image-20200602184321790](Docker_1.assets/image-20200602184321790.png)\n\n#### 1. 预先配置\n\n```markdown\n# 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n```\n\n#### 2.启动EleasticSearch容器\n\n```markdown\n# 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=\"-Xms128m -Xmx128m\" -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n```\n\n#### 3.安装IK分词器\n\n```markdown\n# 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	<properties>\n		<comment>IK Analyzer 扩展配置</comment>\n		<!--用户可以在这里配置自己的扩展字典 -->\n		<entry key=\"ext_dict\">ext_dict.dic</entry>\n		<!--用户可以在这里配置自己的扩展停止词字典-->\n		<entry key=\"ext_stopwords\">ext_stopwords.dic</entry>\n	</properties>\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=\"xiaochen\" -m=\"es with IKAnalyzer\" 容器id xiaochen/elasticsearch:6.4.2\n```\n\n#### 4. 安装Kibana\n\n```markdown\n# 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n```\n\n----\n\n## 10.Docker中出现如下错误解决方案\n\n```powershell\n[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&n=25: x509: certificate has expired or is not yet valid\n```\n\n![image-20200602183429286](Docker_1.assets/image-20200602183429286.png)\n\n- 注意:**这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步**\n\n```markdown\n# 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n```\n\n![image-20200602183718623](Docker_1.assets/image-20200602183718623.png)\n\n## 9.Dockerfile\n\n### 9.1 什么是Dockerfile\n\nDockerfile可以认为是**Docker镜像的描述文件，是由一系列命令和参数构成的脚本**。主要作用是**用来构建docker镜像的构建文件**。\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085.png)\n\n- **通过架构图可以看出通过DockerFile可以直接构建镜像**\n\n### 9.2 Dockerfile解析过程\n\n![image-20200603181253804](Docker_1.assets/image-20200603181253804.png)\n\n### 9.3 Dockerfile的保留命令\n\n官方说明:https://docs.docker.com/engine/reference/builder/\n\n| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| **FROM**       | **当前镜像是基于哪个镜像的** `第一个指令必须是FROM`          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| **RUN**        | **构建镜像时需要运行的指令**                                 |\n| **EXPOSE**     | **当前容器对外暴露出的端口号**                               |\n| **WORKDIR**    | **指定在创建容器后，终端默认登录进来的工作目录，一个落脚点** |\n| **ENV**        | **用来在构建镜像过程中设置环境变量**                         |\n| **ADD**        | **将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包** |\n| **COPY**       | **类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置** |\n| **VOLUME**     | **容器数据卷，用于数据保存和持久化工作**                     |\n| **CMD**        | **指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换** |\n| **ENTRYPOINT** | **指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数** |\n\n#### 9.3.1 FROM 命令\n\n- 基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现\n\n- 语法:\n\n  ```dockerfile\n  FROM  <image>\n  FROM  <image>[:<tag>]     使用版本不写为latest\n  FROM  <image>[@<digest>]  使用摘要\n  ```\n\n#### 9.3.2 MAINTAINER  命令\n\n- 镜像维护者的姓名和邮箱地址[废弃]\n\n- 语法:\n\n  ```dockerfile\n  MAINTAINER <name>\n  ```\n\n#### 9.3.3 RUN 命令\n\n- RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步\n\n- 语法:\n\n  ```dockerfile\n  RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\n  RUN echo hello\n  \n  RUN [\"executable\", \"param1\", \"param2\"] (exec form)\n  RUN [\"/bin/bash\", \"-c\", \"echo hello\"]\n  ```\n\n#### 9.3.4 EXPOSE 命令\n\n- 用来指定构建的镜像在运行为容器时对外暴露的端口\n\n- 语法:\n\n  ```dockerfile\n  EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\n  EXPOSE 80/udp\n  ```\n\n#### 9.3.5 CMD 命令\n\n- 用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n- 注意: **Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。**\n\n- 语法:\n\n  ```dockerfile\n  CMD [\"executable\",\"param1\",\"param2\"] (exec form, this is the preferred form)\n  CMD [\"param1\",\"param2\"] (as default parameters to ENTRYPOINT)\n  CMD command param1 param2 (shell form)\n  ```\n\n#### 9.3.6 WORKDIR 命令\n\n- 用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。\n\n- 语法:\n\n  ```dockerfile\n  WORKDIR /path/to/workdir\n  \n  WORKDIR /a\n  WORKDIR b\n  WORKDIR c\n  `注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n  ```\n\n#### 9.3.7 ENV 命令\n\n- 用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。\n\n- 语法：\n\n  ```dockerfile\n  ENV <key> <value>\n  ENV <key>=<value> ...\n  ```\n\n#### 9.3.8 ADD 命令\n\n- 用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。\n\n- 语法:\n\n  ```dockerfile\n  ADD hom* /mydir/       通配符添加多个文件\n  ADD hom?.txt /mydir/   通配符添加\n  ADD test.txt relativeDir/  可以指定相对路径\n  ADD test.txt /absoluteDir/ 也可以指定绝对路径\n  ADD url \n  ```\n\n#### 9.3.9 COPY 命令\n\n- 用来将context目录中指定文件复制到镜像的指定目录中\n\n- 语法:\n\n  ```dockerfile\n  COPY src dest\n  COPY [\"<src>\",... \"<dest>\"]\n  ```\n\n#### 9.3.10 VOLUME 命令\n\n- 用来定义容器运行时可以挂在到宿主机的目录\n\n- 语法:\n\n  ```dockerfile\n  VOLUME [\"/data\"]\n  ```\n\n#### 9.3.11 ENTRYPOINT命令\n\n- 用来指定容器启动时执行命令和CMD类似\n\n- 语法:\n\n  ```dockerfile\n    [\"executable\", \"param1\", \"param2\"]\n  ENTRYPOINT command param1 param2\n  ```\n\n  ENTRYPOINT指令，往往用于设置容器启动后的**第一个命令**，这对一个容器来说往往是固定的。\n  CMD指令，往往用于设置容器启动的第一个命令的**默认参数**，这对一个容器来说可以是变化的。\n\n#### 9.3.11 ENTRYPOINT命令\n\n### 9.4 Dockerfile构建springboot项目部署\n\n##### 1.准备springboot可运行项目\n\n![image-20200605172151266](Docker_1.assets/image-20200605172151266.png)\n\n##### 2.将可运行项目放入linux虚拟机中\n\n![image-20200605172340380](Docker_1.assets/image-20200605172340380.png)\n\n##### 3.编写Dockerfile\n\n```dockerfile\nFROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [\"java\",\"-jar\"]\nCMD [\"ems.jar\"]\n```\n\n##### 4.构建镜像\n\n```shell\n[root@localhost ems]# docker build -t ems .\n```\n\n##### 5.运行镜像\n\n```shell\n[root@localhost ems]# docker run -p 8989:8989 ems\n```\n\n##### 6.访问项目\n\n```http\nhttp://10.15.0.8:8989/ems/login.html\n```\n\n![image-20200605173141636](Docker_1.assets/image-20200605173141636.png)\n\n---\n\n## 10.高级网络配置\n\n### 10.1 说明\n\n当 Docker 启动时，会自动在主机上创建一个 `docker0` 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n同时，Docker 随机分配一个本地未占用的私有网段（在 [RFC1918](https://tools.ietf.org/html/rfc1918) 中定义）中的一个地址给 `docker0` 接口。比如典型的 `172.17.42.1`，掩码为 `255.255.0.0`。此后启动的容器内的网口也会自动分配一个同一网段（`172.17.0.0/16`）的地址。\n\n当创建一个 Docker 容器的时候，同时会创建了一对 `veth pair` 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 `eth0`；另一端在本地并被挂载到 `docker0` 网桥，名称以 `veth` 开头（例如 `vethAQI2QT`）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。\n\n![image-20201125105847896](Docker_1.assets/image-20201125105847896.png)\n\n### 10.2 查看网络信息\n\n```markdown\n# docker network ls\n```\n\n### 10.3 创建一个网桥\n\n```markdown\n# docker network create -d bridge 网桥名称\n```\n\n### 10.4 删除一个网桥\n\n```markdown\n# docker network rm 网桥名称\n```\n\n### 10.5 容器之前使用网络通信\n\n```markdown\n# 1.查询当前网络配置\n- docker network ls\n```\n\n```shell\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n```\n\n```markdown\n# 2.创建桥接网络\n- docker network create -d bridge info\n```\n\n```shell\n[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n```\n\n```markdown\n# 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n```\n\n```shell\n[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               \"/docker-entrypoint.…\"   3 seconds ago       Up 2 seconds        0.0.0.0:8891->80/tcp   nginx002\nc315bcc94e9d        nginx               \"/docker-entrypoint.…\"   7 minutes ago       Up 7 minutes        0.0.0.0:8890->80/tcp   nginx001\nb63169d43792        mysql:5.7.19        \"docker-entrypoint.s…\"   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n.....\n```\n\n---\n\n## 11.高级数据卷配置\n\n### 11.1 说明\n\n`数据卷` 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：\n\n- `数据卷` 可以在容器之间共享和重用\n- 对 `数据卷` 的修改会立马生效\n- 对 `数据卷` 的更新，不会影响镜像\n- `数据卷` 默认会一直存在，即使容器被删除\n\n> 注意：`数据卷` 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n\n### 11.2 创建数据卷\n\n```shell\n[root@centos ~]# docker volume create my-vol\nmy-vol\n```\n\n### 11.3 查看数据卷\n\n```shell\n[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        \"CreatedAt\": \"2020-11-25T11:43:56+08:00\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\",\n        \"Name\": \"my-vol\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n```\n\n### 11.4 挂载数据卷\n\n```shell\n[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				\"Mounts\": [\n            {\n                \"Type\": \"volume\",\n                \"Name\": \"my-vol\",\n                \"Source\": \"/var/lib/docker/volumes/my-vol/_data\",\n                \"Destination\": \"/usr/share/nginx/html\",\n                \"Driver\": \"local\",\n                \"Mode\": \"z\",\n                \"RW\": true,\n                \"Propagation\": \"\"\n            }\n        ],\n```\n\n### 11.5 删除数据卷\n\n```shell\ndocker volume rm my-vol\n```\n\n---\n\n## 12.Docker Compose\n\n### 12.1 简介\n\n`Compose` 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 `OpenStack` 中的 `Heat` 十分类似。\n\n其代码目前在 https://github.com/docker/compose 上开源。\n\n`Compose` 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。\n\n通过第一部分中的介绍，我们知道使用一个 `Dockerfile` 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。\n\n`Compose` 恰好满足了这样的需求。它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\n\n`Compose` 中有两个重要的概念：\n\n- 服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。\n\n`Compose` 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n`Compose` 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 `Compose` 来进行编排管理。\n\n### 12.2 安装与卸载\n\n###### 1.linux\n\n- 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。\n\n```bash\n$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n```\n\n###### 2.macos、window\n\n- Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。`Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用`。\n\n###### 3.bash命令补全\n\n```shell\n$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose\n```\n\n###### 4.卸载\n\n- 如果是二进制包方式安装的，删除二进制文件即可。\n\n```shell\n$ sudo rm /usr/local/bin/docker-compose\n```\n\n###### 5.测试安装成功\n\n```shell\n$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n```\n\n### 12.3 docker compose使用\n\n```markdown\n# 1.相关概念\n```\n\n首先介绍几个术语。\n\n- 服务 (`service`)：一个应用容器，实际上可以运行多个相同镜像的实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，`Compose` 面向项目进行管理。\n\n```markdown\n# 2.场景\n```\n\n最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。\n\n- springboot应用\n- mysql服务\n- redis服务\n- elasticsearch服务\n- .......\n\n````markdown\n# 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n````\n\n```yml\nversion: \"3.0\"\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - \"6379:6379\"\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n```\n\n```markdown\n# 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n```\n\n```bash\n[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n```\n\n---\n\n### 12.4 docker-compose 模板文件\n\n模板文件是使用 `Compose` 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 `docker run` 相关参数的含义都是类似的。\n\n默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式。\n\n```yaml\nversion: \"3\"\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - \"80:80\"\n    volumes:\n      - \"/data\"\n```\n\n注意每个服务都必须通过 `image` 指令指定镜像或 `build` 指令（需要 Dockerfile）等来自动构建生成镜像。\n\n如果使用 `build` 指令，在 `Dockerfile` 中设置的选项(例如：`CMD`, `EXPOSE`, `VOLUME`, `ENV` 等) 将会自动被获取，无需在 `docker-compose.yml` 中重复设置。\n\n下面分别介绍各个指令的用法。\n\n#### `build`\n\n指定 `Dockerfile` 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 `Compose` 将会利用它自动构建这个镜像，然后使用这个镜像。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n```\n\n你也可以使用 `context` 指令指定 `Dockerfile` 所在文件夹的路径。\n\n使用 `dockerfile` 指令指定 `Dockerfile` 文件名。\n\n使用 `arg` 指令指定构建镜像时的变量。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n```\n\n#### `command`\n\n覆盖容器启动后默认执行的命令。\n\n```yaml\ncommand: echo \"hello world\"\n```\n\n#### `container_name`\n\n指定容器名称。默认将会使用 `项目名称_服务名称_序号` 这样的格式。\n\n```yaml\ncontainer_name: docker-web-container\n```\n\n> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。\n\n#### `depends_on`\n\n解决容器的依赖、启动先后的问题。以下例子中会先启动 `redis` `db` 再启动 `web`\n\n```yaml\nversion: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n```\n\n> 注意：`web` 服务不会等待 `redis` `db` 「完全启动」之后才启动。\n\n#### `env_file`\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 `env_file` 中变量的路径会基于模板文件路径。\n\n如果有变量名称与 `environment` 指令冲突，则按照惯例，以后者为准。\n\n```bash\nenv_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n```\n\n环境变量文件中每一行必须符合格式，支持 `#` 开头的注释行。\n\n```bash\n# common.env: Set development environment\nPROG_ENV=development\n```\n\n#### `environment`\n\n设置环境变量。你可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。\n\n```yaml\nenvironment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n```\n\n如果变量名称或者值中用到 `true|false，yes|no` 等表达 [布尔](https://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括\n\n```bash\ny|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n```\n\n#### `healthcheck`\n\n通过命令检查容器是否健康运行。\n\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n```\n\n#### `image`\n\n指定为镜像名称或镜像 ID。如果镜像在本地不存在，`Compose` 将会尝试拉取这个镜像。\n\n```yaml\nimage: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n```\n\n#### `networks`\n\n配置容器连接的网络。\n\n```yaml\nversion: \"3\"\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n```\n\n#### `ports`\n\n暴露端口信息。\n\n使用宿主端口：容器端口 `(HOST:CONTAINER)` 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。\n\n```yaml\nports:\n - \"3000\"\n - \"8000:8000\"\n - \"49100:22\"\n - \"127.0.0.1:8001:8001\"\n```\n\n*注意：当使用 `HOST:CONTAINER` 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 `YAML` 会自动解析 `xx:yy` 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。*\n\n#### `sysctls`\n\n配置容器内核参数。\n\n```yaml\nsysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n```\n\n#### `ulimits`\n\n指定容器的 ulimits 限制值。\n\n例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。\n\n```yaml\n  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n```\n\n#### `volumes`\n\n数据卷所挂载路径设置。可以设置为宿主机路径(`HOST:CONTAINER`)或者数据卷名称(`VOLUME:CONTAINER`)，并且可以设置访问模式 （`HOST:CONTAINER:ro`）。\n\n该指令中路径支持相对路径。\n\n```yaml\nvolumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n```\n\n如果路径为数据卷名称，必须在文件中配置数据卷。\n\n```yaml\nversion: \"3\"\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n```\n\n---\n\n### 12.5 docker-compose 常用命令\n\n##### 1. 命令对象与格式\n\n对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。\n\n执行 `docker-compose [COMMAND] --help` 或者 `docker-compose help [COMMAND]` 可以查看具体某个命令的使用格式。\n\n`docker-compose` 命令的基本的使用格式是\n\n```bash\ndocker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]\n```\n\n##### 2. 命令选项\n\n- `-f, --file FILE` 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。\n- `-p, --project-name NAME` 指定项目名称，默认将使用所在目录名称作为项目名。\n- `--x-networking` 使用 Docker 的可拔插网络后端特性\n- `--x-network-driver DRIVER` 指定网络后端的驱动，默认为 `bridge`\n- `--verbose` 输出更多调试信息。\n- `-v, --version` 打印版本并退出。\n\n##### 3.命令使用说明\n\n##### `up`\n\n格式为 `docker-compose up [options] [SERVICE...]`。\n\n- 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。\n\n- 链接的服务都将会被自动启动，除非已经处于运行状态。\n\n- 可以说，大部分时候都可以直接通过该命令来启动一个项目。\n\n- 默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。\n\n- 当通过 `Ctrl-C` 停止命令时，所有容器将会停止。\n\n- 如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。\n\n- 默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 `volumes-from` 挂载的卷），以保证新启动的服务匹配 `docker-compose.yml` 文件的最新内容\n\n---\n\n##### `down`\n\n- 此命令将会停止 `up` 命令所启动的容器，并移除网络\n\n----\n\n##### `exec`\n\n- 进入指定的容器。\n\n----\n\n##### `ps`\n\n格式为 `docker-compose ps [options] [SERVICE...]`。\n\n列出项目中目前的所有容器。\n\n选项：\n\n- `-q` 只打印容器的 ID 信息。\n\n----\n\n##### `restart`\n\n格式为 `docker-compose restart [options] [SERVICE...]`。\n\n重启项目中的服务。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 指定重启前停止容器的超时（默认为 10 秒）。\n\n----\n\n##### `rm`\n\n格式为 `docker-compose rm [options] [SERVICE...]`。\n\n删除所有（停止状态的）服务容器。推荐先执行 `docker-compose stop` 命令来停止容器。\n\n选项：\n\n- `-f, --force` 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\n- `-v` 删除容器所挂载的数据卷。\n\n---\n\n##### `start`\n\n格式为 `docker-compose start [SERVICE...]`。\n\n启动已经存在的服务容器。\n\n----\n\n##### `stop`\n\n格式为 `docker-compose stop [options] [SERVICE...]`。\n\n停止已经处于运行状态的容器，但不删除它。通过 `docker-compose start` 可以再次启动这些容器。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。\n\n----\n\n##### `top`\n\n查看各个服务容器内运行的进程。\n\n---\n\n##### `unpause`\n\n格式为 `docker-compose unpause [SERVICE...]`。\n\n恢复处于暂停状态中的服务。\n\n------\n\n## 13.docker可视化工具\n\n#### 13.1 安装Portainer\n\n官方安装说明：[https://www.portainer.io/installation/](http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=)\n\n```shell\n[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   \"/portainer\"        5 seconds ago       Up 4 seconds        0.0.0.0:8000->8000/tcp, 0.0.0.0:9000->9000/tcp   portainer\n```\n\n#### 13.2 登录和使用Portainer\n\n> 用浏览器访问：`http://localhost:9000`\n\n![image-20201223231707738](Docker_1.assets/image-20201223231707738.png)\n\n----\n\n', 'Docker_1', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 13:23:18', 1, '2023-02-21 13:23:18', 1);
INSERT INTO `lzh_article` VALUES (1627902189871607810, 'Docker_1', '<h1>Docker</h1>\n<ul>\n<li>\n<p>官方文档地址:https://www.docker.com/get-started</p>\n</li>\n<li>\n<p>中文参考手册:https://docker_practice.gitee.io/zh-cn/</p>\n</li>\n</ul>\n<hr />\n<h2>1.什么是 Docker</h2>\n<h3>1.1 官方定义</h3>\n<ul>\n<li>最新官网首页</li>\n</ul>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202133061281676957094712.png\" alt=\"image-20201220213306128\" /></p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202142109941676957094721.png\" alt=\"image-20201220214210994\" /></p>\n<pre><code class=\"language-markdown\"># 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n</code></pre>\n<h3>1.2 Docker的起源</h3>\n<pre><code class=\"language-markdown\">Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n</code></pre>\n<h2>2.为什么是Docker</h2>\n<ul>\n<li>\n<p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p>\n<p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p>\n<p><strong>优势1:  一致的运行环境,更轻松的迁移</strong></p>\n</li>\n<li>\n<p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p>\n<p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p>\n<p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p>\n</li>\n<li>\n<p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p>\n<p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p>\n<p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p>\n</li>\n</ul>\n<hr />\n<h2>3.Docker和虚拟机区别</h2>\n<blockquote>\n<p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202224566751676957094746.png\" alt=\"image-20201220222456675\" /></p>\n<p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p>\n<p>|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |</p>\n<hr />\n<h2>4.Docker的安装</h2>\n<h3>4.1 安装docker(centos7.x)</h3>\n<ul>\n<li>\n<p>卸载原始docker</p>\n<pre><code class=\"language-sh\">$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n</code></pre>\n</li>\n<li>\n<p>安装docker依赖</p>\n<pre><code class=\"language-shell\">$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre>\n</li>\n<li>\n<p>设置docker的yum源</p>\n<pre><code class=\"language-bash\">$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n</code></pre>\n</li>\n<li>\n<p>安装最新版的docker</p>\n<pre><code class=\"language-bash\">$ sudo yum install docker-ce docker-ce-cli containerd.io\n</code></pre>\n</li>\n<li>\n<p>指定版本安装docker</p>\n<pre><code class=\"language-bash\">$ yum list docker-ce --showduplicates | sort -r\n$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>关闭docker</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo systemctl stop docker\n</code></pre>\n<ul>\n<li>\n<p>测试docker安装</p>\n<pre><code class=\"language-bash\">$ sudo docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h3>4.2 bash安装(通用所有平台)</h3>\n<ul>\n<li>\n<p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>\n<pre><code class=\"language-bash\">$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>创建docker用户组</p>\n<pre><code class=\"language-bash\">$ sudo groupadd docker\n</code></pre>\n</li>\n<li>\n<p>将当前用户加入docker组</p>\n<pre><code class=\"language-bash\">$ sudo usermod -aG docker $USER\n</code></pre>\n</li>\n<li>\n<p>测试docker安装是否正确</p>\n<pre><code class=\"language-bash\">$ docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h2>5.Docker 的核心架构</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-20200404111908085-02913231676957094400.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>\n<li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>\n<li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>\n<li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>\n<li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li>\n</ul>\n<h2>6. Docker 配置阿里镜像加速服务</h2>\n<h3>6.1 docker 运行流程</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202004041203567841676957094400.png\" alt=\"image-20200404120356784\" /></p>\n<h3>6.2 docker配置阿里云镜像加速</h3>\n<ul>\n<li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li>\n</ul>\n<pre><code class=\"language-shell\">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-\'EOF\'\n{\n  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre>\n<ul>\n<li><code>验证docker的镜像加速是否生效</code></li>\n</ul>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n</code></pre>\n<hr />\n<h2>7.Docker的入门应用</h2>\n<h3>7.1 docker 的第一个程序</h3>\n<blockquote>\n<p>docker  run hello-world</p>\n</blockquote>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>\n<hr />\n<h2>8.常用命令</h2>\n<h3>6.1 辅助命令</h3>\n<pre><code class=\"language-markdown\"># 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n</code></pre>\n<h3>6.2 Images 镜像命令</h3>\n<pre><code class=\"language-markdown\"># 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n</code></pre>\n<h3>6.3 Contrainer 容器命令</h3>\n<pre><code class=\"language-markdown\"># 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签\n</code></pre>\n<hr />\n<h2>7.docker的镜像原理</h2>\n<h3>7.1 镜像是什么？</h3>\n<blockquote>\n<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>\n</blockquote>\n<h3>7.2 为什么一个镜像会那么大？</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202004041429500681676957094400.png\" alt=\"image-20200404142950068\" /></p>\n<p><code>镜像就是花卷</code></p>\n<ul>\n<li>\n<p>UnionFS（联合文件系统）:</p>\n<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p>\n</li>\n</ul>\n<h3>7.3 Docker镜像原理</h3>\n<blockquote>\n<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>\n</blockquote>\n<ul>\n<li>\n<p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>\n</li>\n<li>\n<p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>\n</li>\n<li>\n<p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p>\n</li>\n</ul>\n<p><img src=\"http://1.117.218.230:9000/test/img_1567585172(1)1676957094400.jpg\" alt=\"\" /></p>\n<h3>7.4 为什么docker镜像要采用这种分层结构呢?</h3>\n<blockquote>\n<p><code>最大的一个好处就是资源共享</code></p>\n</blockquote>\n<ul>\n<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>\n</ul>\n<hr />\n<h2>8.Docker安装常用服务</h2>\n<h3>8.1 安装mysql</h3>\n<pre><code class=\"language-markdown\"># 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &lt; /root/xxx.sql\n</code></pre>\n<h3>8.2 安装Redis服务</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n</code></pre>\n<h3>8.3 安装Nginx</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n</code></pre>\n<hr />\n<h3>8.4 安装Tomcat</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n</code></pre>\n<hr />\n<h3>8.5 安装MongoDB数据库</h3>\n<pre><code class=\"language-markdown\"># 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n</code></pre>\n<h3>8.6 安装ElasticSearch</h3>\n<ul>\n<li><code>注意:</code><strong>调高JVM线程数限制数量</strong></li>\n</ul>\n<h4>0.拉取镜像运行elasticsearch</h4>\n<pre><code class=\"language-markdown\"># 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n</code></pre>\n<ul>\n<li>启动出现如下错误</li>\n<li><img src=\"http://1.117.218.230:9000/test/img_image-202006021843217901676957094401.png\" alt=\"image-20200602184321790\" /></li>\n</ul>\n<h4>1. 预先配置</h4>\n<pre><code class=\"language-markdown\"># 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n</code></pre>\n<h4>2.启动EleasticSearch容器</h4>\n<pre><code class=\"language-markdown\"># 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n</code></pre>\n<h4>3.安装IK分词器</h4>\n<pre><code class=\"language-markdown\"># 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	&lt;properties&gt;\n		&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;\n		&lt;!--用户可以在这里配置自己的扩展字典 --&gt;\n		&lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;\n		&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;\n		&lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;\n	&lt;/properties&gt;\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2\n</code></pre>\n<h4>4. 安装Kibana</h4>\n<pre><code class=\"language-markdown\"># 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n</code></pre>\n<hr />\n<h2>10.Docker中出现如下错误解决方案</h2>\n<pre><code class=\"language-powershell\">[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid\n</code></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006021834292861676957094401.png\" alt=\"image-20200602183429286\" /></p>\n<ul>\n<li>注意:<strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></li>\n</ul>\n<pre><code class=\"language-markdown\"># 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n</code></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006021837186231676957094400.png\" alt=\"image-20200602183718623\" /></p>\n<h2>9.Dockerfile</h2>\n<h3>9.1 什么是Dockerfile</h3>\n<p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202004041119080851676957094400.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>\n</ul>\n<h3>9.2 Dockerfile解析过程</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006031812538041676957094401.png\" alt=\"image-20200603181253804\" /></p>\n<h3>9.3 Dockerfile的保留命令</h3>\n<p>官方说明:https://docs.docker.com/engine/reference/builder/</p>\n<p>| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| <strong>FROM</strong>       | <strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code>          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| <strong>RUN</strong>        | <strong>构建镜像时需要运行的指令</strong>                                 |\n| <strong>EXPOSE</strong>     | <strong>当前容器对外暴露出的端口号</strong>                               |\n| <strong>WORKDIR</strong>    | <strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong> |\n| <strong>ENV</strong>        | <strong>用来在构建镜像过程中设置环境变量</strong>                         |\n| <strong>ADD</strong>        | <strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong> |\n| <strong>COPY</strong>       | <strong>类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong> |\n| <strong>VOLUME</strong>     | <strong>容器数据卷，用于数据保存和持久化工作</strong>                     |\n| <strong>CMD</strong>        | <strong>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong> |\n| <strong>ENTRYPOINT</strong> | <strong>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong> |</p>\n<h4>9.3.1 FROM 命令</h4>\n<ul>\n<li>\n<p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">FROM  &lt;image&gt;\nFROM  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest\nFROM  &lt;image&gt;[@&lt;digest&gt;]  使用摘要\n</code></pre>\n</li>\n</ul>\n<h4>9.3.2 MAINTAINER  命令</h4>\n<ul>\n<li>\n<p>镜像维护者的姓名和邮箱地址[废弃]</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">MAINTAINER &lt;name&gt;\n</code></pre>\n</li>\n</ul>\n<h4>9.3.3 RUN 命令</h4>\n<ul>\n<li>\n<p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\nRUN echo hello\n\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)\nRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.4 EXPOSE 命令</h4>\n<ul>\n<li>\n<p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\nEXPOSE 80/udp\n</code></pre>\n</li>\n</ul>\n<h4>9.3.5 CMD 命令</h4>\n<ul>\n<li>\n<p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>\n</li>\n<li>\n<p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)\nCMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)\nCMD command param1 param2 (shell form)\n</code></pre>\n</li>\n</ul>\n<h4>9.3.6 WORKDIR 命令</h4>\n<ul>\n<li>\n<p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">WORKDIR /path/to/workdir\n\nWORKDIR /a\nWORKDIR b\nWORKDIR c\n`注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n</code></pre>\n</li>\n</ul>\n<h4>9.3.7 ENV 命令</h4>\n<ul>\n<li>\n<p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>\n</li>\n<li>\n<p>语法：</p>\n<pre><code class=\"language-dockerfile\">ENV &lt;key&gt; &lt;value&gt;\nENV &lt;key&gt;=&lt;value&gt; ...\n</code></pre>\n</li>\n</ul>\n<h4>9.3.8 ADD 命令</h4>\n<ul>\n<li>\n<p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">ADD hom* /mydir/       通配符添加多个文件\nADD hom?.txt /mydir/   通配符添加\nADD test.txt relativeDir/  可以指定相对路径\nADD test.txt /absoluteDir/ 也可以指定绝对路径\nADD url \n</code></pre>\n</li>\n</ul>\n<h4>9.3.9 COPY 命令</h4>\n<ul>\n<li>\n<p>用来将context目录中指定文件复制到镜像的指定目录中</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">COPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.10 VOLUME 命令</h4>\n<ul>\n<li>\n<p>用来定义容器运行时可以挂在到宿主机的目录</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">VOLUME [&quot;/data&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<ul>\n<li>\n<p>用来指定容器启动时执行命令和CMD类似</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2\n</code></pre>\n<p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。\nCMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<h3>9.4 Dockerfile构建springboot项目部署</h3>\n<h5>1.准备springboot可运行项目</h5>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006051721512661676957094401.png\" alt=\"image-20200605172151266\" /></p>\n<h5>2.将可运行项目放入linux虚拟机中</h5>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006051723403801676957094401.png\" alt=\"image-20200605172340380\" /></p>\n<h5>3.编写Dockerfile</h5>\n<pre><code class=\"language-dockerfile\">FROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]\nCMD [&quot;ems.jar&quot;]\n</code></pre>\n<h5>4.构建镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker build -t ems .\n</code></pre>\n<h5>5.运行镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker run -p 8989:8989 ems\n</code></pre>\n<h5>6.访问项目</h5>\n<pre><code class=\"language-http\">http://10.15.0.8:8989/ems/login.html\n</code></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006051731416361676957094642.png\" alt=\"image-20200605173141636\" /></p>\n<hr />\n<h2>10.高级网络配置</h2>\n<h3>10.1 说明</h3>\n<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href=\"https://tools.ietf.org/html/rfc1918\">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>\n<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202011251058478961676957094693.png\" alt=\"image-20201125105847896\" /></p>\n<h3>10.2 查看网络信息</h3>\n<pre><code class=\"language-markdown\"># docker network ls\n</code></pre>\n<h3>10.3 创建一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network create -d bridge 网桥名称\n</code></pre>\n<h3>10.4 删除一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network rm 网桥名称\n</code></pre>\n<h3>10.5 容器之前使用网络通信</h3>\n<pre><code class=\"language-markdown\"># 1.查询当前网络配置\n- docker network ls\n</code></pre>\n<pre><code class=\"language-shell\">NETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n</code></pre>\n<pre><code class=\"language-markdown\"># 2.创建桥接网络\n- docker network create -d bridge info\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n</code></pre>\n<pre><code class=\"language-markdown\"># 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002\nc315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001\nb63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n.....\n</code></pre>\n<hr />\n<h2>11.高级数据卷配置</h2>\n<h3>11.1 说明</h3>\n<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>\n<ul>\n<li><code>数据卷</code> 可以在容器之间共享和重用</li>\n<li>对 <code>数据卷</code> 的修改会立马生效</li>\n<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>\n<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>\n</ul>\n<blockquote>\n<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>\n</blockquote>\n<h3>11.2 创建数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume create my-vol\nmy-vol\n</code></pre>\n<h3>11.3 查看数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: {},\n        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n        &quot;Name&quot;: &quot;my-vol&quot;,\n        &quot;Options&quot;: {},\n        &quot;Scope&quot;: &quot;local&quot;\n    }\n]\n</code></pre>\n<h3>11.4 挂载数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				&quot;Mounts&quot;: [\n            {\n                &quot;Type&quot;: &quot;volume&quot;,\n                &quot;Name&quot;: &quot;my-vol&quot;,\n                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,\n                &quot;Driver&quot;: &quot;local&quot;,\n                &quot;Mode&quot;: &quot;z&quot;,\n                &quot;RW&quot;: true,\n                &quot;Propagation&quot;: &quot;&quot;\n            }\n        ],\n</code></pre>\n<h3>11.5 删除数据卷</h3>\n<pre><code class=\"language-shell\">docker volume rm my-vol\n</code></pre>\n<hr />\n<h2>12.Docker Compose</h2>\n<h3>12.1 简介</h3>\n<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>\n<p>其代码目前在 https://github.com/docker/compose 上开源。</p>\n<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>\n<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>\n<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>\n<p><code>Compose</code> 中有两个重要的概念：</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>\n</ul>\n<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>\n<h3>12.2 安装与卸载</h3>\n<h6>1.linux</h6>\n<ul>\n<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n</code></pre>\n<h6>2.macos、window</h6>\n<ul>\n<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>\n</ul>\n<h6>3.bash命令补全</h6>\n<pre><code class=\"language-shell\">$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose\n</code></pre>\n<h6>4.卸载</h6>\n<ul>\n<li>如果是二进制包方式安装的，删除二进制文件即可。</li>\n</ul>\n<pre><code class=\"language-shell\">$ sudo rm /usr/local/bin/docker-compose\n</code></pre>\n<h6>5.测试安装成功</h6>\n<pre><code class=\"language-shell\">$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n</code></pre>\n<h3>12.3 docker compose使用</h3>\n<pre><code class=\"language-markdown\"># 1.相关概念\n</code></pre>\n<p>首先介绍几个术语。</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>\n</ul>\n<pre><code class=\"language-markdown\"># 2.场景\n</code></pre>\n<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>\n<ul>\n<li>springboot应用</li>\n<li>mysql服务</li>\n<li>redis服务</li>\n<li>elasticsearch服务</li>\n<li>.......</li>\n</ul>\n<pre><code class=\"language-markdown\"># 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n</code></pre>\n<pre><code class=\"language-yml\">version: &quot;3.0&quot;\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - &quot;3306:3306&quot;\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - &quot;6379:6379&quot;\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n</code></pre>\n<pre><code class=\"language-markdown\"># 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n</code></pre>\n<pre><code class=\"language-bash\">[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n</code></pre>\n<hr />\n<h3>12.4 docker-compose 模板文件</h3>\n<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>\n<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      - &quot;/data&quot;\n</code></pre>\n<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>\n<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>\n<p>下面分别介绍各个指令的用法。</p>\n<h4><code>build</code></h4>\n<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n</code></pre>\n<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>\n<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>\n<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n</code></pre>\n<h4><code>command</code></h4>\n<p>覆盖容器启动后默认执行的命令。</p>\n<pre><code class=\"language-yaml\">command: echo &quot;hello world&quot;\n</code></pre>\n<h4><code>container_name</code></h4>\n<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>\n<pre><code class=\"language-yaml\">container_name: docker-web-container\n</code></pre>\n<blockquote>\n<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>\n</blockquote>\n<h4><code>depends_on</code></h4>\n<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>\n<pre><code class=\"language-yaml\">version: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n</code></pre>\n<blockquote>\n<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>\n</blockquote>\n<h4><code>env_file</code></h4>\n<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>\n<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>\n<pre><code class=\"language-bash\">env_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n</code></pre>\n<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>\n<pre><code class=\"language-bash\"># common.env: Set development environment\nPROG_ENV=development\n</code></pre>\n<h4><code>environment</code></h4>\n<p>设置环境变量。你可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>\n<pre><code class=\"language-yaml\">environment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n</code></pre>\n<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href=\"https://yaml.org/type/bool.html\">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>\n<pre><code class=\"language-bash\">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n</code></pre>\n<h4><code>healthcheck</code></h4>\n<p>通过命令检查容器是否健康运行。</p>\n<pre><code class=\"language-yaml\">healthcheck:\n  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n</code></pre>\n<h4><code>image</code></h4>\n<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>\n<pre><code class=\"language-yaml\">image: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n</code></pre>\n<h4><code>networks</code></h4>\n<p>配置容器连接的网络。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n</code></pre>\n<h4><code>ports</code></h4>\n<p>暴露端口信息。</p>\n<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>\n<pre><code class=\"language-yaml\">ports:\n - &quot;3000&quot;\n - &quot;8000:8000&quot;\n - &quot;49100:22&quot;\n - &quot;127.0.0.1:8001:8001&quot;\n</code></pre>\n<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>\n<h4><code>sysctls</code></h4>\n<p>配置容器内核参数。</p>\n<pre><code class=\"language-yaml\">sysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n</code></pre>\n<h4><code>ulimits</code></h4>\n<p>指定容器的 ulimits 限制值。</p>\n<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>\n<pre><code class=\"language-yaml\">  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n</code></pre>\n<h4><code>volumes</code></h4>\n<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>\n<p>该指令中路径支持相对路径。</p>\n<pre><code class=\"language-yaml\">volumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n</code></pre>\n<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n</code></pre>\n<hr />\n<h3>12.5 docker-compose 常用命令</h3>\n<h5>1. 命令对象与格式</h5>\n<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>\n<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>\n<p><code>docker-compose</code> 命令的基本的使用格式是</p>\n<pre><code class=\"language-bash\">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]\n</code></pre>\n<h5>2. 命令选项</h5>\n<ul>\n<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>\n<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>\n<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>\n<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>\n<li><code>--verbose</code> 输出更多调试信息。</li>\n<li><code>-v, --version</code> 打印版本并退出。</li>\n</ul>\n<h5>3.命令使用说明</h5>\n<h5><code>up</code></h5>\n<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>\n<ul>\n<li>\n<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>\n</li>\n<li>\n<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>\n</li>\n<li>\n<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\n</li>\n<li>\n<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>\n</li>\n<li>\n<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>\n</li>\n<li>\n<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>\n</li>\n<li>\n<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>\n</li>\n</ul>\n<hr />\n<h5><code>down</code></h5>\n<ul>\n<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>\n</ul>\n<hr />\n<h5><code>exec</code></h5>\n<ul>\n<li>进入指定的容器。</li>\n</ul>\n<hr />\n<h5><code>ps</code></h5>\n<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>\n<p>列出项目中目前的所有容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-q</code> 只打印容器的 ID 信息。</li>\n</ul>\n<hr />\n<h5><code>restart</code></h5>\n<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>\n<p>重启项目中的服务。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>rm</code></h5>\n<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>\n<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>\n<li><code>-v</code> 删除容器所挂载的数据卷。</li>\n</ul>\n<hr />\n<h5><code>start</code></h5>\n<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>\n<p>启动已经存在的服务容器。</p>\n<hr />\n<h5><code>stop</code></h5>\n<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>\n<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>top</code></h5>\n<p>查看各个服务容器内运行的进程。</p>\n<hr />\n<h5><code>unpause</code></h5>\n<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>\n<p>恢复处于暂停状态中的服务。</p>\n<hr />\n<h2>13.docker可视化工具</h2>\n<h4>13.1 安装Portainer</h4>\n<p>官方安装说明：<a href=\"http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=\">https://www.portainer.io/installation/</a></p>\n<pre><code class=\"language-shell\">[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer\n</code></pre>\n<h4>13.2 登录和使用Portainer</h4>\n<blockquote>\n<p>用浏览器访问：<code>http://localhost:9000</code></p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012232317077381676957094751.png\" alt=\"image-20201223231707738\" /></p>\n<hr />\n', '# Docker\n\n- 官方文档地址:https://www.docker.com/get-started\n\n- 中文参考手册:https://docker_practice.gitee.io/zh-cn/\n\n-----\n\n## 1.什么是 Docker\n\n### 1.1 官方定义\n\n- 最新官网首页\n\n![image-20201220213306128](Docker_1.assets/image-20201220213306128.png)\n\n![image-20201220214210994](Docker_1.assets/image-20201220214210994.png)\n\n```markdown\n# 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n```\n\n### 1.2 Docker的起源\n\n```markdown\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n```\n\n## 2.为什么是Docker\n\n- `在开发的时候，在本机测试环境可以跑，生产环境跑不起来`\n\n  这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。\n\n  **优势1:  一致的运行环境,更轻松的迁移**\n\n  \n\n- `服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了`\n\n  这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。\n\n  **优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源**\n\n  \n\n- `公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器`\n\n  在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。\n  \n  **优势3: 通过镜像复制N多个环境一致容器**\n\n----\n\n## 3.Docker和虚拟机区别\n\n> 关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。\n\n![image-20201220222456675](Docker_1.assets/image-20201220222456675.png)\n\n`比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重`。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存->虚拟物理内存->真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存->真正物理内存。\n\n|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |\n\n---\n\n## 4.Docker的安装\n\n### 4.1 安装docker(centos7.x)\n\n- 卸载原始docker\n\n  ```sh\n  $ sudo yum remove docker \\\n                    docker-client \\\n                    docker-client-latest \\\n                    docker-common \\\n                    docker-latest \\\n                    docker-latest-logrotate \\\n                    docker-logrotate \\\n                    docker-engine\n  ```\n\n- 安装docker依赖\n\n  ```shell\n  $ sudo yum install -y yum-utils \\\n    device-mapper-persistent-data \\\n    lvm2\n  ```\n\n- 设置docker的yum源\n\n  ```bash\n  $ sudo yum-config-manager \\\n      --add-repo \\\n      https://download.docker.com/linux/centos/docker-ce.repo\n  ```\n\n- 安装最新版的docker\n\n  ```bash\n  $ sudo yum install docker-ce docker-ce-cli containerd.io\n  ```\n\n- 指定版本安装docker\n\n  ```bash\n  $ yum list docker-ce --showduplicates | sort -r\n  $ sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\n  $ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n-  关闭docker\n\n  ```bash\n  $ sudo systemctl stop docker\n  ```\n\n- 测试docker安装\n\n  ```bash\n  $ sudo docker run hello-world\n  ```\n\n### 4.2 bash安装(通用所有平台)\n\n- 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\n\n  ```bash\n  $ curl -fsSL get.docker.com -o get-docker.sh\n  $ sudo sh get-docker.sh --mirror Aliyun\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n- 创建docker用户组\n\n  ```bash\n  $ sudo groupadd docker\n  ```\n\n- 将当前用户加入docker组\n\n  ```bash\n  $ sudo usermod -aG docker $USER\n  ```\n\n- 测试docker安装是否正确\n\n  ```bash\n  $ docker run hello-world\n  ```\n\n## 5.Docker 的核心架构\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085-0291323.png)\n\n- `镜像:` 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等\n- `容器:` 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写\n- `仓库:`用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置\n- `dockerFile:`docker生成镜像配置文件,用来书写自定义镜像的一些配置\n- `tar:`一个对镜像打包的文件,日后可以还原成镜像\n\n## 6. Docker 配置阿里镜像加速服务\n\n### 6.1 docker 运行流程\n\n![image-20200404120356784](Docker_1.assets/image-20200404120356784.png)\n\n### 6.2 docker配置阿里云镜像加速\n\n- `访问阿里云登录自己账号查看docker镜像加速服务`\n\n```shell\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  \"registry-mirrors\": [\"https://lz2nib3q.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n- `验证docker的镜像加速是否生效`\n\n```shell\n[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n```\n\n-----\n\n## 7.Docker的入门应用\n\n### 7.1 docker 的第一个程序\n\n> docker  run hello-world\n\n```shell\n[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n\n----\n\n## 8.常用命令\n\n### 6.1 辅助命令\n\n~~~markdown\n# 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n~~~\n\n### 6.2 Images 镜像命令\n\n~~~markdown\n# 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n~~~\n\n### 6.3 Contrainer 容器命令\n\n~~~markdown\n# 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m \"描述信息\" -a \"作者信息\"   （容器id或者名称）打包的镜像名称:标签\n~~~\n\n----\n\n## 7.docker的镜像原理\n\n### 7.1 镜像是什么？\n\n> 镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。\n\n### 7.2 为什么一个镜像会那么大？\n\n![image-20200404142950068](Docker_1.assets/image-20200404142950068.png)\n\n`镜像就是花卷`\n\n- UnionFS（联合文件系统）:\n\n  Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。	\n\n### 7.3 Docker镜像原理\n\n> `docker的镜像实际是由一层一层的文件系统组成。`\n\n- bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。\n\n- rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。\n\n- 我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。\n\n\n\n![](Docker_1.assets/1567585172(1).jpg)\n\n### 7.4 为什么docker镜像要采用这种分层结构呢?\n\n> `最大的一个好处就是资源共享`\n\n- 比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。\n\n---\n\n## 8.Docker安装常用服务\n\n### 8.1 安装mysql\n\n```markdown\n# 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' < /root/xxx.sql\n```\n\n### 8.2 安装Redis服务\n\n```markdown\n# 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n```\n\n### 8.3 安装Nginx\n\n```markdown\n# 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n```\n\n----\n\n### 8.4 安装Tomcat\n\n```markdown\n# 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n```\n\n-----\n\n### 8.5 安装MongoDB数据库\n\n```markdown\n# 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:\"root\",pwd:\"root\",roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n```\n\n### 8.6 安装ElasticSearch\n\n- `注意:`**调高JVM线程数限制数量**\n\n#### 0.拉取镜像运行elasticsearch\n\n```markdown\n# 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n```\n\n- 启动出现如下错误\n- ![image-20200602184321790](Docker_1.assets/image-20200602184321790.png)\n\n#### 1. 预先配置\n\n```markdown\n# 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n```\n\n#### 2.启动EleasticSearch容器\n\n```markdown\n# 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=\"-Xms128m -Xmx128m\" -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n```\n\n#### 3.安装IK分词器\n\n```markdown\n# 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	<properties>\n		<comment>IK Analyzer 扩展配置</comment>\n		<!--用户可以在这里配置自己的扩展字典 -->\n		<entry key=\"ext_dict\">ext_dict.dic</entry>\n		<!--用户可以在这里配置自己的扩展停止词字典-->\n		<entry key=\"ext_stopwords\">ext_stopwords.dic</entry>\n	</properties>\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=\"xiaochen\" -m=\"es with IKAnalyzer\" 容器id xiaochen/elasticsearch:6.4.2\n```\n\n#### 4. 安装Kibana\n\n```markdown\n# 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n```\n\n----\n\n## 10.Docker中出现如下错误解决方案\n\n```powershell\n[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&n=25: x509: certificate has expired or is not yet valid\n```\n\n![image-20200602183429286](Docker_1.assets/image-20200602183429286.png)\n\n- 注意:**这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步**\n\n```markdown\n# 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n```\n\n![image-20200602183718623](Docker_1.assets/image-20200602183718623.png)\n\n## 9.Dockerfile\n\n### 9.1 什么是Dockerfile\n\nDockerfile可以认为是**Docker镜像的描述文件，是由一系列命令和参数构成的脚本**。主要作用是**用来构建docker镜像的构建文件**。\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085.png)\n\n- **通过架构图可以看出通过DockerFile可以直接构建镜像**\n\n### 9.2 Dockerfile解析过程\n\n![image-20200603181253804](Docker_1.assets/image-20200603181253804.png)\n\n### 9.3 Dockerfile的保留命令\n\n官方说明:https://docs.docker.com/engine/reference/builder/\n\n| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| **FROM**       | **当前镜像是基于哪个镜像的** `第一个指令必须是FROM`          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| **RUN**        | **构建镜像时需要运行的指令**                                 |\n| **EXPOSE**     | **当前容器对外暴露出的端口号**                               |\n| **WORKDIR**    | **指定在创建容器后，终端默认登录进来的工作目录，一个落脚点** |\n| **ENV**        | **用来在构建镜像过程中设置环境变量**                         |\n| **ADD**        | **将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包** |\n| **COPY**       | **类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置** |\n| **VOLUME**     | **容器数据卷，用于数据保存和持久化工作**                     |\n| **CMD**        | **指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换** |\n| **ENTRYPOINT** | **指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数** |\n\n#### 9.3.1 FROM 命令\n\n- 基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现\n\n- 语法:\n\n  ```dockerfile\n  FROM  <image>\n  FROM  <image>[:<tag>]     使用版本不写为latest\n  FROM  <image>[@<digest>]  使用摘要\n  ```\n\n#### 9.3.2 MAINTAINER  命令\n\n- 镜像维护者的姓名和邮箱地址[废弃]\n\n- 语法:\n\n  ```dockerfile\n  MAINTAINER <name>\n  ```\n\n#### 9.3.3 RUN 命令\n\n- RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步\n\n- 语法:\n\n  ```dockerfile\n  RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\n  RUN echo hello\n  \n  RUN [\"executable\", \"param1\", \"param2\"] (exec form)\n  RUN [\"/bin/bash\", \"-c\", \"echo hello\"]\n  ```\n\n#### 9.3.4 EXPOSE 命令\n\n- 用来指定构建的镜像在运行为容器时对外暴露的端口\n\n- 语法:\n\n  ```dockerfile\n  EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\n  EXPOSE 80/udp\n  ```\n\n#### 9.3.5 CMD 命令\n\n- 用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n- 注意: **Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。**\n\n- 语法:\n\n  ```dockerfile\n  CMD [\"executable\",\"param1\",\"param2\"] (exec form, this is the preferred form)\n  CMD [\"param1\",\"param2\"] (as default parameters to ENTRYPOINT)\n  CMD command param1 param2 (shell form)\n  ```\n\n#### 9.3.6 WORKDIR 命令\n\n- 用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。\n\n- 语法:\n\n  ```dockerfile\n  WORKDIR /path/to/workdir\n  \n  WORKDIR /a\n  WORKDIR b\n  WORKDIR c\n  `注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n  ```\n\n#### 9.3.7 ENV 命令\n\n- 用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。\n\n- 语法：\n\n  ```dockerfile\n  ENV <key> <value>\n  ENV <key>=<value> ...\n  ```\n\n#### 9.3.8 ADD 命令\n\n- 用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。\n\n- 语法:\n\n  ```dockerfile\n  ADD hom* /mydir/       通配符添加多个文件\n  ADD hom?.txt /mydir/   通配符添加\n  ADD test.txt relativeDir/  可以指定相对路径\n  ADD test.txt /absoluteDir/ 也可以指定绝对路径\n  ADD url \n  ```\n\n#### 9.3.9 COPY 命令\n\n- 用来将context目录中指定文件复制到镜像的指定目录中\n\n- 语法:\n\n  ```dockerfile\n  COPY src dest\n  COPY [\"<src>\",... \"<dest>\"]\n  ```\n\n#### 9.3.10 VOLUME 命令\n\n- 用来定义容器运行时可以挂在到宿主机的目录\n\n- 语法:\n\n  ```dockerfile\n  VOLUME [\"/data\"]\n  ```\n\n#### 9.3.11 ENTRYPOINT命令\n\n- 用来指定容器启动时执行命令和CMD类似\n\n- 语法:\n\n  ```dockerfile\n    [\"executable\", \"param1\", \"param2\"]\n  ENTRYPOINT command param1 param2\n  ```\n\n  ENTRYPOINT指令，往往用于设置容器启动后的**第一个命令**，这对一个容器来说往往是固定的。\n  CMD指令，往往用于设置容器启动的第一个命令的**默认参数**，这对一个容器来说可以是变化的。\n\n#### 9.3.11 ENTRYPOINT命令\n\n### 9.4 Dockerfile构建springboot项目部署\n\n##### 1.准备springboot可运行项目\n\n![image-20200605172151266](Docker_1.assets/image-20200605172151266.png)\n\n##### 2.将可运行项目放入linux虚拟机中\n\n![image-20200605172340380](Docker_1.assets/image-20200605172340380.png)\n\n##### 3.编写Dockerfile\n\n```dockerfile\nFROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [\"java\",\"-jar\"]\nCMD [\"ems.jar\"]\n```\n\n##### 4.构建镜像\n\n```shell\n[root@localhost ems]# docker build -t ems .\n```\n\n##### 5.运行镜像\n\n```shell\n[root@localhost ems]# docker run -p 8989:8989 ems\n```\n\n##### 6.访问项目\n\n```http\nhttp://10.15.0.8:8989/ems/login.html\n```\n\n![image-20200605173141636](Docker_1.assets/image-20200605173141636.png)\n\n---\n\n## 10.高级网络配置\n\n### 10.1 说明\n\n当 Docker 启动时，会自动在主机上创建一个 `docker0` 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n同时，Docker 随机分配一个本地未占用的私有网段（在 [RFC1918](https://tools.ietf.org/html/rfc1918) 中定义）中的一个地址给 `docker0` 接口。比如典型的 `172.17.42.1`，掩码为 `255.255.0.0`。此后启动的容器内的网口也会自动分配一个同一网段（`172.17.0.0/16`）的地址。\n\n当创建一个 Docker 容器的时候，同时会创建了一对 `veth pair` 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 `eth0`；另一端在本地并被挂载到 `docker0` 网桥，名称以 `veth` 开头（例如 `vethAQI2QT`）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。\n\n![image-20201125105847896](Docker_1.assets/image-20201125105847896.png)\n\n### 10.2 查看网络信息\n\n```markdown\n# docker network ls\n```\n\n### 10.3 创建一个网桥\n\n```markdown\n# docker network create -d bridge 网桥名称\n```\n\n### 10.4 删除一个网桥\n\n```markdown\n# docker network rm 网桥名称\n```\n\n### 10.5 容器之前使用网络通信\n\n```markdown\n# 1.查询当前网络配置\n- docker network ls\n```\n\n```shell\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n```\n\n```markdown\n# 2.创建桥接网络\n- docker network create -d bridge info\n```\n\n```shell\n[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n```\n\n```markdown\n# 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n```\n\n```shell\n[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               \"/docker-entrypoint.…\"   3 seconds ago       Up 2 seconds        0.0.0.0:8891->80/tcp   nginx002\nc315bcc94e9d        nginx               \"/docker-entrypoint.…\"   7 minutes ago       Up 7 minutes        0.0.0.0:8890->80/tcp   nginx001\nb63169d43792        mysql:5.7.19        \"docker-entrypoint.s…\"   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n.....\n```\n\n---\n\n## 11.高级数据卷配置\n\n### 11.1 说明\n\n`数据卷` 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：\n\n- `数据卷` 可以在容器之间共享和重用\n- 对 `数据卷` 的修改会立马生效\n- 对 `数据卷` 的更新，不会影响镜像\n- `数据卷` 默认会一直存在，即使容器被删除\n\n> 注意：`数据卷` 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n\n### 11.2 创建数据卷\n\n```shell\n[root@centos ~]# docker volume create my-vol\nmy-vol\n```\n\n### 11.3 查看数据卷\n\n```shell\n[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        \"CreatedAt\": \"2020-11-25T11:43:56+08:00\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\",\n        \"Name\": \"my-vol\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n```\n\n### 11.4 挂载数据卷\n\n```shell\n[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				\"Mounts\": [\n            {\n                \"Type\": \"volume\",\n                \"Name\": \"my-vol\",\n                \"Source\": \"/var/lib/docker/volumes/my-vol/_data\",\n                \"Destination\": \"/usr/share/nginx/html\",\n                \"Driver\": \"local\",\n                \"Mode\": \"z\",\n                \"RW\": true,\n                \"Propagation\": \"\"\n            }\n        ],\n```\n\n### 11.5 删除数据卷\n\n```shell\ndocker volume rm my-vol\n```\n\n---\n\n## 12.Docker Compose\n\n### 12.1 简介\n\n`Compose` 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 `OpenStack` 中的 `Heat` 十分类似。\n\n其代码目前在 https://github.com/docker/compose 上开源。\n\n`Compose` 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。\n\n通过第一部分中的介绍，我们知道使用一个 `Dockerfile` 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。\n\n`Compose` 恰好满足了这样的需求。它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\n\n`Compose` 中有两个重要的概念：\n\n- 服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。\n\n`Compose` 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n`Compose` 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 `Compose` 来进行编排管理。\n\n### 12.2 安装与卸载\n\n###### 1.linux\n\n- 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。\n\n```bash\n$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n```\n\n###### 2.macos、window\n\n- Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。`Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用`。\n\n###### 3.bash命令补全\n\n```shell\n$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose\n```\n\n###### 4.卸载\n\n- 如果是二进制包方式安装的，删除二进制文件即可。\n\n```shell\n$ sudo rm /usr/local/bin/docker-compose\n```\n\n###### 5.测试安装成功\n\n```shell\n$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n```\n\n### 12.3 docker compose使用\n\n```markdown\n# 1.相关概念\n```\n\n首先介绍几个术语。\n\n- 服务 (`service`)：一个应用容器，实际上可以运行多个相同镜像的实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，`Compose` 面向项目进行管理。\n\n```markdown\n# 2.场景\n```\n\n最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。\n\n- springboot应用\n- mysql服务\n- redis服务\n- elasticsearch服务\n- .......\n\n````markdown\n# 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n````\n\n```yml\nversion: \"3.0\"\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - \"6379:6379\"\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n```\n\n```markdown\n# 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n```\n\n```bash\n[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n```\n\n---\n\n### 12.4 docker-compose 模板文件\n\n模板文件是使用 `Compose` 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 `docker run` 相关参数的含义都是类似的。\n\n默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式。\n\n```yaml\nversion: \"3\"\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - \"80:80\"\n    volumes:\n      - \"/data\"\n```\n\n注意每个服务都必须通过 `image` 指令指定镜像或 `build` 指令（需要 Dockerfile）等来自动构建生成镜像。\n\n如果使用 `build` 指令，在 `Dockerfile` 中设置的选项(例如：`CMD`, `EXPOSE`, `VOLUME`, `ENV` 等) 将会自动被获取，无需在 `docker-compose.yml` 中重复设置。\n\n下面分别介绍各个指令的用法。\n\n#### `build`\n\n指定 `Dockerfile` 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 `Compose` 将会利用它自动构建这个镜像，然后使用这个镜像。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n```\n\n你也可以使用 `context` 指令指定 `Dockerfile` 所在文件夹的路径。\n\n使用 `dockerfile` 指令指定 `Dockerfile` 文件名。\n\n使用 `arg` 指令指定构建镜像时的变量。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n```\n\n#### `command`\n\n覆盖容器启动后默认执行的命令。\n\n```yaml\ncommand: echo \"hello world\"\n```\n\n#### `container_name`\n\n指定容器名称。默认将会使用 `项目名称_服务名称_序号` 这样的格式。\n\n```yaml\ncontainer_name: docker-web-container\n```\n\n> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。\n\n#### `depends_on`\n\n解决容器的依赖、启动先后的问题。以下例子中会先启动 `redis` `db` 再启动 `web`\n\n```yaml\nversion: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n```\n\n> 注意：`web` 服务不会等待 `redis` `db` 「完全启动」之后才启动。\n\n#### `env_file`\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 `env_file` 中变量的路径会基于模板文件路径。\n\n如果有变量名称与 `environment` 指令冲突，则按照惯例，以后者为准。\n\n```bash\nenv_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n```\n\n环境变量文件中每一行必须符合格式，支持 `#` 开头的注释行。\n\n```bash\n# common.env: Set development environment\nPROG_ENV=development\n```\n\n#### `environment`\n\n设置环境变量。你可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。\n\n```yaml\nenvironment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n```\n\n如果变量名称或者值中用到 `true|false，yes|no` 等表达 [布尔](https://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括\n\n```bash\ny|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n```\n\n#### `healthcheck`\n\n通过命令检查容器是否健康运行。\n\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n```\n\n#### `image`\n\n指定为镜像名称或镜像 ID。如果镜像在本地不存在，`Compose` 将会尝试拉取这个镜像。\n\n```yaml\nimage: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n```\n\n#### `networks`\n\n配置容器连接的网络。\n\n```yaml\nversion: \"3\"\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n```\n\n#### `ports`\n\n暴露端口信息。\n\n使用宿主端口：容器端口 `(HOST:CONTAINER)` 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。\n\n```yaml\nports:\n - \"3000\"\n - \"8000:8000\"\n - \"49100:22\"\n - \"127.0.0.1:8001:8001\"\n```\n\n*注意：当使用 `HOST:CONTAINER` 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 `YAML` 会自动解析 `xx:yy` 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。*\n\n#### `sysctls`\n\n配置容器内核参数。\n\n```yaml\nsysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n```\n\n#### `ulimits`\n\n指定容器的 ulimits 限制值。\n\n例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。\n\n```yaml\n  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n```\n\n#### `volumes`\n\n数据卷所挂载路径设置。可以设置为宿主机路径(`HOST:CONTAINER`)或者数据卷名称(`VOLUME:CONTAINER`)，并且可以设置访问模式 （`HOST:CONTAINER:ro`）。\n\n该指令中路径支持相对路径。\n\n```yaml\nvolumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n```\n\n如果路径为数据卷名称，必须在文件中配置数据卷。\n\n```yaml\nversion: \"3\"\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n```\n\n---\n\n### 12.5 docker-compose 常用命令\n\n##### 1. 命令对象与格式\n\n对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。\n\n执行 `docker-compose [COMMAND] --help` 或者 `docker-compose help [COMMAND]` 可以查看具体某个命令的使用格式。\n\n`docker-compose` 命令的基本的使用格式是\n\n```bash\ndocker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]\n```\n\n##### 2. 命令选项\n\n- `-f, --file FILE` 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。\n- `-p, --project-name NAME` 指定项目名称，默认将使用所在目录名称作为项目名。\n- `--x-networking` 使用 Docker 的可拔插网络后端特性\n- `--x-network-driver DRIVER` 指定网络后端的驱动，默认为 `bridge`\n- `--verbose` 输出更多调试信息。\n- `-v, --version` 打印版本并退出。\n\n##### 3.命令使用说明\n\n##### `up`\n\n格式为 `docker-compose up [options] [SERVICE...]`。\n\n- 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。\n\n- 链接的服务都将会被自动启动，除非已经处于运行状态。\n\n- 可以说，大部分时候都可以直接通过该命令来启动一个项目。\n\n- 默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。\n\n- 当通过 `Ctrl-C` 停止命令时，所有容器将会停止。\n\n- 如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。\n\n- 默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 `volumes-from` 挂载的卷），以保证新启动的服务匹配 `docker-compose.yml` 文件的最新内容\n\n---\n\n##### `down`\n\n- 此命令将会停止 `up` 命令所启动的容器，并移除网络\n\n----\n\n##### `exec`\n\n- 进入指定的容器。\n\n----\n\n##### `ps`\n\n格式为 `docker-compose ps [options] [SERVICE...]`。\n\n列出项目中目前的所有容器。\n\n选项：\n\n- `-q` 只打印容器的 ID 信息。\n\n----\n\n##### `restart`\n\n格式为 `docker-compose restart [options] [SERVICE...]`。\n\n重启项目中的服务。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 指定重启前停止容器的超时（默认为 10 秒）。\n\n----\n\n##### `rm`\n\n格式为 `docker-compose rm [options] [SERVICE...]`。\n\n删除所有（停止状态的）服务容器。推荐先执行 `docker-compose stop` 命令来停止容器。\n\n选项：\n\n- `-f, --force` 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\n- `-v` 删除容器所挂载的数据卷。\n\n---\n\n##### `start`\n\n格式为 `docker-compose start [SERVICE...]`。\n\n启动已经存在的服务容器。\n\n----\n\n##### `stop`\n\n格式为 `docker-compose stop [options] [SERVICE...]`。\n\n停止已经处于运行状态的容器，但不删除它。通过 `docker-compose start` 可以再次启动这些容器。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。\n\n----\n\n##### `top`\n\n查看各个服务容器内运行的进程。\n\n---\n\n##### `unpause`\n\n格式为 `docker-compose unpause [SERVICE...]`。\n\n恢复处于暂停状态中的服务。\n\n------\n\n## 13.docker可视化工具\n\n#### 13.1 安装Portainer\n\n官方安装说明：[https://www.portainer.io/installation/](http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=)\n\n```shell\n[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   \"/portainer\"        5 seconds ago       Up 4 seconds        0.0.0.0:8000->8000/tcp, 0.0.0.0:9000->9000/tcp   portainer\n```\n\n#### 13.2 登录和使用Portainer\n\n> 用浏览器访问：`http://localhost:9000`\n\n![image-20201223231707738](Docker_1.assets/image-20201223231707738.png)\n\n----\n\n', 'Docker_1', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 13:25:02', 1, '2023-02-21 13:25:02', 0);
INSERT INTO `lzh_article` VALUES (1627908514626179074, 'AJAX', '<h1>AJAX（Asynchronous Javascript And Xml）</h1>\n<h2>传统请求及缺点</h2>\n<ul>\n<li>传统的请求都有哪些？\n<ul>\n<li>直接在浏览器地址栏上输入URL。</li>\n<li>点击超链接</li>\n<li>提交form表单</li>\n<li>使用JS代码发送请求\n<ul>\n<li>window.open(url)</li>\n<li>document.location.href = url</li>\n<li>window.location.href = url</li>\n<li>....</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>传统请求存在的问题\n<ul>\n<li>页面全部刷新导致了用户的体验较差。</li>\n<li>传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）</li>\n<li><img src=\"C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX同步请求.png\" alt=\"AJAX同步请求\" /></li>\n</ul>\n</li>\n</ul>\n<h2>AJAX概述</h2>\n<ul>\n<li>AJAX不能称为一种技术，它是多种技术的综合产物。</li>\n<li>AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。</li>\n<li>什么是异步，什么是同步？\n<ul>\n<li>假设有t1和t2线程，t1和t2线程并发，就是异步。</li>\n<li>假设有t1和t2线程，t2在执行的时候，必须等待t1线程执行到某个位置之后t2才能执行，那么t2在等t1，显然他们是排队的，排队的就是同步。</li>\n<li>AJAX是可以发送异步请求的。也就是说，在同一个浏览器页面当中，可以发送多个ajax请求，这些ajax请求之间不需要等待，是并发的。</li>\n</ul>\n</li>\n<li>AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。</li>\n<li>AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。</li>\n<li>AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）</li>\n<li>AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。</li>\n<li><img src=\"C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX异步请求.png\" alt=\"\" /></li>\n<li><img src=\"C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\对AJAX异步请求的理解.png\" alt=\"\" /></li>\n</ul>\n<h2>XMLHttpRequest对象</h2>\n<ul>\n<li>\n<p>XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。</p>\n</li>\n<li>\n<p>XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。</p>\n</li>\n<li>\n<p>创建XMLHttpRequest对象</p>\n<ul>\n<li>\n<pre><code class=\"language-javascript\">var xhr = new XMLHttpRequest();\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>XMLHttpRequest对象的方法</p>\n</li>\n</ul>\n<p>| 方法                                          | 描述                                                         |\n| :-------------------------------------------- | :----------------------------------------------------------- |\n| abort()                                       | 取消当前请求                                                 |\n| getAllResponseHeaders()                       | 返回头部信息                                                 |\n| getResponseHeader()                           | 返回特定的头部信息                                           |\n| open(<em>method</em>, <em>url</em>, <em>async</em>, <em>user</em>, <em>psw</em>) | 规定请求method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 |\n| send()                                        | 将请求发送到服务器，用于 GET 请求                            |\n| send(<em>string</em>)                                | 将请求发送到服务器，用于 POST 请求                           |\n| setRequestHeader()                            | 向要发送的报头添加标签/值对                                  |</p>\n<ul>\n<li>XMLHttpRequest对象的属性</li>\n</ul>\n<p>| 属性               | 描述                                                         |\n| :----------------- | :----------------------------------------------------------- |\n| onreadystatechange | 定义当 readyState 属性发生变化时被调用的函数                 |\n| readyState         | 保存 XMLHttpRequest 的状态。0：请求未初始化     1：服务器连接已建立     2：请求已收到    3：正在处理请求    4：请求已完成且响应已就绪 |\n| responseText       | 以字符串返回响应数据                                         |\n| responseXML        | 以 XML 数据返回响应数据                                      |\n| status             | 返回请求的状态号200: &quot;OK&quot;403: &quot;Forbidden&quot;404: &quot;Not Found&quot;    |\n| statusText         | 返回状态文本（比如 &quot;OK&quot; 或 &quot;Not Found&quot;）                     |</p>\n<h2>AJAX GET请求</h2>\n<ul>\n<li>\n<p>发送AJAX get请求，前端代码：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;发送ajax get请求&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () {\n        document.getElementById(&quot;btn&quot;).onclick = function () {\n            //1. 创建AJAX核心对象\n            var xhr = new XMLHttpRequest();\n            //2. 注册回调函数\n            xhr.onreadystatechange = function(){\n                if (this.readyState == 4) {\n                    if (this.status == 200) {\n                        // 通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容。\n                        // 并且不管服务器响应回来的是什么，都以普通文本的形势获取。（服务器可能响应回来：普通文本、XML、JSON、HTML...）\n                        // innerHTML属性是javascript中的语法，和ajax的XMLHttpRequest对象无关。\n                        // innerHTML可以设置元素内部的HTML代码。（innerHTML可以将后面的内容当做一段HTML代码解释并执行）\n                        //document.getElementById(&quot;myspan&quot;).innerHTML = this.responseText\n                        document.getElementById(&quot;mydiv&quot;).innerHTML = this.responseText\n                        // innerText也不是AJAX中的，是javascript中的元素属性，和XMLHttpRequest无关。\n                        // innerText也是设置元素中的内容，但是即使后面是一段HTML代码，也是将其看做一个普通字符串设置进去。\n                        //document.getElementById(&quot;myspan&quot;).innerText = this.responseText\n                    }else{\n                        alert(this.status)\n                    }\n                }\n            }\n            //3. 开启通道\n            xhr.open(&quot;GET&quot;, &quot;/ajax/ajaxrequest2&quot;, true)\n            //4. 发送请求\n            xhr.send()\n        }\n    }\n&lt;/script&gt;\n&lt;button id=&quot;btn&quot;&gt;发送ajax get请求&lt;/button&gt;\n&lt;span id=&quot;myspan&quot;&gt;&lt;/span&gt;\n&lt;div id=&quot;mydiv&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n<li>\n<p>发送AJAX get请求，后端代码：</p>\n<pre><code class=\"language-java\">package com.bjpowernode.ajax.servlet;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * @program: 代码\n * @ClassName: AjaxRequest2Servlet\n * @version: 1.0\n * @description:\n * @author: bjpowernode\n * @create: 2022-05-13 10:46\n **/\n\n@WebServlet(&quot;/ajaxrequest2&quot;)\npublic class AjaxRequest2Servlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // 设置响应的内容类型以及字符集\n        response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n        // 获取响应流\n        PrintWriter out = response.getWriter();\n        // 响应\n        out.print(&quot;&lt;font color=\'red\'&gt;用户名已存在！！！&lt;/font&gt;&quot;);\n    }\n}\n\n</code></pre>\n</li>\n<li>\n<p>AJAX get请求如何提交数据呢？</p>\n<ul>\n<li>get请求提交数据是在“请求行”上提交，格式是：url?name=value&amp;name=value&amp;name=value....</li>\n<li>其实这个get请求提交数据的格式是HTTP协议中规定的，遵循协议即可。</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX GET请求的缓存问题</h2>\n<ul>\n<li>对于低版本的IE浏览器来说，AJAX的get请求可能会走缓存。存在缓存问题。对于现代的浏览器来说，大部分浏览器都已经不存在AJAX get缓存问题了。</li>\n<li>什么是AJAX GET请求缓存问题呢？\n<ul>\n<li>在HTTP协议中是这样规定get请求的：get请求会被缓存起来。</li>\n<li>发送AJAX GET请求时，在同一个浏览器上，前后发送的AJAX请求路径一样的话，对于低版本的IE来说，第二次的AJAX GET请求会走缓存，不走服务器。</li>\n</ul>\n</li>\n<li>POST请求在HTTP协议中规定的是：POST请求不会被浏览器缓存。</li>\n<li>GET请求缓存的优缺点：\n<ul>\n<li>优点：直接从浏览器缓存中获取资源，不需要从服务器上重新加载资源，速度较快，用户体验好。</li>\n<li>缺点：无法实时获取最新的服务器资源。</li>\n</ul>\n</li>\n<li>浏览器什么时候会走缓存？\n<ul>\n<li>第一：是一个GET请求</li>\n<li>第二：请求路径已经被浏览器缓存过了。第二次发送请求的时候，这个路径没有变化，会走浏览器缓存。</li>\n</ul>\n</li>\n<li>如果是低版本的IE浏览器，怎么解决AJAX GET请求的缓存问题呢？\n<ul>\n<li>可以在请求路径url后面添加一个时间戳，这个时间戳是随时变化的。所以每一次发送的请求路径都是不一样的，这样就不会走浏览器的缓存问题了。</li>\n<li>可以采用时间戳：&quot;url?t=&quot; + new Date().getTime()</li>\n<li>或者可以通过随机数：&quot;url?t=&quot; + Math.random()</li>\n<li>也可以随机数+时间戳....</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX POST请求</h2>\n<ul>\n<li>\n<p>AJAX POST请求和GET请求的代码区别在哪里？就是前端代码有区别。后端代码没有区别。</p>\n<pre><code class=\"language-javascript\">// 4. 发送AJAX POST请求\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) // 设置请求头的内容类型。模拟form表单提交数据。\n// 获取表单中的数据\nvar username = document.getElementById(&quot;username&quot;).value;\nvar password = document.getElementById(&quot;password&quot;).value;\n// send函数中的参数就是发送的数据，这个数据在“请求体”当中发送。\nxhr.send(&quot;username=&quot;+username+&quot;&amp;password=&quot;+password)\n</code></pre>\n</li>\n<li>\n<p>实现一个案例：使用AJAX POST请求实现用户注册的时候，用户名是否可用。（验证用户名是否可以注册）实现步骤如下：</p>\n<ul>\n<li>在前端，用户输入用户名之后，失去焦点事件blur发生，然后发送AJAX POST请求，提交用户名</li>\n<li>在后端，接收到用户名，连接数据库，根据用户名去表中搜索</li>\n<li>如果用户名已存在\n<ul>\n<li>后端响应消息：对不起，用户名已存在（在前端页面以红色字体展示）</li>\n</ul>\n</li>\n<li>如果用户名不存在\n<ul>\n<li>后端响应消息：用户名可以使用（在前端页面以绿色字体展示）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>实现一个案例：用户点击按钮之后，发送AJAX请求，显示学生列表。</p>\n<ul>\n<li>在后端java程序中拼接HTML代码，然后将HTML代码直接响应到浏览器客户端。这种方式不好，不应该在java代码中编写HTML代码，能否在java程序中直接向前端响应数据？可以，可以在后端拼接JSON格式的字符串，或者XML格式的字符串，将这个字符串发送给前端，前端解析即可。</li>\n</ul>\n</li>\n</ul>\n<h2>基于JSON的数据交换</h2>\n<ul>\n<li>\n<p>在WEB前端中，如何将一个json格式的字符串转换成json对象</p>\n<pre><code class=\"language-javascript\">var jsonStr = &quot;{\\&quot;username\\&quot; : \\&quot;zhangsan\\&quot;, \\&quot;password\\&quot; : \\&quot;1233344\\&quot;}&quot;\nvar jsonObj = JSON.parse(jsonStr)\nconsole.log(jsonObj.username)\nconsole.log(jsonObj.password)\n</code></pre>\n</li>\n<li>\n<p>在后端拼接JSON格式的字符串，响应给前端的浏览器</p>\n<pre><code class=\"language-java\">json.append(&quot;[&quot;);\nwhile (rs.next()) {\n    // 获取每个学生的信息\n    String name = rs.getString(&quot;name&quot;);\n    String age = rs.getString(&quot;age&quot;);\n    String addr = rs.getString(&quot;addr&quot;);\n    // 拼接json格式的字符串\n    // {&quot;name&quot;:&quot;   王五    &quot;,&quot;age&quot;:    20      ,&quot;addr&quot;:&quot;      北京大兴区     &quot;},\n    json.append(&quot;{\\&quot;name\\&quot;:\\&quot;&quot;);\n    json.append(name);\n    json.append(&quot;\\&quot;,\\&quot;age\\&quot;:&quot;);\n    json.append(age);\n    json.append(&quot;,\\&quot;addr\\&quot;:\\&quot;&quot;);\n    json.append(addr);\n    json.append(&quot;\\&quot;},&quot;);\n}\njsonStr = json.substring(0, json.length() - 1) + &quot;]&quot;;\n</code></pre>\n</li>\n<li>\n<p>拼接JSON格式的字符串太痛苦，可以使用阿里巴巴的fastjson组件，它可以将java对象转换成json格式的字符串</p>\n<pre><code class=\"language-java\">List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();\nwhile (rs.next()) {\n    // 取出数据\n    String name = rs.getString(&quot;name&quot;);\n    int age = rs.getInt(&quot;age&quot;);\n    String addr = rs.getString(&quot;addr&quot;);\n    // 将以上数据封装成Student对象\n    Student s = new Student(name, age, addr);\n    // 将Student对象放到List集合\n    studentList.add(s);\n}\n// 将List集合转换成json字符串\njsonStr = JSON.toJSONString(studentList);\n</code></pre>\n<p>注意：使用fastjson需要引入fastjson-1.2.2.jar</p>\n</li>\n</ul>\n<h2>基于XML的数据交换</h2>\n<ul>\n<li>\n<p>注意：如果服务器端响应XML的话，响应的内容类型需要写成：</p>\n<pre><code class=\"language-java\">response.setContentType(&quot;text/xml;charset=UTF-8&quot;);\n</code></pre>\n</li>\n<li>\n<p>xml和JSON都是常用的数据交换格式</p>\n<ul>\n<li>XML体积大，解析麻烦。较少用。</li>\n<li>JSON体积小，解析简单，较常用。</li>\n</ul>\n</li>\n<li>\n<p>基于XML的数据交换，前端代码</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;使用XML完成数据交换&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function(){\n        document.getElementById(&quot;btn&quot;).onclick = function(){\n            // 1.创建XMLHTTPRequest对象\n            var xhr = new XMLHttpRequest();\n            // 2.注册回调函数\n            xhr.onreadystatechange = function () {\n                if (this.readyState == 4) {\n                    if (this.status == 200) {\n                        // 服务器端响应了一个XML字符串，这里怎么接收呢？\n                        // 使用XMLHTTPRequest对象的responseXML属性，接收返回之后，可以自动封装成document对象（文档对象）\n                        var xmlDoc = this.responseXML\n                        //console.log(xmlDoc)\n                        // 获取所有的&lt;student&gt;元素，返回了多个对象，应该是数组。\n                        var students = xmlDoc.getElementsByTagName(&quot;student&quot;)\n                        //console.log(students[0].nodeName)\n                        var html = &quot;&quot;;\n                        for (var i = 0; i &lt; students.length; i++) {\n                            var student = students[i]\n                            // 获取&lt;student&gt;元素下的所有子元素\n                            html += &quot;&lt;tr&gt;&quot;\n                            html += &quot;&lt;td&gt;&quot;+(i+1)+&quot;&lt;/td&gt;&quot;\n                            var nameOrAge = student.childNodes\n                            for (var j = 0; j &lt; nameOrAge.length; j++) {\n                                var node = nameOrAge[j]\n                                if (node.nodeName == &quot;name&quot;) {\n                                    //console.log(&quot;name = &quot; + node.textContent)\n                                    html += &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;/td&gt;&quot;\n                                }\n                                if (node.nodeName == &quot;age&quot;) {\n                                    //console.log(&quot;age = &quot; + node.textContent)\n                                    html += &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;/td&gt;&quot;\n                                }\n                            }\n                            html += &quot;&lt;/tr&gt;&quot;\n                        }\n                        document.getElementById(&quot;stutbody&quot;).innerHTML = html\n                    }else{\n                        alert(this.status)\n                    }\n                }\n            }\n            // 3.开启通道\n            xhr.open(&quot;GET&quot;, &quot;/ajax/ajaxrequest6?t=&quot; + new Date().getTime(), true)\n            // 4.发送请求\n            xhr.send()\n        }\n    }\n&lt;/script&gt;\n&lt;button id=&quot;btn&quot;&gt;显示学生列表&lt;/button&gt;\n&lt;table width=&quot;500px&quot; border=&quot;1px&quot;&gt;\n    &lt;thead&gt;\n    &lt;tr&gt;\n        &lt;th&gt;序号&lt;/th&gt;\n        &lt;th&gt;姓名&lt;/th&gt;\n        &lt;th&gt;年龄&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody id=&quot;stutbody&quot;&gt;\n    &lt;!--&lt;tr&gt;\n        &lt;td&gt;1&lt;/td&gt;\n        &lt;td&gt;zhangsan&lt;/td&gt;\n        &lt;td&gt;20&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;2&lt;/td&gt;\n        &lt;td&gt;lisi&lt;/td&gt;\n        &lt;td&gt;22&lt;/td&gt;\n    &lt;/tr&gt;--&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n<li>\n<p>基于XML的数据交换，后端java程序：</p>\n<pre><code class=\"language-java\">package com.bjpowernode.ajax.servlet;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * @program: 代码\n * @ClassName: AjaxRequest6Servlet\n * @version: 1.0\n * @description: 服务器端返回XML字符串\n * @author: bjpowernode\n * @create: 2022-05-15 11:48\n **/\n@WebServlet(&quot;/ajaxrequest6&quot;)\npublic class AjaxRequest6Servlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // 注意：响应的内容类型是XML。\n        response.setContentType(&quot;text/xml;charset=UTF-8&quot;);\n        PrintWriter out = response.getWriter();\n\n        /*\n        &lt;students&gt;\n            &lt;student&gt;\n                &lt;name&gt;zhangsan&lt;/name&gt;\n                &lt;age&gt;20&lt;/age&gt;\n            &lt;/student&gt;\n            &lt;student&gt;\n                &lt;name&gt;lisi&lt;/name&gt;\n                &lt;age&gt;22&lt;/age&gt;\n            &lt;/student&gt;\n        &lt;/students&gt;\n         */\n\n        StringBuilder xml = new StringBuilder();\n        xml.append(&quot;&lt;students&gt;&quot;);\n        xml.append(&quot;&lt;student&gt;&quot;);\n        xml.append(&quot;&lt;name&gt;zhangsan&lt;/name&gt;&quot;);\n        xml.append(&quot;&lt;age&gt;20&lt;/age&gt;&quot;);\n        xml.append(&quot;&lt;/student&gt;&quot;);\n        xml.append(&quot;&lt;student&gt;&quot;);\n        xml.append(&quot;&lt;name&gt;lisi&lt;/name&gt;&quot;);\n        xml.append(&quot;&lt;age&gt;22&lt;/age&gt;&quot;);\n        xml.append(&quot;&lt;/student&gt;&quot;);\n        xml.append(&quot;&lt;/students&gt;&quot;);\n\n        out.print(xml);\n    }\n}\n\n</code></pre>\n</li>\n</ul>\n<h2>AJAX乱码问题</h2>\n<ul>\n<li>\n<p>测试内容：</p>\n<ul>\n<li>发送ajax get请求\n<ul>\n<li>发送数据到服务器，服务器获取的数据是否乱码？</li>\n<li>服务器响应给前端的中文，会不会乱码？</li>\n</ul>\n</li>\n<li>发送ajax post请求\n<ul>\n<li>发送数据到服务器，服务器获取的数据是否乱码？</li>\n<li>服务器响应给前端的中文，会不会乱码？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>包括还要测试tomcat服务器的版本：</p>\n<ul>\n<li>tomcat10和tomcat9都要进行测试。</li>\n</ul>\n</li>\n<li>\n<p>测试结果：</p>\n<ul>\n<li>\n<p>对于tomcat10来说，关于字符集，我们程序员不需要干涉，不会出现乱码。</p>\n</li>\n<li>\n<p>对于tomcat9来说呢？</p>\n<ul>\n<li>\n<p>响应中文的时候，会出现乱码，怎么解决？</p>\n<pre><code class=\"language-java\">response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n</code></pre>\n</li>\n<li>\n<p>发送ajax post请求的时候，发送给服务器的数据，服务器接收之后乱码，怎么解决？</p>\n<pre><code class=\"language-java\">request.setCharacterEncoding(&quot;UTF-8&quot;);\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX的异步与同步</h2>\n<ul>\n<li>\n<p>什么是异步？什么是同步？</p>\n<ul>\n<li>ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）</li>\n<li>如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。）</li>\n</ul>\n</li>\n<li>\n<p>异步和同步在代码上如何实现？</p>\n<pre><code class=\"language-javascript\">// 假设这个是ajax请求1\n// 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。\n// false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。\nxhr1.open(&quot;请求方式&quot;, &quot;URL&quot;, false)\nxhr1.send()\n\n// 假设这个是ajax请求2\n// 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。\nxhr2.open(&quot;请求方式&quot;, &quot;URL&quot;, true) \nxhr2.send()\n</code></pre>\n</li>\n<li>\n<p>什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）</p>\n<ul>\n<li>举一个例子\n<ul>\n<li>用户注册\n<ul>\n<li>用户名需要发送ajax请求进行校验</li>\n<li>邮箱地址也需要发送ajax请求校验</li>\n<li>其他的也可能需要发送ajax请求。。。</li>\n<li>并且最终注册按钮的时候，也是发送ajax请求进行注册。</li>\n<li>那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX代码封装</h2>\n<ul>\n<li>\n<p>AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。</p>\n</li>\n<li>\n<p>接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）</p>\n</li>\n<li>\n<p>手动开发jQuery，源代码</p>\n<pre><code class=\"language-javascript\">function jQuery(selector){\n    if (typeof selector == &quot;string&quot;) {\n        if (selector.charAt(0) == &quot;#&quot;) {\n            domObj = document.getElementById(selector.substring(1))\n            return new jQuery()\n        }\n    }\n    if (typeof selector == &quot;function&quot;) {\n        window.onload = selector\n    }\n    this.html = function(htmlStr){\n        domObj.innerHTML = htmlStr\n    }\n    this.click = function(fun){\n        domObj.onclick = fun\n    }\n    this.focus = function (fun){\n        domObj.onfocus = fun\n    }\n    this.blur = function(fun) {\n        domObj.onblur = fun\n    }\n    this.change = function (fun){\n        domObj.onchange = fun\n    }\n    this.val = function(v){\n        if (v == undefined) {\n            return domObj.value\n        }else{\n            domObj.value = v\n        }\n    }\n\n    // 静态的方法，发送ajax请求\n    /**\n     * 分析：使用ajax函数发送ajax请求的时候，需要程序员给我们传过来什么？\n     *      请求的方式(type)：GET/POST\n     *      请求的URL(url)：url\n     *      请求时提交的数据(data)：data\n     *      请求时发送异步请求还是同步请求(async)：true表示异步，false表示同步。\n     */\n    jQuery.ajax = function(jsonArgs){\n        // 1.\n        var xhr = new XMLHttpRequest();\n        // 2.\n        xhr.onreadystatechange = function(){\n            if (this.readyState == 4) {\n                if (this.status == 200) {\n                    // 我们这个工具类在封装的时候，先不考虑那么多，假设服务器返回的都是json格式的字符串。\n                    var jsonObj = JSON.parse(this.responseText)\n                    // 调用函数\n                    jsonArgs.success(jsonObj)\n                }\n            }\n        }\n\n        if (jsonArgs.type.toUpperCase() == &quot;POST&quot;) {\n            // 3.\n            xhr.open(&quot;POST&quot;, jsonArgs.url, jsonArgs.async)\n            // 4.\n            xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)\n            xhr.send(jsonArgs.data)\n        }\n\n        if (jsonArgs.type.toUpperCase() == &quot;GET&quot;) {\n            xhr.open(&quot;GET&quot;, jsonArgs.url + &quot;?&quot; + jsonArgs.data, jsonArgs.async)\n            xhr.send()\n        }\n\n    }\n}\n$ = jQuery\n\n// 这里有个细节，执行这个目的是为了让静态方法ajax生效。\nnew jQuery()\n\n\n</code></pre>\n</li>\n<li>\n<p>使用以上库，怎么用？</p>\n<pre><code class=\"language-html\">&lt;script type=&quot;text/javascript&quot; src=&quot;/ajax/js/jQuery-1.0.0.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $(function(){\n        $(&quot;#btn1&quot;).click(function(){\n            $.ajax({\n                type : &quot;POST&quot;,\n                url : &quot;/ajax/ajaxrequest11&quot;,\n                data : &quot;username=&quot; + $(&quot;#username&quot;).val(),\n                async : true,\n                success : function(json){\n                    $(&quot;#div1&quot;).html(json.uname)\n                }\n            })\n        })\n    })\n&lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n<h2>AJAX实现省市联动</h2>\n<ul>\n<li>\n<p>什么是省市联动？</p>\n<ul>\n<li>在网页上，选择对应的省份之后，动态的关联出该省份对应的市。选择对应的市之后，动态的关联出该市对应的区。（首先要清楚需求）</li>\n</ul>\n</li>\n<li>\n<p>进行数据库表的设计</p>\n<ul>\n<li>\n<pre><code>t_area （区域表）\nid(PK-自增)	  code		name		pcode\n---------------------------------------------\n1				001		 河北省		null\n2				002		 河南省		null\n3				003		 石家庄	    001\n4				004		 邯郸			 001\n5				005		 郑州			 002\n6				006		 洛阳			 002\n7				007		 丛台区	    004  \n\n将全国所有的省、市、区、县等信息都存储到一张表当中。\n采用的存储方式实际上是code pcode形势。\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>建表t_area，模拟好数据。</p>\n</li>\n<li>\n<p>首先实现第一个功能：</p>\n<ul>\n<li>页面加载完毕之后，先把省份全部展现出来。</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX跨域问题</h2>\n<h2>AJAX实现搜索联想 自动补全</h2>\n<h2>附录：HTTP状态信息</h2>\n<h3>1xx: 信息</h3>\n<p>| 消息:                   | 描述:                                                        |\n| :---------------------- | :----------------------------------------------------------- |\n| 100 Continue            | 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 |\n| 101 Switching Protocols | 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。   |</p>\n<h3>2xx: 成功</h3>\n<p>| 消息:                             | 描述:                                                        |\n| :-------------------------------- | :----------------------------------------------------------- |\n| 200 OK                            | 请求成功（其后是对GET和POST请求的应答文档。）                |\n| 201 Created                       | 请求被创建完成，同时新的资源被创建。                         |\n| 202 Accepted                      | 供处理的请求已被接受，但是处理未完成。                       |\n| 203 Non-authoritative Information | 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 |\n| 204 No Content                    | 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 |\n| 205 Reset Content                 | 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 |\n| 206 Partial Content               | 客户发送了一个带有Range头的GET请求，服务器完成了它。         |</p>\n<h3>3xx: 重定向</h3>\n<p>| 消息:                  | 描述:                                                        |\n| :--------------------- | :----------------------------------------------------------- |\n| 300 Multiple Choices   | 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 |\n| 301 Moved Permanently  | 所请求的页面已经转移至新的url。                              |\n| 302 Found              | 所请求的页面已经临时转移至新的url。                          |\n| 303 See Other          | 所请求的页面可在别的url下被找到。                            |\n| 304 Not Modified       | 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 |\n| 305 Use Proxy          | 客户请求的文档应该通过Location头所指明的代理服务器提取。     |\n| 306 <em>Unused</em>           | 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。   |\n| 307 Temporary Redirect | 被请求的页面已经临时移至新的url。                            |</p>\n<h3>4xx: 客户端错误</h3>\n<p>| 消息:                             | 描述:                                                        |\n| :-------------------------------- | :----------------------------------------------------------- |\n| 400 Bad Request                   | 服务器未能理解请求。                                         |\n| 401 Unauthorized                  | 被请求的页面需要用户名和密码。                               |\n| 402 Payment Required              | 此代码尚无法使用。                                           |\n| 403 Forbidden                     | 对被请求页面的访问被禁止。                                   |\n| 404 Not Found                     | 服务器无法找到被请求的页面。                                 |\n| 405 Method Not Allowed            | 请求中指定的方法不被允许。                                   |\n| 406 Not Acceptable                | 服务器生成的响应无法被客户端所接受。                         |\n| 407 Proxy Authentication Required | 用户必须首先使用代理服务器进行验证，这样请求才会被处理。     |\n| 408 Request Timeout               | 请求超出了服务器的等待时间。                                 |\n| 409 Conflict                      | 由于冲突，请求无法被完成。                                   |\n| 410 Gone                          | 被请求的页面不可用。                                         |\n| 411 Length Required               | &quot;Content-Length&quot; 未被定义。如果无此内容，服务器不会接受请求。 |\n| 412 Precondition Failed           | 请求中的前提条件被服务器评估为失败。                         |\n| 413 Request Entity Too Large      | 由于所请求的实体的太大，服务器不会接受请求。                 |\n| 414 Request-url Too Long          | 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 |\n| 415 Unsupported Media Type        | 由于媒介类型不被支持，服务器不会接受请求。                   |\n| 416                               | 服务器不能满足客户在请求中指定的Range头。                    |\n| 417 Expectation Failed            |                                                              |</p>\n<h3>5xx: 服务器错误</h3>\n<p>| 消息:                          | 描述:                                              |\n| :----------------------------- | :------------------------------------------------- |\n| 500 Internal Server Error      | 请求未完成。服务器遇到不可预知的情况。             |\n| 501 Not Implemented            | 请求未完成。服务器不支持所请求的功能。             |\n| 502 Bad Gateway                | 请求未完成。服务器从上游服务器收到一个无效的响应。 |\n| 503 Service Unavailable        | 请求未完成。服务器临时过载或当机。                 |\n| 504 Gateway Timeout            | 网关超时。                                         |\n| 505 HTTP Version Not Supported | 服务器不支持请求中指明的HTTP协议版本。             |</p>\n', '# AJAX（Asynchronous Javascript And Xml）\r\n\r\n## 传统请求及缺点\r\n\r\n- 传统的请求都有哪些？\r\n  - 直接在浏览器地址栏上输入URL。\r\n  - 点击超链接\r\n  - 提交form表单\r\n  - 使用JS代码发送请求\r\n    - window.open(url)\r\n    - document.location.href = url\r\n    - window.location.href = url\r\n    - ....\r\n- 传统请求存在的问题\r\n  - 页面全部刷新导致了用户的体验较差。\r\n  - 传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）\r\n  - ![AJAX同步请求](C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX同步请求.png)\r\n\r\n## AJAX概述\r\n\r\n- AJAX不能称为一种技术，它是多种技术的综合产物。\r\n- AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。\r\n- 什么是异步，什么是同步？\r\n  - 假设有t1和t2线程，t1和t2线程并发，就是异步。\r\n  - 假设有t1和t2线程，t2在执行的时候，必须等待t1线程执行到某个位置之后t2才能执行，那么t2在等t1，显然他们是排队的，排队的就是同步。\r\n  - AJAX是可以发送异步请求的。也就是说，在同一个浏览器页面当中，可以发送多个ajax请求，这些ajax请求之间不需要等待，是并发的。\r\n- AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。\r\n- AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。\r\n- AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）\r\n- AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。\r\n- ![](C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX异步请求.png)\r\n- ![](C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\对AJAX异步请求的理解.png)\r\n\r\n## XMLHttpRequest对象\r\n\r\n- XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。\r\n\r\n- XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。\r\n\r\n- 创建XMLHttpRequest对象\r\n\r\n  - ```javascript\r\n    var xhr = new XMLHttpRequest();\r\n    ```\r\n\r\n- XMLHttpRequest对象的方法\r\n\r\n| 方法                                          | 描述                                                         |\r\n| :-------------------------------------------- | :----------------------------------------------------------- |\r\n| abort()                                       | 取消当前请求                                                 |\r\n| getAllResponseHeaders()                       | 返回头部信息                                                 |\r\n| getResponseHeader()                           | 返回特定的头部信息                                           |\r\n| open(*method*, *url*, *async*, *user*, *psw*) | 规定请求method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 |\r\n| send()                                        | 将请求发送到服务器，用于 GET 请求                            |\r\n| send(*string*)                                | 将请求发送到服务器，用于 POST 请求                           |\r\n| setRequestHeader()                            | 向要发送的报头添加标签/值对                                  |\r\n\r\n- XMLHttpRequest对象的属性\r\n\r\n| 属性               | 描述                                                         |\r\n| :----------------- | :----------------------------------------------------------- |\r\n| onreadystatechange | 定义当 readyState 属性发生变化时被调用的函数                 |\r\n| readyState         | 保存 XMLHttpRequest 的状态。0：请求未初始化     1：服务器连接已建立     2：请求已收到    3：正在处理请求    4：请求已完成且响应已就绪 |\r\n| responseText       | 以字符串返回响应数据                                         |\r\n| responseXML        | 以 XML 数据返回响应数据                                      |\r\n| status             | 返回请求的状态号200: \"OK\"403: \"Forbidden\"404: \"Not Found\"    |\r\n| statusText         | 返回状态文本（比如 \"OK\" 或 \"Not Found\"）                     |\r\n\r\n## AJAX GET请求\r\n\r\n- 发送AJAX get请求，前端代码：\r\n\r\n  ```html\r\n  <!DOCTYPE html>\r\n  <html lang=\"en\">\r\n  <head>\r\n      <meta charset=\"UTF-8\">\r\n      <title>发送ajax get请求</title>\r\n  </head>\r\n  <body>\r\n  <script type=\"text/javascript\">\r\n      window.onload = function () {\r\n          document.getElementById(\"btn\").onclick = function () {\r\n              //1. 创建AJAX核心对象\r\n              var xhr = new XMLHttpRequest();\r\n              //2. 注册回调函数\r\n              xhr.onreadystatechange = function(){\r\n                  if (this.readyState == 4) {\r\n                      if (this.status == 200) {\r\n                          // 通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容。\r\n                          // 并且不管服务器响应回来的是什么，都以普通文本的形势获取。（服务器可能响应回来：普通文本、XML、JSON、HTML...）\r\n                          // innerHTML属性是javascript中的语法，和ajax的XMLHttpRequest对象无关。\r\n                          // innerHTML可以设置元素内部的HTML代码。（innerHTML可以将后面的内容当做一段HTML代码解释并执行）\r\n                          //document.getElementById(\"myspan\").innerHTML = this.responseText\r\n                          document.getElementById(\"mydiv\").innerHTML = this.responseText\r\n                          // innerText也不是AJAX中的，是javascript中的元素属性，和XMLHttpRequest无关。\r\n                          // innerText也是设置元素中的内容，但是即使后面是一段HTML代码，也是将其看做一个普通字符串设置进去。\r\n                          //document.getElementById(\"myspan\").innerText = this.responseText\r\n                      }else{\r\n                          alert(this.status)\r\n                      }\r\n                  }\r\n              }\r\n              //3. 开启通道\r\n              xhr.open(\"GET\", \"/ajax/ajaxrequest2\", true)\r\n              //4. 发送请求\r\n              xhr.send()\r\n          }\r\n      }\r\n  </script>\r\n  <button id=\"btn\">发送ajax get请求</button>\r\n  <span id=\"myspan\"></span>\r\n  <div id=\"mydiv\"></div>\r\n  </body>\r\n  </html>\r\n  ```\r\n\r\n- 发送AJAX get请求，后端代码：\r\n\r\n  ```java\r\n  package com.bjpowernode.ajax.servlet;\r\n  \r\n  import jakarta.servlet.ServletException;\r\n  import jakarta.servlet.annotation.WebServlet;\r\n  import jakarta.servlet.http.HttpServlet;\r\n  import jakarta.servlet.http.HttpServletRequest;\r\n  import jakarta.servlet.http.HttpServletResponse;\r\n  \r\n  import java.io.IOException;\r\n  import java.io.PrintWriter;\r\n  \r\n  /**\r\n   * @program: 代码\r\n   * @ClassName: AjaxRequest2Servlet\r\n   * @version: 1.0\r\n   * @description:\r\n   * @author: bjpowernode\r\n   * @create: 2022-05-13 10:46\r\n   **/\r\n  \r\n  @WebServlet(\"/ajaxrequest2\")\r\n  public class AjaxRequest2Servlet extends HttpServlet {\r\n      @Override\r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\n              throws ServletException, IOException {\r\n          // 设置响应的内容类型以及字符集\r\n          response.setContentType(\"text/html;charset=UTF-8\");\r\n          // 获取响应流\r\n          PrintWriter out = response.getWriter();\r\n          // 响应\r\n          out.print(\"<font color=\'red\'>用户名已存在！！！</font>\");\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- AJAX get请求如何提交数据呢？\r\n\r\n  - get请求提交数据是在“请求行”上提交，格式是：url?name=value&name=value&name=value....\r\n  - 其实这个get请求提交数据的格式是HTTP协议中规定的，遵循协议即可。\r\n\r\n## AJAX GET请求的缓存问题\r\n\r\n- 对于低版本的IE浏览器来说，AJAX的get请求可能会走缓存。存在缓存问题。对于现代的浏览器来说，大部分浏览器都已经不存在AJAX get缓存问题了。\r\n- 什么是AJAX GET请求缓存问题呢？\r\n  - 在HTTP协议中是这样规定get请求的：get请求会被缓存起来。\r\n  - 发送AJAX GET请求时，在同一个浏览器上，前后发送的AJAX请求路径一样的话，对于低版本的IE来说，第二次的AJAX GET请求会走缓存，不走服务器。\r\n- POST请求在HTTP协议中规定的是：POST请求不会被浏览器缓存。\r\n- GET请求缓存的优缺点：\r\n  - 优点：直接从浏览器缓存中获取资源，不需要从服务器上重新加载资源，速度较快，用户体验好。\r\n  - 缺点：无法实时获取最新的服务器资源。\r\n- 浏览器什么时候会走缓存？\r\n  - 第一：是一个GET请求\r\n  - 第二：请求路径已经被浏览器缓存过了。第二次发送请求的时候，这个路径没有变化，会走浏览器缓存。\r\n- 如果是低版本的IE浏览器，怎么解决AJAX GET请求的缓存问题呢？\r\n  - 可以在请求路径url后面添加一个时间戳，这个时间戳是随时变化的。所以每一次发送的请求路径都是不一样的，这样就不会走浏览器的缓存问题了。\r\n  - 可以采用时间戳：\"url?t=\" + new Date().getTime()\r\n  - 或者可以通过随机数：\"url?t=\" + Math.random()\r\n  - 也可以随机数+时间戳....\r\n\r\n## AJAX POST请求\r\n\r\n- AJAX POST请求和GET请求的代码区别在哪里？就是前端代码有区别。后端代码没有区别。\r\n\r\n  ```javascript\r\n  // 4. 发送AJAX POST请求\r\n  xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\") // 设置请求头的内容类型。模拟form表单提交数据。\r\n  // 获取表单中的数据\r\n  var username = document.getElementById(\"username\").value;\r\n  var password = document.getElementById(\"password\").value;\r\n  // send函数中的参数就是发送的数据，这个数据在“请求体”当中发送。\r\n  xhr.send(\"username=\"+username+\"&password=\"+password)\r\n  ```\r\n\r\n- 实现一个案例：使用AJAX POST请求实现用户注册的时候，用户名是否可用。（验证用户名是否可以注册）实现步骤如下：\r\n\r\n  - 在前端，用户输入用户名之后，失去焦点事件blur发生，然后发送AJAX POST请求，提交用户名\r\n  - 在后端，接收到用户名，连接数据库，根据用户名去表中搜索\r\n  - 如果用户名已存在\r\n    - 后端响应消息：对不起，用户名已存在（在前端页面以红色字体展示）\r\n  - 如果用户名不存在\r\n    - 后端响应消息：用户名可以使用（在前端页面以绿色字体展示）\r\n\r\n- 实现一个案例：用户点击按钮之后，发送AJAX请求，显示学生列表。\r\n\r\n  - 在后端java程序中拼接HTML代码，然后将HTML代码直接响应到浏览器客户端。这种方式不好，不应该在java代码中编写HTML代码，能否在java程序中直接向前端响应数据？可以，可以在后端拼接JSON格式的字符串，或者XML格式的字符串，将这个字符串发送给前端，前端解析即可。\r\n\r\n\r\n## 基于JSON的数据交换\r\n\r\n- 在WEB前端中，如何将一个json格式的字符串转换成json对象\r\n\r\n  ```javascript\r\n  var jsonStr = \"{\\\"username\\\" : \\\"zhangsan\\\", \\\"password\\\" : \\\"1233344\\\"}\"\r\n  var jsonObj = JSON.parse(jsonStr)\r\n  console.log(jsonObj.username)\r\n  console.log(jsonObj.password)\r\n  ```\r\n\r\n- 在后端拼接JSON格式的字符串，响应给前端的浏览器\r\n\r\n  ```java\r\n  json.append(\"[\");\r\n  while (rs.next()) {\r\n      // 获取每个学生的信息\r\n      String name = rs.getString(\"name\");\r\n      String age = rs.getString(\"age\");\r\n      String addr = rs.getString(\"addr\");\r\n      // 拼接json格式的字符串\r\n      // {\"name\":\"   王五    \",\"age\":    20      ,\"addr\":\"      北京大兴区     \"},\r\n      json.append(\"{\\\"name\\\":\\\"\");\r\n      json.append(name);\r\n      json.append(\"\\\",\\\"age\\\":\");\r\n      json.append(age);\r\n      json.append(\",\\\"addr\\\":\\\"\");\r\n      json.append(addr);\r\n      json.append(\"\\\"},\");\r\n  }\r\n  jsonStr = json.substring(0, json.length() - 1) + \"]\";\r\n  ```\r\n\r\n- 拼接JSON格式的字符串太痛苦，可以使用阿里巴巴的fastjson组件，它可以将java对象转换成json格式的字符串\r\n\r\n  ```java\r\n  List<Student> studentList = new ArrayList<>();\r\n  while (rs.next()) {\r\n      // 取出数据\r\n      String name = rs.getString(\"name\");\r\n      int age = rs.getInt(\"age\");\r\n      String addr = rs.getString(\"addr\");\r\n      // 将以上数据封装成Student对象\r\n      Student s = new Student(name, age, addr);\r\n      // 将Student对象放到List集合\r\n      studentList.add(s);\r\n  }\r\n  // 将List集合转换成json字符串\r\n  jsonStr = JSON.toJSONString(studentList);\r\n  ```\r\n\r\n  注意：使用fastjson需要引入fastjson-1.2.2.jar\r\n\r\n## 基于XML的数据交换\r\n\r\n- 注意：如果服务器端响应XML的话，响应的内容类型需要写成：\r\n\r\n  ```java\r\n  response.setContentType(\"text/xml;charset=UTF-8\");\r\n  ```\r\n\r\n- xml和JSON都是常用的数据交换格式\r\n\r\n  - XML体积大，解析麻烦。较少用。\r\n  - JSON体积小，解析简单，较常用。\r\n\r\n- 基于XML的数据交换，前端代码\r\n\r\n  ```html\r\n  <!DOCTYPE html>\r\n  <html lang=\"en\">\r\n  <head>\r\n      <meta charset=\"UTF-8\">\r\n      <title>使用XML完成数据交换</title>\r\n  </head>\r\n  <body>\r\n  <script type=\"text/javascript\">\r\n      window.onload = function(){\r\n          document.getElementById(\"btn\").onclick = function(){\r\n              // 1.创建XMLHTTPRequest对象\r\n              var xhr = new XMLHttpRequest();\r\n              // 2.注册回调函数\r\n              xhr.onreadystatechange = function () {\r\n                  if (this.readyState == 4) {\r\n                      if (this.status == 200) {\r\n                          // 服务器端响应了一个XML字符串，这里怎么接收呢？\r\n                          // 使用XMLHTTPRequest对象的responseXML属性，接收返回之后，可以自动封装成document对象（文档对象）\r\n                          var xmlDoc = this.responseXML\r\n                          //console.log(xmlDoc)\r\n                          // 获取所有的<student>元素，返回了多个对象，应该是数组。\r\n                          var students = xmlDoc.getElementsByTagName(\"student\")\r\n                          //console.log(students[0].nodeName)\r\n                          var html = \"\";\r\n                          for (var i = 0; i < students.length; i++) {\r\n                              var student = students[i]\r\n                              // 获取<student>元素下的所有子元素\r\n                              html += \"<tr>\"\r\n                              html += \"<td>\"+(i+1)+\"</td>\"\r\n                              var nameOrAge = student.childNodes\r\n                              for (var j = 0; j < nameOrAge.length; j++) {\r\n                                  var node = nameOrAge[j]\r\n                                  if (node.nodeName == \"name\") {\r\n                                      //console.log(\"name = \" + node.textContent)\r\n                                      html += \"<td>\"+node.textContent+\"</td>\"\r\n                                  }\r\n                                  if (node.nodeName == \"age\") {\r\n                                      //console.log(\"age = \" + node.textContent)\r\n                                      html += \"<td>\"+node.textContent+\"</td>\"\r\n                                  }\r\n                              }\r\n                              html += \"</tr>\"\r\n                          }\r\n                          document.getElementById(\"stutbody\").innerHTML = html\r\n                      }else{\r\n                          alert(this.status)\r\n                      }\r\n                  }\r\n              }\r\n              // 3.开启通道\r\n              xhr.open(\"GET\", \"/ajax/ajaxrequest6?t=\" + new Date().getTime(), true)\r\n              // 4.发送请求\r\n              xhr.send()\r\n          }\r\n      }\r\n  </script>\r\n  <button id=\"btn\">显示学生列表</button>\r\n  <table width=\"500px\" border=\"1px\">\r\n      <thead>\r\n      <tr>\r\n          <th>序号</th>\r\n          <th>姓名</th>\r\n          <th>年龄</th>\r\n      </tr>\r\n      </thead>\r\n      <tbody id=\"stutbody\">\r\n      <!--<tr>\r\n          <td>1</td>\r\n          <td>zhangsan</td>\r\n          <td>20</td>\r\n      </tr>\r\n      <tr>\r\n          <td>2</td>\r\n          <td>lisi</td>\r\n          <td>22</td>\r\n      </tr>-->\r\n      </tbody>\r\n  </table>\r\n  </body>\r\n  </html>\r\n  ```\r\n\r\n- 基于XML的数据交换，后端java程序：\r\n\r\n  ```java\r\n  package com.bjpowernode.ajax.servlet;\r\n  \r\n  import jakarta.servlet.ServletException;\r\n  import jakarta.servlet.annotation.WebServlet;\r\n  import jakarta.servlet.http.HttpServlet;\r\n  import jakarta.servlet.http.HttpServletRequest;\r\n  import jakarta.servlet.http.HttpServletResponse;\r\n  \r\n  import java.io.IOException;\r\n  import java.io.PrintWriter;\r\n  \r\n  /**\r\n   * @program: 代码\r\n   * @ClassName: AjaxRequest6Servlet\r\n   * @version: 1.0\r\n   * @description: 服务器端返回XML字符串\r\n   * @author: bjpowernode\r\n   * @create: 2022-05-15 11:48\r\n   **/\r\n  @WebServlet(\"/ajaxrequest6\")\r\n  public class AjaxRequest6Servlet extends HttpServlet {\r\n      @Override\r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\n              throws ServletException, IOException {\r\n          // 注意：响应的内容类型是XML。\r\n          response.setContentType(\"text/xml;charset=UTF-8\");\r\n          PrintWriter out = response.getWriter();\r\n  \r\n          /*\r\n          <students>\r\n              <student>\r\n                  <name>zhangsan</name>\r\n                  <age>20</age>\r\n              </student>\r\n              <student>\r\n                  <name>lisi</name>\r\n                  <age>22</age>\r\n              </student>\r\n          </students>\r\n           */\r\n  \r\n          StringBuilder xml = new StringBuilder();\r\n          xml.append(\"<students>\");\r\n          xml.append(\"<student>\");\r\n          xml.append(\"<name>zhangsan</name>\");\r\n          xml.append(\"<age>20</age>\");\r\n          xml.append(\"</student>\");\r\n          xml.append(\"<student>\");\r\n          xml.append(\"<name>lisi</name>\");\r\n          xml.append(\"<age>22</age>\");\r\n          xml.append(\"</student>\");\r\n          xml.append(\"</students>\");\r\n  \r\n          out.print(xml);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  \r\n\r\n## AJAX乱码问题\r\n\r\n- 测试内容：\r\n\r\n  - 发送ajax get请求\r\n    - 发送数据到服务器，服务器获取的数据是否乱码？\r\n    - 服务器响应给前端的中文，会不会乱码？\r\n  - 发送ajax post请求\r\n    - 发送数据到服务器，服务器获取的数据是否乱码？\r\n    - 服务器响应给前端的中文，会不会乱码？\r\n\r\n- 包括还要测试tomcat服务器的版本：\r\n\r\n  - tomcat10和tomcat9都要进行测试。\r\n\r\n- 测试结果：\r\n\r\n  - 对于tomcat10来说，关于字符集，我们程序员不需要干涉，不会出现乱码。\r\n\r\n  - 对于tomcat9来说呢？\r\n\r\n    - 响应中文的时候，会出现乱码，怎么解决？\r\n\r\n      ```java\r\n      response.setContentType(\"text/html;charset=UTF-8\");\r\n      ```\r\n\r\n    - 发送ajax post请求的时候，发送给服务器的数据，服务器接收之后乱码，怎么解决？\r\n\r\n      ```java\r\n      request.setCharacterEncoding(\"UTF-8\");\r\n      ```\r\n\r\n      \r\n\r\n## AJAX的异步与同步\r\n\r\n- 什么是异步？什么是同步？\r\n\r\n  - ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）\r\n  - 如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。）\r\n\r\n- 异步和同步在代码上如何实现？\r\n\r\n  ```javascript\r\n  // 假设这个是ajax请求1\r\n  // 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。\r\n  // false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。\r\n  xhr1.open(\"请求方式\", \"URL\", false)\r\n  xhr1.send()\r\n  \r\n  // 假设这个是ajax请求2\r\n  // 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。\r\n  xhr2.open(\"请求方式\", \"URL\", true) \r\n  xhr2.send()\r\n  ```\r\n\r\n- 什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）\r\n\r\n  - 举一个例子\r\n    - 用户注册\r\n      - 用户名需要发送ajax请求进行校验\r\n      - 邮箱地址也需要发送ajax请求校验\r\n      - 其他的也可能需要发送ajax请求。。。\r\n      - 并且最终注册按钮的时候，也是发送ajax请求进行注册。\r\n      - 那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。\r\n\r\n## AJAX代码封装\r\n\r\n- AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。\r\n\r\n- 接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）\r\n\r\n- 手动开发jQuery，源代码\r\n\r\n  ```javascript\r\n  function jQuery(selector){\r\n      if (typeof selector == \"string\") {\r\n          if (selector.charAt(0) == \"#\") {\r\n              domObj = document.getElementById(selector.substring(1))\r\n              return new jQuery()\r\n          }\r\n      }\r\n      if (typeof selector == \"function\") {\r\n          window.onload = selector\r\n      }\r\n      this.html = function(htmlStr){\r\n          domObj.innerHTML = htmlStr\r\n      }\r\n      this.click = function(fun){\r\n          domObj.onclick = fun\r\n      }\r\n      this.focus = function (fun){\r\n          domObj.onfocus = fun\r\n      }\r\n      this.blur = function(fun) {\r\n          domObj.onblur = fun\r\n      }\r\n      this.change = function (fun){\r\n          domObj.onchange = fun\r\n      }\r\n      this.val = function(v){\r\n          if (v == undefined) {\r\n              return domObj.value\r\n          }else{\r\n              domObj.value = v\r\n          }\r\n      }\r\n  \r\n      // 静态的方法，发送ajax请求\r\n      /**\r\n       * 分析：使用ajax函数发送ajax请求的时候，需要程序员给我们传过来什么？\r\n       *      请求的方式(type)：GET/POST\r\n       *      请求的URL(url)：url\r\n       *      请求时提交的数据(data)：data\r\n       *      请求时发送异步请求还是同步请求(async)：true表示异步，false表示同步。\r\n       */\r\n      jQuery.ajax = function(jsonArgs){\r\n          // 1.\r\n          var xhr = new XMLHttpRequest();\r\n          // 2.\r\n          xhr.onreadystatechange = function(){\r\n              if (this.readyState == 4) {\r\n                  if (this.status == 200) {\r\n                      // 我们这个工具类在封装的时候，先不考虑那么多，假设服务器返回的都是json格式的字符串。\r\n                      var jsonObj = JSON.parse(this.responseText)\r\n                      // 调用函数\r\n                      jsonArgs.success(jsonObj)\r\n                  }\r\n              }\r\n          }\r\n  \r\n          if (jsonArgs.type.toUpperCase() == \"POST\") {\r\n              // 3.\r\n              xhr.open(\"POST\", jsonArgs.url, jsonArgs.async)\r\n              // 4.\r\n              xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\r\n              xhr.send(jsonArgs.data)\r\n          }\r\n  \r\n          if (jsonArgs.type.toUpperCase() == \"GET\") {\r\n              xhr.open(\"GET\", jsonArgs.url + \"?\" + jsonArgs.data, jsonArgs.async)\r\n              xhr.send()\r\n          }\r\n  \r\n      }\r\n  }\r\n  $ = jQuery\r\n  \r\n  // 这里有个细节，执行这个目的是为了让静态方法ajax生效。\r\n  new jQuery()\r\n  \r\n  \r\n  ```\r\n\r\n- 使用以上库，怎么用？\r\n\r\n  ```html\r\n  <script type=\"text/javascript\" src=\"/ajax/js/jQuery-1.0.0.js\"></script>\r\n  <script type=\"text/javascript\">\r\n      $(function(){\r\n          $(\"#btn1\").click(function(){\r\n              $.ajax({\r\n                  type : \"POST\",\r\n                  url : \"/ajax/ajaxrequest11\",\r\n                  data : \"username=\" + $(\"#username\").val(),\r\n                  async : true,\r\n                  success : function(json){\r\n                      $(\"#div1\").html(json.uname)\r\n                  }\r\n              })\r\n          })\r\n      })\r\n  </script>\r\n  ```\r\n\r\n  \r\n\r\n## AJAX实现省市联动\r\n\r\n- 什么是省市联动？\r\n\r\n  - 在网页上，选择对应的省份之后，动态的关联出该省份对应的市。选择对应的市之后，动态的关联出该市对应的区。（首先要清楚需求）\r\n\r\n- 进行数据库表的设计\r\n\r\n  - ```\r\n    t_area （区域表）\r\n    id(PK-自增)	  code		name		pcode\r\n    ---------------------------------------------\r\n    1				001		 河北省		null\r\n    2				002		 河南省		null\r\n    3				003		 石家庄	    001\r\n    4				004		 邯郸			 001\r\n    5				005		 郑州			 002\r\n    6				006		 洛阳			 002\r\n    7				007		 丛台区	    004  \r\n    \r\n    将全国所有的省、市、区、县等信息都存储到一张表当中。\r\n    采用的存储方式实际上是code pcode形势。\r\n    ```\r\n\r\n- 建表t_area，模拟好数据。\r\n\r\n- 首先实现第一个功能：\r\n\r\n  - 页面加载完毕之后，先把省份全部展现出来。\r\n\r\n## AJAX跨域问题\r\n\r\n\r\n\r\n## AJAX实现搜索联想 自动补全\r\n\r\n\r\n\r\n## 附录：HTTP状态信息\r\n\r\n### 1xx: 信息\r\n\r\n| 消息:                   | 描述:                                                        |\r\n| :---------------------- | :----------------------------------------------------------- |\r\n| 100 Continue            | 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 |\r\n| 101 Switching Protocols | 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。   |\r\n\r\n### 2xx: 成功\r\n\r\n| 消息:                             | 描述:                                                        |\r\n| :-------------------------------- | :----------------------------------------------------------- |\r\n| 200 OK                            | 请求成功（其后是对GET和POST请求的应答文档。）                |\r\n| 201 Created                       | 请求被创建完成，同时新的资源被创建。                         |\r\n| 202 Accepted                      | 供处理的请求已被接受，但是处理未完成。                       |\r\n| 203 Non-authoritative Information | 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 |\r\n| 204 No Content                    | 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 |\r\n| 205 Reset Content                 | 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 |\r\n| 206 Partial Content               | 客户发送了一个带有Range头的GET请求，服务器完成了它。         |\r\n\r\n### 3xx: 重定向\r\n\r\n| 消息:                  | 描述:                                                        |\r\n| :--------------------- | :----------------------------------------------------------- |\r\n| 300 Multiple Choices   | 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 |\r\n| 301 Moved Permanently  | 所请求的页面已经转移至新的url。                              |\r\n| 302 Found              | 所请求的页面已经临时转移至新的url。                          |\r\n| 303 See Other          | 所请求的页面可在别的url下被找到。                            |\r\n| 304 Not Modified       | 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 |\r\n| 305 Use Proxy          | 客户请求的文档应该通过Location头所指明的代理服务器提取。     |\r\n| 306 *Unused*           | 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。   |\r\n| 307 Temporary Redirect | 被请求的页面已经临时移至新的url。                            |\r\n\r\n### 4xx: 客户端错误\r\n\r\n| 消息:                             | 描述:                                                        |\r\n| :-------------------------------- | :----------------------------------------------------------- |\r\n| 400 Bad Request                   | 服务器未能理解请求。                                         |\r\n| 401 Unauthorized                  | 被请求的页面需要用户名和密码。                               |\r\n| 402 Payment Required              | 此代码尚无法使用。                                           |\r\n| 403 Forbidden                     | 对被请求页面的访问被禁止。                                   |\r\n| 404 Not Found                     | 服务器无法找到被请求的页面。                                 |\r\n| 405 Method Not Allowed            | 请求中指定的方法不被允许。                                   |\r\n| 406 Not Acceptable                | 服务器生成的响应无法被客户端所接受。                         |\r\n| 407 Proxy Authentication Required | 用户必须首先使用代理服务器进行验证，这样请求才会被处理。     |\r\n| 408 Request Timeout               | 请求超出了服务器的等待时间。                                 |\r\n| 409 Conflict                      | 由于冲突，请求无法被完成。                                   |\r\n| 410 Gone                          | 被请求的页面不可用。                                         |\r\n| 411 Length Required               | \"Content-Length\" 未被定义。如果无此内容，服务器不会接受请求。 |\r\n| 412 Precondition Failed           | 请求中的前提条件被服务器评估为失败。                         |\r\n| 413 Request Entity Too Large      | 由于所请求的实体的太大，服务器不会接受请求。                 |\r\n| 414 Request-url Too Long          | 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 |\r\n| 415 Unsupported Media Type        | 由于媒介类型不被支持，服务器不会接受请求。                   |\r\n| 416                               | 服务器不能满足客户在请求中指定的Range头。                    |\r\n| 417 Expectation Failed            |                                                              |\r\n\r\n### 5xx: 服务器错误\r\n\r\n| 消息:                          | 描述:                                              |\r\n| :----------------------------- | :------------------------------------------------- |\r\n| 500 Internal Server Error      | 请求未完成。服务器遇到不可预知的情况。             |\r\n| 501 Not Implemented            | 请求未完成。服务器不支持所请求的功能。             |\r\n| 502 Bad Gateway                | 请求未完成。服务器从上游服务器收到一个无效的响应。 |\r\n| 503 Service Unavailable        | 请求未完成。服务器临时过载或当机。                 |\r\n| 504 Gateway Timeout            | 网关超时。                                         |\r\n| 505 HTTP Version Not Supported | 服务器不支持请求中指明的HTTP协议版本。             |\r\n', 'AJAX', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 13:50:10', 1, '2023-02-21 13:50:10', 0);
INSERT INTO `lzh_article` VALUES (1627909519640137729, 'Docker_1', '<h1>Docker</h1>\n<ul>\n<li>\n<p>官方文档地址:https://www.docker.com/get-started</p>\n</li>\n<li>\n<p>中文参考手册:https://docker_practice.gitee.io/zh-cn/</p>\n</li>\n</ul>\n<hr />\n<h2>1.什么是 Docker</h2>\n<h3>1.1 官方定义</h3>\n<ul>\n<li>最新官网首页</li>\n</ul>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202133061281676958835046.png\" alt=\"image-20201220213306128\" /></p>\n<p><img src=\"Docker_1.assets/image-20201220214210994.png\" alt=\"image-20201220214210994\" /></p>\n<pre><code class=\"language-markdown\"># 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n</code></pre>\n<h3>1.2 Docker的起源</h3>\n<pre><code class=\"language-markdown\">Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n</code></pre>\n<h2>2.为什么是Docker</h2>\n<ul>\n<li>\n<p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p>\n<p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p>\n<p><strong>优势1:  一致的运行环境,更轻松的迁移</strong></p>\n</li>\n<li>\n<p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p>\n<p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p>\n<p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p>\n</li>\n<li>\n<p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p>\n<p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p>\n<p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p>\n</li>\n</ul>\n<hr />\n<h2>3.Docker和虚拟机区别</h2>\n<blockquote>\n<p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p>\n</blockquote>\n<p><img src=\"Docker_1.assets/image-20201220222456675.png\" alt=\"image-20201220222456675\" /></p>\n<p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p>\n<p>|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |</p>\n<hr />\n<h2>4.Docker的安装</h2>\n<h3>4.1 安装docker(centos7.x)</h3>\n<ul>\n<li>\n<p>卸载原始docker</p>\n<pre><code class=\"language-sh\">$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n</code></pre>\n</li>\n<li>\n<p>安装docker依赖</p>\n<pre><code class=\"language-shell\">$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre>\n</li>\n<li>\n<p>设置docker的yum源</p>\n<pre><code class=\"language-bash\">$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n</code></pre>\n</li>\n<li>\n<p>安装最新版的docker</p>\n<pre><code class=\"language-bash\">$ sudo yum install docker-ce docker-ce-cli containerd.io\n</code></pre>\n</li>\n<li>\n<p>指定版本安装docker</p>\n<pre><code class=\"language-bash\">$ yum list docker-ce --showduplicates | sort -r\n$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>关闭docker</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo systemctl stop docker\n</code></pre>\n<ul>\n<li>\n<p>测试docker安装</p>\n<pre><code class=\"language-bash\">$ sudo docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h3>4.2 bash安装(通用所有平台)</h3>\n<ul>\n<li>\n<p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>\n<pre><code class=\"language-bash\">$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>创建docker用户组</p>\n<pre><code class=\"language-bash\">$ sudo groupadd docker\n</code></pre>\n</li>\n<li>\n<p>将当前用户加入docker组</p>\n<pre><code class=\"language-bash\">$ sudo usermod -aG docker $USER\n</code></pre>\n</li>\n<li>\n<p>测试docker安装是否正确</p>\n<pre><code class=\"language-bash\">$ docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h2>5.Docker 的核心架构</h2>\n<p><img src=\"Docker_1.assets/image-20200404111908085-0291323.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>\n<li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>\n<li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>\n<li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>\n<li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li>\n</ul>\n<h2>6. Docker 配置阿里镜像加速服务</h2>\n<h3>6.1 docker 运行流程</h3>\n<p><img src=\"Docker_1.assets/image-20200404120356784.png\" alt=\"image-20200404120356784\" /></p>\n<h3>6.2 docker配置阿里云镜像加速</h3>\n<ul>\n<li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li>\n</ul>\n<pre><code class=\"language-shell\">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-\'EOF\'\n{\n  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre>\n<ul>\n<li><code>验证docker的镜像加速是否生效</code></li>\n</ul>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n</code></pre>\n<hr />\n<h2>7.Docker的入门应用</h2>\n<h3>7.1 docker 的第一个程序</h3>\n<blockquote>\n<p>docker  run hello-world</p>\n</blockquote>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>\n<hr />\n<h2>8.常用命令</h2>\n<h3>6.1 辅助命令</h3>\n<pre><code class=\"language-markdown\"># 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n</code></pre>\n<h3>6.2 Images 镜像命令</h3>\n<pre><code class=\"language-markdown\"># 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n</code></pre>\n<h3>6.3 Contrainer 容器命令</h3>\n<pre><code class=\"language-markdown\"># 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签\n</code></pre>\n<hr />\n<h2>7.docker的镜像原理</h2>\n<h3>7.1 镜像是什么？</h3>\n<blockquote>\n<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>\n</blockquote>\n<h3>7.2 为什么一个镜像会那么大？</h3>\n<p><img src=\"Docker_1.assets/image-20200404142950068.png\" alt=\"image-20200404142950068\" /></p>\n<p><code>镜像就是花卷</code></p>\n<ul>\n<li>\n<p>UnionFS（联合文件系统）:</p>\n<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p>\n</li>\n</ul>\n<h3>7.3 Docker镜像原理</h3>\n<blockquote>\n<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>\n</blockquote>\n<ul>\n<li>\n<p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>\n</li>\n<li>\n<p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>\n</li>\n<li>\n<p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p>\n</li>\n</ul>\n<p><img src=\"Docker_1.assets/1567585172(1).jpg\" alt=\"\" /></p>\n<h3>7.4 为什么docker镜像要采用这种分层结构呢?</h3>\n<blockquote>\n<p><code>最大的一个好处就是资源共享</code></p>\n</blockquote>\n<ul>\n<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>\n</ul>\n<hr />\n<h2>8.Docker安装常用服务</h2>\n<h3>8.1 安装mysql</h3>\n<pre><code class=\"language-markdown\"># 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &lt; /root/xxx.sql\n</code></pre>\n<h3>8.2 安装Redis服务</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n</code></pre>\n<h3>8.3 安装Nginx</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n</code></pre>\n<hr />\n<h3>8.4 安装Tomcat</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n</code></pre>\n<hr />\n<h3>8.5 安装MongoDB数据库</h3>\n<pre><code class=\"language-markdown\"># 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n</code></pre>\n<h3>8.6 安装ElasticSearch</h3>\n<ul>\n<li><code>注意:</code><strong>调高JVM线程数限制数量</strong></li>\n</ul>\n<h4>0.拉取镜像运行elasticsearch</h4>\n<pre><code class=\"language-markdown\"># 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n</code></pre>\n<ul>\n<li>启动出现如下错误</li>\n<li><img src=\"Docker_1.assets/image-20200602184321790.png\" alt=\"image-20200602184321790\" /></li>\n</ul>\n<h4>1. 预先配置</h4>\n<pre><code class=\"language-markdown\"># 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n</code></pre>\n<h4>2.启动EleasticSearch容器</h4>\n<pre><code class=\"language-markdown\"># 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n</code></pre>\n<h4>3.安装IK分词器</h4>\n<pre><code class=\"language-markdown\"># 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	&lt;properties&gt;\n		&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;\n		&lt;!--用户可以在这里配置自己的扩展字典 --&gt;\n		&lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;\n		&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;\n		&lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;\n	&lt;/properties&gt;\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2\n</code></pre>\n<h4>4. 安装Kibana</h4>\n<pre><code class=\"language-markdown\"># 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n</code></pre>\n<hr />\n<h2>10.Docker中出现如下错误解决方案</h2>\n<pre><code class=\"language-powershell\">[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid\n</code></pre>\n<p><img src=\"Docker_1.assets/image-20200602183429286.png\" alt=\"image-20200602183429286\" /></p>\n<ul>\n<li>注意:<strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></li>\n</ul>\n<pre><code class=\"language-markdown\"># 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n</code></pre>\n<p><img src=\"Docker_1.assets/image-20200602183718623.png\" alt=\"image-20200602183718623\" /></p>\n<h2>9.Dockerfile</h2>\n<h3>9.1 什么是Dockerfile</h3>\n<p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p>\n<p><img src=\"Docker_1.assets/image-20200404111908085.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>\n</ul>\n<h3>9.2 Dockerfile解析过程</h3>\n<p><img src=\"Docker_1.assets/image-20200603181253804.png\" alt=\"image-20200603181253804\" /></p>\n<h3>9.3 Dockerfile的保留命令</h3>\n<p>官方说明:https://docs.docker.com/engine/reference/builder/</p>\n<p>| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| <strong>FROM</strong>       | <strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code>          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| <strong>RUN</strong>        | <strong>构建镜像时需要运行的指令</strong>                                 |\n| <strong>EXPOSE</strong>     | <strong>当前容器对外暴露出的端口号</strong>                               |\n| <strong>WORKDIR</strong>    | <strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong> |\n| <strong>ENV</strong>        | <strong>用来在构建镜像过程中设置环境变量</strong>                         |\n| <strong>ADD</strong>        | <strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong> |\n| <strong>COPY</strong>       | <strong>类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong> |\n| <strong>VOLUME</strong>     | <strong>容器数据卷，用于数据保存和持久化工作</strong>                     |\n| <strong>CMD</strong>        | <strong>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong> |\n| <strong>ENTRYPOINT</strong> | <strong>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong> |</p>\n<h4>9.3.1 FROM 命令</h4>\n<ul>\n<li>\n<p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">FROM  &lt;image&gt;\nFROM  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest\nFROM  &lt;image&gt;[@&lt;digest&gt;]  使用摘要\n</code></pre>\n</li>\n</ul>\n<h4>9.3.2 MAINTAINER  命令</h4>\n<ul>\n<li>\n<p>镜像维护者的姓名和邮箱地址[废弃]</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">MAINTAINER &lt;name&gt;\n</code></pre>\n</li>\n</ul>\n<h4>9.3.3 RUN 命令</h4>\n<ul>\n<li>\n<p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\nRUN echo hello\n\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)\nRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.4 EXPOSE 命令</h4>\n<ul>\n<li>\n<p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\nEXPOSE 80/udp\n</code></pre>\n</li>\n</ul>\n<h4>9.3.5 CMD 命令</h4>\n<ul>\n<li>\n<p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>\n</li>\n<li>\n<p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)\nCMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)\nCMD command param1 param2 (shell form)\n</code></pre>\n</li>\n</ul>\n<h4>9.3.6 WORKDIR 命令</h4>\n<ul>\n<li>\n<p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">WORKDIR /path/to/workdir\n\nWORKDIR /a\nWORKDIR b\nWORKDIR c\n`注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n</code></pre>\n</li>\n</ul>\n<h4>9.3.7 ENV 命令</h4>\n<ul>\n<li>\n<p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>\n</li>\n<li>\n<p>语法：</p>\n<pre><code class=\"language-dockerfile\">ENV &lt;key&gt; &lt;value&gt;\nENV &lt;key&gt;=&lt;value&gt; ...\n</code></pre>\n</li>\n</ul>\n<h4>9.3.8 ADD 命令</h4>\n<ul>\n<li>\n<p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">ADD hom* /mydir/       通配符添加多个文件\nADD hom?.txt /mydir/   通配符添加\nADD test.txt relativeDir/  可以指定相对路径\nADD test.txt /absoluteDir/ 也可以指定绝对路径\nADD url \n</code></pre>\n</li>\n</ul>\n<h4>9.3.9 COPY 命令</h4>\n<ul>\n<li>\n<p>用来将context目录中指定文件复制到镜像的指定目录中</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">COPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.10 VOLUME 命令</h4>\n<ul>\n<li>\n<p>用来定义容器运行时可以挂在到宿主机的目录</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">VOLUME [&quot;/data&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<ul>\n<li>\n<p>用来指定容器启动时执行命令和CMD类似</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2\n</code></pre>\n<p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。\nCMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<h3>9.4 Dockerfile构建springboot项目部署</h3>\n<h5>1.准备springboot可运行项目</h5>\n<p><img src=\"Docker_1.assets/image-20200605172151266.png\" alt=\"image-20200605172151266\" /></p>\n<h5>2.将可运行项目放入linux虚拟机中</h5>\n<p><img src=\"Docker_1.assets/image-20200605172340380.png\" alt=\"image-20200605172340380\" /></p>\n<h5>3.编写Dockerfile</h5>\n<pre><code class=\"language-dockerfile\">FROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]\nCMD [&quot;ems.jar&quot;]\n</code></pre>\n<h5>4.构建镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker build -t ems .\n</code></pre>\n<h5>5.运行镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker run -p 8989:8989 ems\n</code></pre>\n<h5>6.访问项目</h5>\n<pre><code class=\"language-http\">http://10.15.0.8:8989/ems/login.html\n</code></pre>\n<p><img src=\"Docker_1.assets/image-20200605173141636.png\" alt=\"image-20200605173141636\" /></p>\n<hr />\n<h2>10.高级网络配置</h2>\n<h3>10.1 说明</h3>\n<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href=\"https://tools.ietf.org/html/rfc1918\">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>\n<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>\n<p><img src=\"Docker_1.assets/image-20201125105847896.png\" alt=\"image-20201125105847896\" /></p>\n<h3>10.2 查看网络信息</h3>\n<pre><code class=\"language-markdown\"># docker network ls\n</code></pre>\n<h3>10.3 创建一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network create -d bridge 网桥名称\n</code></pre>\n<h3>10.4 删除一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network rm 网桥名称\n</code></pre>\n<h3>10.5 容器之前使用网络通信</h3>\n<pre><code class=\"language-markdown\"># 1.查询当前网络配置\n- docker network ls\n</code></pre>\n<pre><code class=\"language-shell\">NETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n</code></pre>\n<pre><code class=\"language-markdown\"># 2.创建桥接网络\n- docker network create -d bridge info\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n</code></pre>\n<pre><code class=\"language-markdown\"># 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002\nc315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001\nb63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n.....\n</code></pre>\n<hr />\n<h2>11.高级数据卷配置</h2>\n<h3>11.1 说明</h3>\n<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>\n<ul>\n<li><code>数据卷</code> 可以在容器之间共享和重用</li>\n<li>对 <code>数据卷</code> 的修改会立马生效</li>\n<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>\n<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>\n</ul>\n<blockquote>\n<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>\n</blockquote>\n<h3>11.2 创建数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume create my-vol\nmy-vol\n</code></pre>\n<h3>11.3 查看数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: {},\n        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n        &quot;Name&quot;: &quot;my-vol&quot;,\n        &quot;Options&quot;: {},\n        &quot;Scope&quot;: &quot;local&quot;\n    }\n]\n</code></pre>\n<h3>11.4 挂载数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				&quot;Mounts&quot;: [\n            {\n                &quot;Type&quot;: &quot;volume&quot;,\n                &quot;Name&quot;: &quot;my-vol&quot;,\n                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,\n                &quot;Driver&quot;: &quot;local&quot;,\n                &quot;Mode&quot;: &quot;z&quot;,\n                &quot;RW&quot;: true,\n                &quot;Propagation&quot;: &quot;&quot;\n            }\n        ],\n</code></pre>\n<h3>11.5 删除数据卷</h3>\n<pre><code class=\"language-shell\">docker volume rm my-vol\n</code></pre>\n<hr />\n<h2>12.Docker Compose</h2>\n<h3>12.1 简介</h3>\n<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>\n<p>其代码目前在 https://github.com/docker/compose 上开源。</p>\n<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>\n<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>\n<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>\n<p><code>Compose</code> 中有两个重要的概念：</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>\n</ul>\n<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>\n<h3>12.2 安装与卸载</h3>\n<h6>1.linux</h6>\n<ul>\n<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n</code></pre>\n<h6>2.macos、window</h6>\n<ul>\n<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>\n</ul>\n<h6>3.bash命令补全</h6>\n<pre><code class=\"language-shell\">$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose\n</code></pre>\n<h6>4.卸载</h6>\n<ul>\n<li>如果是二进制包方式安装的，删除二进制文件即可。</li>\n</ul>\n<pre><code class=\"language-shell\">$ sudo rm /usr/local/bin/docker-compose\n</code></pre>\n<h6>5.测试安装成功</h6>\n<pre><code class=\"language-shell\">$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n</code></pre>\n<h3>12.3 docker compose使用</h3>\n<pre><code class=\"language-markdown\"># 1.相关概念\n</code></pre>\n<p>首先介绍几个术语。</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>\n</ul>\n<pre><code class=\"language-markdown\"># 2.场景\n</code></pre>\n<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>\n<ul>\n<li>springboot应用</li>\n<li>mysql服务</li>\n<li>redis服务</li>\n<li>elasticsearch服务</li>\n<li>.......</li>\n</ul>\n<pre><code class=\"language-markdown\"># 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n</code></pre>\n<pre><code class=\"language-yml\">version: &quot;3.0&quot;\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - &quot;3306:3306&quot;\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - &quot;6379:6379&quot;\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n</code></pre>\n<pre><code class=\"language-markdown\"># 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n</code></pre>\n<pre><code class=\"language-bash\">[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n</code></pre>\n<hr />\n<h3>12.4 docker-compose 模板文件</h3>\n<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>\n<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      - &quot;/data&quot;\n</code></pre>\n<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>\n<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>\n<p>下面分别介绍各个指令的用法。</p>\n<h4><code>build</code></h4>\n<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n</code></pre>\n<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>\n<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>\n<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n</code></pre>\n<h4><code>command</code></h4>\n<p>覆盖容器启动后默认执行的命令。</p>\n<pre><code class=\"language-yaml\">command: echo &quot;hello world&quot;\n</code></pre>\n<h4><code>container_name</code></h4>\n<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>\n<pre><code class=\"language-yaml\">container_name: docker-web-container\n</code></pre>\n<blockquote>\n<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>\n</blockquote>\n<h4><code>depends_on</code></h4>\n<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>\n<pre><code class=\"language-yaml\">version: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n</code></pre>\n<blockquote>\n<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>\n</blockquote>\n<h4><code>env_file</code></h4>\n<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>\n<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>\n<pre><code class=\"language-bash\">env_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n</code></pre>\n<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>\n<pre><code class=\"language-bash\"># common.env: Set development environment\nPROG_ENV=development\n</code></pre>\n<h4><code>environment</code></h4>\n<p>设置环境变量。你可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>\n<pre><code class=\"language-yaml\">environment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n</code></pre>\n<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href=\"https://yaml.org/type/bool.html\">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>\n<pre><code class=\"language-bash\">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n</code></pre>\n<h4><code>healthcheck</code></h4>\n<p>通过命令检查容器是否健康运行。</p>\n<pre><code class=\"language-yaml\">healthcheck:\n  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n</code></pre>\n<h4><code>image</code></h4>\n<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>\n<pre><code class=\"language-yaml\">image: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n</code></pre>\n<h4><code>networks</code></h4>\n<p>配置容器连接的网络。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n</code></pre>\n<h4><code>ports</code></h4>\n<p>暴露端口信息。</p>\n<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>\n<pre><code class=\"language-yaml\">ports:\n - &quot;3000&quot;\n - &quot;8000:8000&quot;\n - &quot;49100:22&quot;\n - &quot;127.0.0.1:8001:8001&quot;\n</code></pre>\n<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>\n<h4><code>sysctls</code></h4>\n<p>配置容器内核参数。</p>\n<pre><code class=\"language-yaml\">sysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n</code></pre>\n<h4><code>ulimits</code></h4>\n<p>指定容器的 ulimits 限制值。</p>\n<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>\n<pre><code class=\"language-yaml\">  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n</code></pre>\n<h4><code>volumes</code></h4>\n<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>\n<p>该指令中路径支持相对路径。</p>\n<pre><code class=\"language-yaml\">volumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n</code></pre>\n<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n</code></pre>\n<hr />\n<h3>12.5 docker-compose 常用命令</h3>\n<h5>1. 命令对象与格式</h5>\n<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>\n<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>\n<p><code>docker-compose</code> 命令的基本的使用格式是</p>\n<pre><code class=\"language-bash\">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]\n</code></pre>\n<h5>2. 命令选项</h5>\n<ul>\n<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>\n<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>\n<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>\n<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>\n<li><code>--verbose</code> 输出更多调试信息。</li>\n<li><code>-v, --version</code> 打印版本并退出。</li>\n</ul>\n<h5>3.命令使用说明</h5>\n<h5><code>up</code></h5>\n<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>\n<ul>\n<li>\n<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>\n</li>\n<li>\n<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>\n</li>\n<li>\n<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\n</li>\n<li>\n<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>\n</li>\n<li>\n<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>\n</li>\n<li>\n<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>\n</li>\n<li>\n<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>\n</li>\n</ul>\n<hr />\n<h5><code>down</code></h5>\n<ul>\n<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>\n</ul>\n<hr />\n<h5><code>exec</code></h5>\n<ul>\n<li>进入指定的容器。</li>\n</ul>\n<hr />\n<h5><code>ps</code></h5>\n<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>\n<p>列出项目中目前的所有容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-q</code> 只打印容器的 ID 信息。</li>\n</ul>\n<hr />\n<h5><code>restart</code></h5>\n<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>\n<p>重启项目中的服务。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>rm</code></h5>\n<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>\n<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>\n<li><code>-v</code> 删除容器所挂载的数据卷。</li>\n</ul>\n<hr />\n<h5><code>start</code></h5>\n<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>\n<p>启动已经存在的服务容器。</p>\n<hr />\n<h5><code>stop</code></h5>\n<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>\n<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>top</code></h5>\n<p>查看各个服务容器内运行的进程。</p>\n<hr />\n<h5><code>unpause</code></h5>\n<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>\n<p>恢复处于暂停状态中的服务。</p>\n<hr />\n<h2>13.docker可视化工具</h2>\n<h4>13.1 安装Portainer</h4>\n<p>官方安装说明：<a href=\"http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=\">https://www.portainer.io/installation/</a></p>\n<pre><code class=\"language-shell\">[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer\n</code></pre>\n<h4>13.2 登录和使用Portainer</h4>\n<blockquote>\n<p>用浏览器访问：<code>http://localhost:9000</code></p>\n</blockquote>\n<p><img src=\"Docker_1.assets/image-20201223231707738.png\" alt=\"image-20201223231707738\" /></p>\n<hr />\n', '# Docker\n\n- 官方文档地址:https://www.docker.com/get-started\n\n- 中文参考手册:https://docker_practice.gitee.io/zh-cn/\n\n-----\n\n## 1.什么是 Docker\n\n### 1.1 官方定义\n\n- 最新官网首页\n\n![image-20201220213306128](Docker_1.assets/image-20201220213306128.png)\n\n![image-20201220214210994](Docker_1.assets/image-20201220214210994.png)\n\n```markdown\n# 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n```\n\n### 1.2 Docker的起源\n\n```markdown\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n```\n\n## 2.为什么是Docker\n\n- `在开发的时候，在本机测试环境可以跑，生产环境跑不起来`\n\n  这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。\n\n  **优势1:  一致的运行环境,更轻松的迁移**\n\n  \n\n- `服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了`\n\n  这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。\n\n  **优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源**\n\n  \n\n- `公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器`\n\n  在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。\n  \n  **优势3: 通过镜像复制N多个环境一致容器**\n\n----\n\n## 3.Docker和虚拟机区别\n\n> 关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。\n\n![image-20201220222456675](Docker_1.assets/image-20201220222456675.png)\n\n`比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重`。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存->虚拟物理内存->真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存->真正物理内存。\n\n|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |\n\n---\n\n## 4.Docker的安装\n\n### 4.1 安装docker(centos7.x)\n\n- 卸载原始docker\n\n  ```sh\n  $ sudo yum remove docker \\\n                    docker-client \\\n                    docker-client-latest \\\n                    docker-common \\\n                    docker-latest \\\n                    docker-latest-logrotate \\\n                    docker-logrotate \\\n                    docker-engine\n  ```\n\n- 安装docker依赖\n\n  ```shell\n  $ sudo yum install -y yum-utils \\\n    device-mapper-persistent-data \\\n    lvm2\n  ```\n\n- 设置docker的yum源\n\n  ```bash\n  $ sudo yum-config-manager \\\n      --add-repo \\\n      https://download.docker.com/linux/centos/docker-ce.repo\n  ```\n\n- 安装最新版的docker\n\n  ```bash\n  $ sudo yum install docker-ce docker-ce-cli containerd.io\n  ```\n\n- 指定版本安装docker\n\n  ```bash\n  $ yum list docker-ce --showduplicates | sort -r\n  $ sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\n  $ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n-  关闭docker\n\n  ```bash\n  $ sudo systemctl stop docker\n  ```\n\n- 测试docker安装\n\n  ```bash\n  $ sudo docker run hello-world\n  ```\n\n### 4.2 bash安装(通用所有平台)\n\n- 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\n\n  ```bash\n  $ curl -fsSL get.docker.com -o get-docker.sh\n  $ sudo sh get-docker.sh --mirror Aliyun\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n- 创建docker用户组\n\n  ```bash\n  $ sudo groupadd docker\n  ```\n\n- 将当前用户加入docker组\n\n  ```bash\n  $ sudo usermod -aG docker $USER\n  ```\n\n- 测试docker安装是否正确\n\n  ```bash\n  $ docker run hello-world\n  ```\n\n## 5.Docker 的核心架构\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085-0291323.png)\n\n- `镜像:` 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等\n- `容器:` 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写\n- `仓库:`用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置\n- `dockerFile:`docker生成镜像配置文件,用来书写自定义镜像的一些配置\n- `tar:`一个对镜像打包的文件,日后可以还原成镜像\n\n## 6. Docker 配置阿里镜像加速服务\n\n### 6.1 docker 运行流程\n\n![image-20200404120356784](Docker_1.assets/image-20200404120356784.png)\n\n### 6.2 docker配置阿里云镜像加速\n\n- `访问阿里云登录自己账号查看docker镜像加速服务`\n\n```shell\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  \"registry-mirrors\": [\"https://lz2nib3q.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n- `验证docker的镜像加速是否生效`\n\n```shell\n[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n```\n\n-----\n\n## 7.Docker的入门应用\n\n### 7.1 docker 的第一个程序\n\n> docker  run hello-world\n\n```shell\n[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n\n----\n\n## 8.常用命令\n\n### 6.1 辅助命令\n\n~~~markdown\n# 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n~~~\n\n### 6.2 Images 镜像命令\n\n~~~markdown\n# 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n~~~\n\n### 6.3 Contrainer 容器命令\n\n~~~markdown\n# 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m \"描述信息\" -a \"作者信息\"   （容器id或者名称）打包的镜像名称:标签\n~~~\n\n----\n\n## 7.docker的镜像原理\n\n### 7.1 镜像是什么？\n\n> 镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。\n\n### 7.2 为什么一个镜像会那么大？\n\n![image-20200404142950068](Docker_1.assets/image-20200404142950068.png)\n\n`镜像就是花卷`\n\n- UnionFS（联合文件系统）:\n\n  Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。	\n\n### 7.3 Docker镜像原理\n\n> `docker的镜像实际是由一层一层的文件系统组成。`\n\n- bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。\n\n- rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。\n\n- 我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。\n\n\n\n![](Docker_1.assets/1567585172(1).jpg)\n\n### 7.4 为什么docker镜像要采用这种分层结构呢?\n\n> `最大的一个好处就是资源共享`\n\n- 比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。\n\n---\n\n## 8.Docker安装常用服务\n\n### 8.1 安装mysql\n\n```markdown\n# 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' < /root/xxx.sql\n```\n\n### 8.2 安装Redis服务\n\n```markdown\n# 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n```\n\n### 8.3 安装Nginx\n\n```markdown\n# 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n```\n\n----\n\n### 8.4 安装Tomcat\n\n```markdown\n# 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n```\n\n-----\n\n### 8.5 安装MongoDB数据库\n\n```markdown\n# 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:\"root\",pwd:\"root\",roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n```\n\n### 8.6 安装ElasticSearch\n\n- `注意:`**调高JVM线程数限制数量**\n\n#### 0.拉取镜像运行elasticsearch\n\n```markdown\n# 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n```\n\n- 启动出现如下错误\n- ![image-20200602184321790](Docker_1.assets/image-20200602184321790.png)\n\n#### 1. 预先配置\n\n```markdown\n# 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n```\n\n#### 2.启动EleasticSearch容器\n\n```markdown\n# 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=\"-Xms128m -Xmx128m\" -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n```\n\n#### 3.安装IK分词器\n\n```markdown\n# 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	<properties>\n		<comment>IK Analyzer 扩展配置</comment>\n		<!--用户可以在这里配置自己的扩展字典 -->\n		<entry key=\"ext_dict\">ext_dict.dic</entry>\n		<!--用户可以在这里配置自己的扩展停止词字典-->\n		<entry key=\"ext_stopwords\">ext_stopwords.dic</entry>\n	</properties>\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=\"xiaochen\" -m=\"es with IKAnalyzer\" 容器id xiaochen/elasticsearch:6.4.2\n```\n\n#### 4. 安装Kibana\n\n```markdown\n# 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n```\n\n----\n\n## 10.Docker中出现如下错误解决方案\n\n```powershell\n[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&n=25: x509: certificate has expired or is not yet valid\n```\n\n![image-20200602183429286](Docker_1.assets/image-20200602183429286.png)\n\n- 注意:**这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步**\n\n```markdown\n# 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n```\n\n![image-20200602183718623](Docker_1.assets/image-20200602183718623.png)\n\n## 9.Dockerfile\n\n### 9.1 什么是Dockerfile\n\nDockerfile可以认为是**Docker镜像的描述文件，是由一系列命令和参数构成的脚本**。主要作用是**用来构建docker镜像的构建文件**。\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085.png)\n\n- **通过架构图可以看出通过DockerFile可以直接构建镜像**\n\n### 9.2 Dockerfile解析过程\n\n![image-20200603181253804](Docker_1.assets/image-20200603181253804.png)\n\n### 9.3 Dockerfile的保留命令\n\n官方说明:https://docs.docker.com/engine/reference/builder/\n\n| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| **FROM**       | **当前镜像是基于哪个镜像的** `第一个指令必须是FROM`          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| **RUN**        | **构建镜像时需要运行的指令**                                 |\n| **EXPOSE**     | **当前容器对外暴露出的端口号**                               |\n| **WORKDIR**    | **指定在创建容器后，终端默认登录进来的工作目录，一个落脚点** |\n| **ENV**        | **用来在构建镜像过程中设置环境变量**                         |\n| **ADD**        | **将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包** |\n| **COPY**       | **类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置** |\n| **VOLUME**     | **容器数据卷，用于数据保存和持久化工作**                     |\n| **CMD**        | **指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换** |\n| **ENTRYPOINT** | **指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数** |\n\n#### 9.3.1 FROM 命令\n\n- 基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现\n\n- 语法:\n\n  ```dockerfile\n  FROM  <image>\n  FROM  <image>[:<tag>]     使用版本不写为latest\n  FROM  <image>[@<digest>]  使用摘要\n  ```\n\n#### 9.3.2 MAINTAINER  命令\n\n- 镜像维护者的姓名和邮箱地址[废弃]\n\n- 语法:\n\n  ```dockerfile\n  MAINTAINER <name>\n  ```\n\n#### 9.3.3 RUN 命令\n\n- RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步\n\n- 语法:\n\n  ```dockerfile\n  RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\n  RUN echo hello\n  \n  RUN [\"executable\", \"param1\", \"param2\"] (exec form)\n  RUN [\"/bin/bash\", \"-c\", \"echo hello\"]\n  ```\n\n#### 9.3.4 EXPOSE 命令\n\n- 用来指定构建的镜像在运行为容器时对外暴露的端口\n\n- 语法:\n\n  ```dockerfile\n  EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\n  EXPOSE 80/udp\n  ```\n\n#### 9.3.5 CMD 命令\n\n- 用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n- 注意: **Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。**\n\n- 语法:\n\n  ```dockerfile\n  CMD [\"executable\",\"param1\",\"param2\"] (exec form, this is the preferred form)\n  CMD [\"param1\",\"param2\"] (as default parameters to ENTRYPOINT)\n  CMD command param1 param2 (shell form)\n  ```\n\n#### 9.3.6 WORKDIR 命令\n\n- 用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。\n\n- 语法:\n\n  ```dockerfile\n  WORKDIR /path/to/workdir\n  \n  WORKDIR /a\n  WORKDIR b\n  WORKDIR c\n  `注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n  ```\n\n#### 9.3.7 ENV 命令\n\n- 用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。\n\n- 语法：\n\n  ```dockerfile\n  ENV <key> <value>\n  ENV <key>=<value> ...\n  ```\n\n#### 9.3.8 ADD 命令\n\n- 用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。\n\n- 语法:\n\n  ```dockerfile\n  ADD hom* /mydir/       通配符添加多个文件\n  ADD hom?.txt /mydir/   通配符添加\n  ADD test.txt relativeDir/  可以指定相对路径\n  ADD test.txt /absoluteDir/ 也可以指定绝对路径\n  ADD url \n  ```\n\n#### 9.3.9 COPY 命令\n\n- 用来将context目录中指定文件复制到镜像的指定目录中\n\n- 语法:\n\n  ```dockerfile\n  COPY src dest\n  COPY [\"<src>\",... \"<dest>\"]\n  ```\n\n#### 9.3.10 VOLUME 命令\n\n- 用来定义容器运行时可以挂在到宿主机的目录\n\n- 语法:\n\n  ```dockerfile\n  VOLUME [\"/data\"]\n  ```\n\n#### 9.3.11 ENTRYPOINT命令\n\n- 用来指定容器启动时执行命令和CMD类似\n\n- 语法:\n\n  ```dockerfile\n    [\"executable\", \"param1\", \"param2\"]\n  ENTRYPOINT command param1 param2\n  ```\n\n  ENTRYPOINT指令，往往用于设置容器启动后的**第一个命令**，这对一个容器来说往往是固定的。\n  CMD指令，往往用于设置容器启动的第一个命令的**默认参数**，这对一个容器来说可以是变化的。\n\n#### 9.3.11 ENTRYPOINT命令\n\n### 9.4 Dockerfile构建springboot项目部署\n\n##### 1.准备springboot可运行项目\n\n![image-20200605172151266](Docker_1.assets/image-20200605172151266.png)\n\n##### 2.将可运行项目放入linux虚拟机中\n\n![image-20200605172340380](Docker_1.assets/image-20200605172340380.png)\n\n##### 3.编写Dockerfile\n\n```dockerfile\nFROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [\"java\",\"-jar\"]\nCMD [\"ems.jar\"]\n```\n\n##### 4.构建镜像\n\n```shell\n[root@localhost ems]# docker build -t ems .\n```\n\n##### 5.运行镜像\n\n```shell\n[root@localhost ems]# docker run -p 8989:8989 ems\n```\n\n##### 6.访问项目\n\n```http\nhttp://10.15.0.8:8989/ems/login.html\n```\n\n![image-20200605173141636](Docker_1.assets/image-20200605173141636.png)\n\n---\n\n## 10.高级网络配置\n\n### 10.1 说明\n\n当 Docker 启动时，会自动在主机上创建一个 `docker0` 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n同时，Docker 随机分配一个本地未占用的私有网段（在 [RFC1918](https://tools.ietf.org/html/rfc1918) 中定义）中的一个地址给 `docker0` 接口。比如典型的 `172.17.42.1`，掩码为 `255.255.0.0`。此后启动的容器内的网口也会自动分配一个同一网段（`172.17.0.0/16`）的地址。\n\n当创建一个 Docker 容器的时候，同时会创建了一对 `veth pair` 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 `eth0`；另一端在本地并被挂载到 `docker0` 网桥，名称以 `veth` 开头（例如 `vethAQI2QT`）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。\n\n![image-20201125105847896](Docker_1.assets/image-20201125105847896.png)\n\n### 10.2 查看网络信息\n\n```markdown\n# docker network ls\n```\n\n### 10.3 创建一个网桥\n\n```markdown\n# docker network create -d bridge 网桥名称\n```\n\n### 10.4 删除一个网桥\n\n```markdown\n# docker network rm 网桥名称\n```\n\n### 10.5 容器之前使用网络通信\n\n```markdown\n# 1.查询当前网络配置\n- docker network ls\n```\n\n```shell\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n```\n\n```markdown\n# 2.创建桥接网络\n- docker network create -d bridge info\n```\n\n```shell\n[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n```\n\n```markdown\n# 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n```\n\n```shell\n[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               \"/docker-entrypoint.…\"   3 seconds ago       Up 2 seconds        0.0.0.0:8891->80/tcp   nginx002\nc315bcc94e9d        nginx               \"/docker-entrypoint.…\"   7 minutes ago       Up 7 minutes        0.0.0.0:8890->80/tcp   nginx001\nb63169d43792        mysql:5.7.19        \"docker-entrypoint.s…\"   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n.....\n```\n\n---\n\n## 11.高级数据卷配置\n\n### 11.1 说明\n\n`数据卷` 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：\n\n- `数据卷` 可以在容器之间共享和重用\n- 对 `数据卷` 的修改会立马生效\n- 对 `数据卷` 的更新，不会影响镜像\n- `数据卷` 默认会一直存在，即使容器被删除\n\n> 注意：`数据卷` 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n\n### 11.2 创建数据卷\n\n```shell\n[root@centos ~]# docker volume create my-vol\nmy-vol\n```\n\n### 11.3 查看数据卷\n\n```shell\n[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        \"CreatedAt\": \"2020-11-25T11:43:56+08:00\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\",\n        \"Name\": \"my-vol\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n```\n\n### 11.4 挂载数据卷\n\n```shell\n[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				\"Mounts\": [\n            {\n                \"Type\": \"volume\",\n                \"Name\": \"my-vol\",\n                \"Source\": \"/var/lib/docker/volumes/my-vol/_data\",\n                \"Destination\": \"/usr/share/nginx/html\",\n                \"Driver\": \"local\",\n                \"Mode\": \"z\",\n                \"RW\": true,\n                \"Propagation\": \"\"\n            }\n        ],\n```\n\n### 11.5 删除数据卷\n\n```shell\ndocker volume rm my-vol\n```\n\n---\n\n## 12.Docker Compose\n\n### 12.1 简介\n\n`Compose` 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 `OpenStack` 中的 `Heat` 十分类似。\n\n其代码目前在 https://github.com/docker/compose 上开源。\n\n`Compose` 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。\n\n通过第一部分中的介绍，我们知道使用一个 `Dockerfile` 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。\n\n`Compose` 恰好满足了这样的需求。它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\n\n`Compose` 中有两个重要的概念：\n\n- 服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。\n\n`Compose` 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n`Compose` 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 `Compose` 来进行编排管理。\n\n### 12.2 安装与卸载\n\n###### 1.linux\n\n- 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。\n\n```bash\n$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n```\n\n###### 2.macos、window\n\n- Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。`Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用`。\n\n###### 3.bash命令补全\n\n```shell\n$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose\n```\n\n###### 4.卸载\n\n- 如果是二进制包方式安装的，删除二进制文件即可。\n\n```shell\n$ sudo rm /usr/local/bin/docker-compose\n```\n\n###### 5.测试安装成功\n\n```shell\n$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n```\n\n### 12.3 docker compose使用\n\n```markdown\n# 1.相关概念\n```\n\n首先介绍几个术语。\n\n- 服务 (`service`)：一个应用容器，实际上可以运行多个相同镜像的实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，`Compose` 面向项目进行管理。\n\n```markdown\n# 2.场景\n```\n\n最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。\n\n- springboot应用\n- mysql服务\n- redis服务\n- elasticsearch服务\n- .......\n\n````markdown\n# 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n````\n\n```yml\nversion: \"3.0\"\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - \"6379:6379\"\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n```\n\n```markdown\n# 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n```\n\n```bash\n[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n```\n\n---\n\n### 12.4 docker-compose 模板文件\n\n模板文件是使用 `Compose` 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 `docker run` 相关参数的含义都是类似的。\n\n默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式。\n\n```yaml\nversion: \"3\"\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - \"80:80\"\n    volumes:\n      - \"/data\"\n```\n\n注意每个服务都必须通过 `image` 指令指定镜像或 `build` 指令（需要 Dockerfile）等来自动构建生成镜像。\n\n如果使用 `build` 指令，在 `Dockerfile` 中设置的选项(例如：`CMD`, `EXPOSE`, `VOLUME`, `ENV` 等) 将会自动被获取，无需在 `docker-compose.yml` 中重复设置。\n\n下面分别介绍各个指令的用法。\n\n#### `build`\n\n指定 `Dockerfile` 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 `Compose` 将会利用它自动构建这个镜像，然后使用这个镜像。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n```\n\n你也可以使用 `context` 指令指定 `Dockerfile` 所在文件夹的路径。\n\n使用 `dockerfile` 指令指定 `Dockerfile` 文件名。\n\n使用 `arg` 指令指定构建镜像时的变量。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n```\n\n#### `command`\n\n覆盖容器启动后默认执行的命令。\n\n```yaml\ncommand: echo \"hello world\"\n```\n\n#### `container_name`\n\n指定容器名称。默认将会使用 `项目名称_服务名称_序号` 这样的格式。\n\n```yaml\ncontainer_name: docker-web-container\n```\n\n> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。\n\n#### `depends_on`\n\n解决容器的依赖、启动先后的问题。以下例子中会先启动 `redis` `db` 再启动 `web`\n\n```yaml\nversion: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n```\n\n> 注意：`web` 服务不会等待 `redis` `db` 「完全启动」之后才启动。\n\n#### `env_file`\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 `env_file` 中变量的路径会基于模板文件路径。\n\n如果有变量名称与 `environment` 指令冲突，则按照惯例，以后者为准。\n\n```bash\nenv_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n```\n\n环境变量文件中每一行必须符合格式，支持 `#` 开头的注释行。\n\n```bash\n# common.env: Set development environment\nPROG_ENV=development\n```\n\n#### `environment`\n\n设置环境变量。你可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。\n\n```yaml\nenvironment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n```\n\n如果变量名称或者值中用到 `true|false，yes|no` 等表达 [布尔](https://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括\n\n```bash\ny|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n```\n\n#### `healthcheck`\n\n通过命令检查容器是否健康运行。\n\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n```\n\n#### `image`\n\n指定为镜像名称或镜像 ID。如果镜像在本地不存在，`Compose` 将会尝试拉取这个镜像。\n\n```yaml\nimage: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n```\n\n#### `networks`\n\n配置容器连接的网络。\n\n```yaml\nversion: \"3\"\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n```\n\n#### `ports`\n\n暴露端口信息。\n\n使用宿主端口：容器端口 `(HOST:CONTAINER)` 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。\n\n```yaml\nports:\n - \"3000\"\n - \"8000:8000\"\n - \"49100:22\"\n - \"127.0.0.1:8001:8001\"\n```\n\n*注意：当使用 `HOST:CONTAINER` 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 `YAML` 会自动解析 `xx:yy` 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。*\n\n#### `sysctls`\n\n配置容器内核参数。\n\n```yaml\nsysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n```\n\n#### `ulimits`\n\n指定容器的 ulimits 限制值。\n\n例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。\n\n```yaml\n  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n```\n\n#### `volumes`\n\n数据卷所挂载路径设置。可以设置为宿主机路径(`HOST:CONTAINER`)或者数据卷名称(`VOLUME:CONTAINER`)，并且可以设置访问模式 （`HOST:CONTAINER:ro`）。\n\n该指令中路径支持相对路径。\n\n```yaml\nvolumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n```\n\n如果路径为数据卷名称，必须在文件中配置数据卷。\n\n```yaml\nversion: \"3\"\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n```\n\n---\n\n### 12.5 docker-compose 常用命令\n\n##### 1. 命令对象与格式\n\n对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。\n\n执行 `docker-compose [COMMAND] --help` 或者 `docker-compose help [COMMAND]` 可以查看具体某个命令的使用格式。\n\n`docker-compose` 命令的基本的使用格式是\n\n```bash\ndocker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]\n```\n\n##### 2. 命令选项\n\n- `-f, --file FILE` 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。\n- `-p, --project-name NAME` 指定项目名称，默认将使用所在目录名称作为项目名。\n- `--x-networking` 使用 Docker 的可拔插网络后端特性\n- `--x-network-driver DRIVER` 指定网络后端的驱动，默认为 `bridge`\n- `--verbose` 输出更多调试信息。\n- `-v, --version` 打印版本并退出。\n\n##### 3.命令使用说明\n\n##### `up`\n\n格式为 `docker-compose up [options] [SERVICE...]`。\n\n- 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。\n\n- 链接的服务都将会被自动启动，除非已经处于运行状态。\n\n- 可以说，大部分时候都可以直接通过该命令来启动一个项目。\n\n- 默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。\n\n- 当通过 `Ctrl-C` 停止命令时，所有容器将会停止。\n\n- 如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。\n\n- 默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 `volumes-from` 挂载的卷），以保证新启动的服务匹配 `docker-compose.yml` 文件的最新内容\n\n---\n\n##### `down`\n\n- 此命令将会停止 `up` 命令所启动的容器，并移除网络\n\n----\n\n##### `exec`\n\n- 进入指定的容器。\n\n----\n\n##### `ps`\n\n格式为 `docker-compose ps [options] [SERVICE...]`。\n\n列出项目中目前的所有容器。\n\n选项：\n\n- `-q` 只打印容器的 ID 信息。\n\n----\n\n##### `restart`\n\n格式为 `docker-compose restart [options] [SERVICE...]`。\n\n重启项目中的服务。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 指定重启前停止容器的超时（默认为 10 秒）。\n\n----\n\n##### `rm`\n\n格式为 `docker-compose rm [options] [SERVICE...]`。\n\n删除所有（停止状态的）服务容器。推荐先执行 `docker-compose stop` 命令来停止容器。\n\n选项：\n\n- `-f, --force` 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\n- `-v` 删除容器所挂载的数据卷。\n\n---\n\n##### `start`\n\n格式为 `docker-compose start [SERVICE...]`。\n\n启动已经存在的服务容器。\n\n----\n\n##### `stop`\n\n格式为 `docker-compose stop [options] [SERVICE...]`。\n\n停止已经处于运行状态的容器，但不删除它。通过 `docker-compose start` 可以再次启动这些容器。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。\n\n----\n\n##### `top`\n\n查看各个服务容器内运行的进程。\n\n---\n\n##### `unpause`\n\n格式为 `docker-compose unpause [SERVICE...]`。\n\n恢复处于暂停状态中的服务。\n\n------\n\n## 13.docker可视化工具\n\n#### 13.1 安装Portainer\n\n官方安装说明：[https://www.portainer.io/installation/](http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=)\n\n```shell\n[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   \"/portainer\"        5 seconds ago       Up 4 seconds        0.0.0.0:8000->8000/tcp, 0.0.0.0:9000->9000/tcp   portainer\n```\n\n#### 13.2 登录和使用Portainer\n\n> 用浏览器访问：`http://localhost:9000`\n\n![image-20201223231707738](Docker_1.assets/image-20201223231707738.png)\n\n----\n\n', 'Docker_1', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 13:54:09', 1, '2023-02-21 13:54:09', 0);
INSERT INTO `lzh_article` VALUES (1627910080968036354, 'Docker_1', '<h1>Docker</h1>\n<ul>\n<li>\n<p>官方文档地址:https://www.docker.com/get-started</p>\n</li>\n<li>\n<p>中文参考手册:https://docker_practice.gitee.io/zh-cn/</p>\n</li>\n</ul>\n<hr />\n<h2>1.什么是 Docker</h2>\n<h3>1.1 官方定义</h3>\n<ul>\n<li>最新官网首页</li>\n</ul>\n<p><img src=\"Docker_1.assets/image-20201220213306128.png\" alt=\"image-20201220213306128\" /></p>\n<p><img src=\"Docker_1.assets/image-20201220214210994.png\" alt=\"image-20201220214210994\" /></p>\n<pre><code class=\"language-markdown\"># 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n</code></pre>\n<h3>1.2 Docker的起源</h3>\n<pre><code class=\"language-markdown\">Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n</code></pre>\n<h2>2.为什么是Docker</h2>\n<ul>\n<li>\n<p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p>\n<p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p>\n<p><strong>优势1:  一致的运行环境,更轻松的迁移</strong></p>\n</li>\n<li>\n<p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p>\n<p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p>\n<p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p>\n</li>\n<li>\n<p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p>\n<p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p>\n<p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p>\n</li>\n</ul>\n<hr />\n<h2>3.Docker和虚拟机区别</h2>\n<blockquote>\n<p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p>\n</blockquote>\n<p><img src=\"Docker_1.assets/image-20201220222456675.png\" alt=\"image-20201220222456675\" /></p>\n<p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p>\n<p>|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |</p>\n<hr />\n<h2>4.Docker的安装</h2>\n<h3>4.1 安装docker(centos7.x)</h3>\n<ul>\n<li>\n<p>卸载原始docker</p>\n<pre><code class=\"language-sh\">$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n</code></pre>\n</li>\n<li>\n<p>安装docker依赖</p>\n<pre><code class=\"language-shell\">$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre>\n</li>\n<li>\n<p>设置docker的yum源</p>\n<pre><code class=\"language-bash\">$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n</code></pre>\n</li>\n<li>\n<p>安装最新版的docker</p>\n<pre><code class=\"language-bash\">$ sudo yum install docker-ce docker-ce-cli containerd.io\n</code></pre>\n</li>\n<li>\n<p>指定版本安装docker</p>\n<pre><code class=\"language-bash\">$ yum list docker-ce --showduplicates | sort -r\n$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>关闭docker</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo systemctl stop docker\n</code></pre>\n<ul>\n<li>\n<p>测试docker安装</p>\n<pre><code class=\"language-bash\">$ sudo docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h3>4.2 bash安装(通用所有平台)</h3>\n<ul>\n<li>\n<p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>\n<pre><code class=\"language-bash\">$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>创建docker用户组</p>\n<pre><code class=\"language-bash\">$ sudo groupadd docker\n</code></pre>\n</li>\n<li>\n<p>将当前用户加入docker组</p>\n<pre><code class=\"language-bash\">$ sudo usermod -aG docker $USER\n</code></pre>\n</li>\n<li>\n<p>测试docker安装是否正确</p>\n<pre><code class=\"language-bash\">$ docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h2>5.Docker 的核心架构</h2>\n<p><img src=\"Docker_1.assets/image-20200404111908085-0291323.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>\n<li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>\n<li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>\n<li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>\n<li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li>\n</ul>\n<h2>6. Docker 配置阿里镜像加速服务</h2>\n<h3>6.1 docker 运行流程</h3>\n<p><img src=\"Docker_1.assets/image-20200404120356784.png\" alt=\"image-20200404120356784\" /></p>\n<h3>6.2 docker配置阿里云镜像加速</h3>\n<ul>\n<li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li>\n</ul>\n<pre><code class=\"language-shell\">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-\'EOF\'\n{\n  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre>\n<ul>\n<li><code>验证docker的镜像加速是否生效</code></li>\n</ul>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n</code></pre>\n<hr />\n<h2>7.Docker的入门应用</h2>\n<h3>7.1 docker 的第一个程序</h3>\n<blockquote>\n<p>docker  run hello-world</p>\n</blockquote>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>\n<hr />\n<h2>8.常用命令</h2>\n<h3>6.1 辅助命令</h3>\n<pre><code class=\"language-markdown\"># 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n</code></pre>\n<h3>6.2 Images 镜像命令</h3>\n<pre><code class=\"language-markdown\"># 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n</code></pre>\n<h3>6.3 Contrainer 容器命令</h3>\n<pre><code class=\"language-markdown\"># 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签\n</code></pre>\n<hr />\n<h2>7.docker的镜像原理</h2>\n<h3>7.1 镜像是什么？</h3>\n<blockquote>\n<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>\n</blockquote>\n<h3>7.2 为什么一个镜像会那么大？</h3>\n<p><img src=\"Docker_1.assets/image-20200404142950068.png\" alt=\"image-20200404142950068\" /></p>\n<p><code>镜像就是花卷</code></p>\n<ul>\n<li>\n<p>UnionFS（联合文件系统）:</p>\n<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p>\n</li>\n</ul>\n<h3>7.3 Docker镜像原理</h3>\n<blockquote>\n<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>\n</blockquote>\n<ul>\n<li>\n<p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>\n</li>\n<li>\n<p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>\n</li>\n<li>\n<p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p>\n</li>\n</ul>\n<p><img src=\"Docker_1.assets/1567585172(1).jpg\" alt=\"\" /></p>\n<h3>7.4 为什么docker镜像要采用这种分层结构呢?</h3>\n<blockquote>\n<p><code>最大的一个好处就是资源共享</code></p>\n</blockquote>\n<ul>\n<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>\n</ul>\n<hr />\n<h2>8.Docker安装常用服务</h2>\n<h3>8.1 安装mysql</h3>\n<pre><code class=\"language-markdown\"># 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &lt; /root/xxx.sql\n</code></pre>\n<h3>8.2 安装Redis服务</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n</code></pre>\n<h3>8.3 安装Nginx</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n</code></pre>\n<hr />\n<h3>8.4 安装Tomcat</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n</code></pre>\n<hr />\n<h3>8.5 安装MongoDB数据库</h3>\n<pre><code class=\"language-markdown\"># 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n</code></pre>\n<h3>8.6 安装ElasticSearch</h3>\n<ul>\n<li><code>注意:</code><strong>调高JVM线程数限制数量</strong></li>\n</ul>\n<h4>0.拉取镜像运行elasticsearch</h4>\n<pre><code class=\"language-markdown\"># 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n</code></pre>\n<ul>\n<li>启动出现如下错误</li>\n<li><img src=\"Docker_1.assets/image-20200602184321790.png\" alt=\"image-20200602184321790\" /></li>\n</ul>\n<h4>1. 预先配置</h4>\n<pre><code class=\"language-markdown\"># 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n</code></pre>\n<h4>2.启动EleasticSearch容器</h4>\n<pre><code class=\"language-markdown\"># 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n</code></pre>\n<h4>3.安装IK分词器</h4>\n<pre><code class=\"language-markdown\"># 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	&lt;properties&gt;\n		&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;\n		&lt;!--用户可以在这里配置自己的扩展字典 --&gt;\n		&lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;\n		&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;\n		&lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;\n	&lt;/properties&gt;\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2\n</code></pre>\n<h4>4. 安装Kibana</h4>\n<pre><code class=\"language-markdown\"># 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n</code></pre>\n<hr />\n<h2>10.Docker中出现如下错误解决方案</h2>\n<pre><code class=\"language-powershell\">[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid\n</code></pre>\n<p><img src=\"Docker_1.assets/image-20200602183429286.png\" alt=\"image-20200602183429286\" /></p>\n<ul>\n<li>注意:<strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></li>\n</ul>\n<pre><code class=\"language-markdown\"># 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n</code></pre>\n<p><img src=\"Docker_1.assets/image-20200602183718623.png\" alt=\"image-20200602183718623\" /></p>\n<h2>9.Dockerfile</h2>\n<h3>9.1 什么是Dockerfile</h3>\n<p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p>\n<p><img src=\"Docker_1.assets/image-20200404111908085.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>\n</ul>\n<h3>9.2 Dockerfile解析过程</h3>\n<p><img src=\"Docker_1.assets/image-20200603181253804.png\" alt=\"image-20200603181253804\" /></p>\n<h3>9.3 Dockerfile的保留命令</h3>\n<p>官方说明:https://docs.docker.com/engine/reference/builder/</p>\n<p>| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| <strong>FROM</strong>       | <strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code>          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| <strong>RUN</strong>        | <strong>构建镜像时需要运行的指令</strong>                                 |\n| <strong>EXPOSE</strong>     | <strong>当前容器对外暴露出的端口号</strong>                               |\n| <strong>WORKDIR</strong>    | <strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong> |\n| <strong>ENV</strong>        | <strong>用来在构建镜像过程中设置环境变量</strong>                         |\n| <strong>ADD</strong>        | <strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong> |\n| <strong>COPY</strong>       | <strong>类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong> |\n| <strong>VOLUME</strong>     | <strong>容器数据卷，用于数据保存和持久化工作</strong>                     |\n| <strong>CMD</strong>        | <strong>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong> |\n| <strong>ENTRYPOINT</strong> | <strong>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong> |</p>\n<h4>9.3.1 FROM 命令</h4>\n<ul>\n<li>\n<p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">FROM  &lt;image&gt;\nFROM  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest\nFROM  &lt;image&gt;[@&lt;digest&gt;]  使用摘要\n</code></pre>\n</li>\n</ul>\n<h4>9.3.2 MAINTAINER  命令</h4>\n<ul>\n<li>\n<p>镜像维护者的姓名和邮箱地址[废弃]</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">MAINTAINER &lt;name&gt;\n</code></pre>\n</li>\n</ul>\n<h4>9.3.3 RUN 命令</h4>\n<ul>\n<li>\n<p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\nRUN echo hello\n\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)\nRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.4 EXPOSE 命令</h4>\n<ul>\n<li>\n<p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\nEXPOSE 80/udp\n</code></pre>\n</li>\n</ul>\n<h4>9.3.5 CMD 命令</h4>\n<ul>\n<li>\n<p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>\n</li>\n<li>\n<p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)\nCMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)\nCMD command param1 param2 (shell form)\n</code></pre>\n</li>\n</ul>\n<h4>9.3.6 WORKDIR 命令</h4>\n<ul>\n<li>\n<p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">WORKDIR /path/to/workdir\n\nWORKDIR /a\nWORKDIR b\nWORKDIR c\n`注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n</code></pre>\n</li>\n</ul>\n<h4>9.3.7 ENV 命令</h4>\n<ul>\n<li>\n<p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>\n</li>\n<li>\n<p>语法：</p>\n<pre><code class=\"language-dockerfile\">ENV &lt;key&gt; &lt;value&gt;\nENV &lt;key&gt;=&lt;value&gt; ...\n</code></pre>\n</li>\n</ul>\n<h4>9.3.8 ADD 命令</h4>\n<ul>\n<li>\n<p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">ADD hom* /mydir/       通配符添加多个文件\nADD hom?.txt /mydir/   通配符添加\nADD test.txt relativeDir/  可以指定相对路径\nADD test.txt /absoluteDir/ 也可以指定绝对路径\nADD url \n</code></pre>\n</li>\n</ul>\n<h4>9.3.9 COPY 命令</h4>\n<ul>\n<li>\n<p>用来将context目录中指定文件复制到镜像的指定目录中</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">COPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.10 VOLUME 命令</h4>\n<ul>\n<li>\n<p>用来定义容器运行时可以挂在到宿主机的目录</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">VOLUME [&quot;/data&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<ul>\n<li>\n<p>用来指定容器启动时执行命令和CMD类似</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2\n</code></pre>\n<p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。\nCMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<h3>9.4 Dockerfile构建springboot项目部署</h3>\n<h5>1.准备springboot可运行项目</h5>\n<p><img src=\"Docker_1.assets/image-20200605172151266.png\" alt=\"image-20200605172151266\" /></p>\n<h5>2.将可运行项目放入linux虚拟机中</h5>\n<p><img src=\"Docker_1.assets/image-20200605172340380.png\" alt=\"image-20200605172340380\" /></p>\n<h5>3.编写Dockerfile</h5>\n<pre><code class=\"language-dockerfile\">FROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]\nCMD [&quot;ems.jar&quot;]\n</code></pre>\n<h5>4.构建镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker build -t ems .\n</code></pre>\n<h5>5.运行镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker run -p 8989:8989 ems\n</code></pre>\n<h5>6.访问项目</h5>\n<pre><code class=\"language-http\">http://10.15.0.8:8989/ems/login.html\n</code></pre>\n<p><img src=\"Docker_1.assets/image-20200605173141636.png\" alt=\"image-20200605173141636\" /></p>\n<hr />\n<h2>10.高级网络配置</h2>\n<h3>10.1 说明</h3>\n<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href=\"https://tools.ietf.org/html/rfc1918\">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>\n<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>\n<p><img src=\"Docker_1.assets/image-20201125105847896.png\" alt=\"image-20201125105847896\" /></p>\n<h3>10.2 查看网络信息</h3>\n<pre><code class=\"language-markdown\"># docker network ls\n</code></pre>\n<h3>10.3 创建一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network create -d bridge 网桥名称\n</code></pre>\n<h3>10.4 删除一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network rm 网桥名称\n</code></pre>\n<h3>10.5 容器之前使用网络通信</h3>\n<pre><code class=\"language-markdown\"># 1.查询当前网络配置\n- docker network ls\n</code></pre>\n<pre><code class=\"language-shell\">NETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n</code></pre>\n<pre><code class=\"language-markdown\"># 2.创建桥接网络\n- docker network create -d bridge info\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n</code></pre>\n<pre><code class=\"language-markdown\"># 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002\nc315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001\nb63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n.....\n</code></pre>\n<hr />\n<h2>11.高级数据卷配置</h2>\n<h3>11.1 说明</h3>\n<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>\n<ul>\n<li><code>数据卷</code> 可以在容器之间共享和重用</li>\n<li>对 <code>数据卷</code> 的修改会立马生效</li>\n<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>\n<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>\n</ul>\n<blockquote>\n<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>\n</blockquote>\n<h3>11.2 创建数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume create my-vol\nmy-vol\n</code></pre>\n<h3>11.3 查看数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: {},\n        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n        &quot;Name&quot;: &quot;my-vol&quot;,\n        &quot;Options&quot;: {},\n        &quot;Scope&quot;: &quot;local&quot;\n    }\n]\n</code></pre>\n<h3>11.4 挂载数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				&quot;Mounts&quot;: [\n            {\n                &quot;Type&quot;: &quot;volume&quot;,\n                &quot;Name&quot;: &quot;my-vol&quot;,\n                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,\n                &quot;Driver&quot;: &quot;local&quot;,\n                &quot;Mode&quot;: &quot;z&quot;,\n                &quot;RW&quot;: true,\n                &quot;Propagation&quot;: &quot;&quot;\n            }\n        ],\n</code></pre>\n<h3>11.5 删除数据卷</h3>\n<pre><code class=\"language-shell\">docker volume rm my-vol\n</code></pre>\n<hr />\n<h2>12.Docker Compose</h2>\n<h3>12.1 简介</h3>\n<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>\n<p>其代码目前在 https://github.com/docker/compose 上开源。</p>\n<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>\n<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>\n<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>\n<p><code>Compose</code> 中有两个重要的概念：</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>\n</ul>\n<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>\n<h3>12.2 安装与卸载</h3>\n<h6>1.linux</h6>\n<ul>\n<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n</code></pre>\n<h6>2.macos、window</h6>\n<ul>\n<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>\n</ul>\n<h6>3.bash命令补全</h6>\n<pre><code class=\"language-shell\">$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose\n</code></pre>\n<h6>4.卸载</h6>\n<ul>\n<li>如果是二进制包方式安装的，删除二进制文件即可。</li>\n</ul>\n<pre><code class=\"language-shell\">$ sudo rm /usr/local/bin/docker-compose\n</code></pre>\n<h6>5.测试安装成功</h6>\n<pre><code class=\"language-shell\">$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n</code></pre>\n<h3>12.3 docker compose使用</h3>\n<pre><code class=\"language-markdown\"># 1.相关概念\n</code></pre>\n<p>首先介绍几个术语。</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>\n</ul>\n<pre><code class=\"language-markdown\"># 2.场景\n</code></pre>\n<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>\n<ul>\n<li>springboot应用</li>\n<li>mysql服务</li>\n<li>redis服务</li>\n<li>elasticsearch服务</li>\n<li>.......</li>\n</ul>\n<pre><code class=\"language-markdown\"># 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n</code></pre>\n<pre><code class=\"language-yml\">version: &quot;3.0&quot;\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - &quot;3306:3306&quot;\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - &quot;6379:6379&quot;\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n</code></pre>\n<pre><code class=\"language-markdown\"># 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n</code></pre>\n<pre><code class=\"language-bash\">[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n</code></pre>\n<hr />\n<h3>12.4 docker-compose 模板文件</h3>\n<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>\n<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      - &quot;/data&quot;\n</code></pre>\n<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>\n<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>\n<p>下面分别介绍各个指令的用法。</p>\n<h4><code>build</code></h4>\n<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n</code></pre>\n<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>\n<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>\n<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n</code></pre>\n<h4><code>command</code></h4>\n<p>覆盖容器启动后默认执行的命令。</p>\n<pre><code class=\"language-yaml\">command: echo &quot;hello world&quot;\n</code></pre>\n<h4><code>container_name</code></h4>\n<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>\n<pre><code class=\"language-yaml\">container_name: docker-web-container\n</code></pre>\n<blockquote>\n<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>\n</blockquote>\n<h4><code>depends_on</code></h4>\n<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>\n<pre><code class=\"language-yaml\">version: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n</code></pre>\n<blockquote>\n<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>\n</blockquote>\n<h4><code>env_file</code></h4>\n<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>\n<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>\n<pre><code class=\"language-bash\">env_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n</code></pre>\n<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>\n<pre><code class=\"language-bash\"># common.env: Set development environment\nPROG_ENV=development\n</code></pre>\n<h4><code>environment</code></h4>\n<p>设置环境变量。你可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>\n<pre><code class=\"language-yaml\">environment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n</code></pre>\n<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href=\"https://yaml.org/type/bool.html\">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>\n<pre><code class=\"language-bash\">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n</code></pre>\n<h4><code>healthcheck</code></h4>\n<p>通过命令检查容器是否健康运行。</p>\n<pre><code class=\"language-yaml\">healthcheck:\n  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n</code></pre>\n<h4><code>image</code></h4>\n<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>\n<pre><code class=\"language-yaml\">image: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n</code></pre>\n<h4><code>networks</code></h4>\n<p>配置容器连接的网络。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n</code></pre>\n<h4><code>ports</code></h4>\n<p>暴露端口信息。</p>\n<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>\n<pre><code class=\"language-yaml\">ports:\n - &quot;3000&quot;\n - &quot;8000:8000&quot;\n - &quot;49100:22&quot;\n - &quot;127.0.0.1:8001:8001&quot;\n</code></pre>\n<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>\n<h4><code>sysctls</code></h4>\n<p>配置容器内核参数。</p>\n<pre><code class=\"language-yaml\">sysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n</code></pre>\n<h4><code>ulimits</code></h4>\n<p>指定容器的 ulimits 限制值。</p>\n<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>\n<pre><code class=\"language-yaml\">  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n</code></pre>\n<h4><code>volumes</code></h4>\n<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>\n<p>该指令中路径支持相对路径。</p>\n<pre><code class=\"language-yaml\">volumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n</code></pre>\n<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n</code></pre>\n<hr />\n<h3>12.5 docker-compose 常用命令</h3>\n<h5>1. 命令对象与格式</h5>\n<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>\n<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>\n<p><code>docker-compose</code> 命令的基本的使用格式是</p>\n<pre><code class=\"language-bash\">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]\n</code></pre>\n<h5>2. 命令选项</h5>\n<ul>\n<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>\n<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>\n<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>\n<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>\n<li><code>--verbose</code> 输出更多调试信息。</li>\n<li><code>-v, --version</code> 打印版本并退出。</li>\n</ul>\n<h5>3.命令使用说明</h5>\n<h5><code>up</code></h5>\n<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>\n<ul>\n<li>\n<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>\n</li>\n<li>\n<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>\n</li>\n<li>\n<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\n</li>\n<li>\n<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>\n</li>\n<li>\n<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>\n</li>\n<li>\n<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>\n</li>\n<li>\n<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>\n</li>\n</ul>\n<hr />\n<h5><code>down</code></h5>\n<ul>\n<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>\n</ul>\n<hr />\n<h5><code>exec</code></h5>\n<ul>\n<li>进入指定的容器。</li>\n</ul>\n<hr />\n<h5><code>ps</code></h5>\n<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>\n<p>列出项目中目前的所有容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-q</code> 只打印容器的 ID 信息。</li>\n</ul>\n<hr />\n<h5><code>restart</code></h5>\n<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>\n<p>重启项目中的服务。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>rm</code></h5>\n<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>\n<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>\n<li><code>-v</code> 删除容器所挂载的数据卷。</li>\n</ul>\n<hr />\n<h5><code>start</code></h5>\n<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>\n<p>启动已经存在的服务容器。</p>\n<hr />\n<h5><code>stop</code></h5>\n<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>\n<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>top</code></h5>\n<p>查看各个服务容器内运行的进程。</p>\n<hr />\n<h5><code>unpause</code></h5>\n<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>\n<p>恢复处于暂停状态中的服务。</p>\n<hr />\n<h2>13.docker可视化工具</h2>\n<h4>13.1 安装Portainer</h4>\n<p>官方安装说明：<a href=\"http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=\">https://www.portainer.io/installation/</a></p>\n<pre><code class=\"language-shell\">[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer\n</code></pre>\n<h4>13.2 登录和使用Portainer</h4>\n<blockquote>\n<p>用浏览器访问：<code>http://localhost:9000</code></p>\n</blockquote>\n<p><img src=\"Docker_1.assets/image-20201223231707738.png\" alt=\"image-20201223231707738\" /></p>\n<hr />\n', '# Docker\n\n- 官方文档地址:https://www.docker.com/get-started\n\n- 中文参考手册:https://docker_practice.gitee.io/zh-cn/\n\n-----\n\n## 1.什么是 Docker\n\n### 1.1 官方定义\n\n- 最新官网首页\n\n![image-20201220213306128](Docker_1.assets/image-20201220213306128.png)\n\n![image-20201220214210994](Docker_1.assets/image-20201220214210994.png)\n\n```markdown\n# 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n```\n\n### 1.2 Docker的起源\n\n```markdown\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n```\n\n## 2.为什么是Docker\n\n- `在开发的时候，在本机测试环境可以跑，生产环境跑不起来`\n\n  这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。\n\n  **优势1:  一致的运行环境,更轻松的迁移**\n\n  \n\n- `服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了`\n\n  这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。\n\n  **优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源**\n\n  \n\n- `公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器`\n\n  在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。\n  \n  **优势3: 通过镜像复制N多个环境一致容器**\n\n----\n\n## 3.Docker和虚拟机区别\n\n> 关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。\n\n![image-20201220222456675](Docker_1.assets/image-20201220222456675.png)\n\n`比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重`。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存->虚拟物理内存->真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存->真正物理内存。\n\n|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |\n\n---\n\n## 4.Docker的安装\n\n### 4.1 安装docker(centos7.x)\n\n- 卸载原始docker\n\n  ```sh\n  $ sudo yum remove docker \\\n                    docker-client \\\n                    docker-client-latest \\\n                    docker-common \\\n                    docker-latest \\\n                    docker-latest-logrotate \\\n                    docker-logrotate \\\n                    docker-engine\n  ```\n\n- 安装docker依赖\n\n  ```shell\n  $ sudo yum install -y yum-utils \\\n    device-mapper-persistent-data \\\n    lvm2\n  ```\n\n- 设置docker的yum源\n\n  ```bash\n  $ sudo yum-config-manager \\\n      --add-repo \\\n      https://download.docker.com/linux/centos/docker-ce.repo\n  ```\n\n- 安装最新版的docker\n\n  ```bash\n  $ sudo yum install docker-ce docker-ce-cli containerd.io\n  ```\n\n- 指定版本安装docker\n\n  ```bash\n  $ yum list docker-ce --showduplicates | sort -r\n  $ sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\n  $ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n-  关闭docker\n\n  ```bash\n  $ sudo systemctl stop docker\n  ```\n\n- 测试docker安装\n\n  ```bash\n  $ sudo docker run hello-world\n  ```\n\n### 4.2 bash安装(通用所有平台)\n\n- 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\n\n  ```bash\n  $ curl -fsSL get.docker.com -o get-docker.sh\n  $ sudo sh get-docker.sh --mirror Aliyun\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n- 创建docker用户组\n\n  ```bash\n  $ sudo groupadd docker\n  ```\n\n- 将当前用户加入docker组\n\n  ```bash\n  $ sudo usermod -aG docker $USER\n  ```\n\n- 测试docker安装是否正确\n\n  ```bash\n  $ docker run hello-world\n  ```\n\n## 5.Docker 的核心架构\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085-0291323.png)\n\n- `镜像:` 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等\n- `容器:` 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写\n- `仓库:`用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置\n- `dockerFile:`docker生成镜像配置文件,用来书写自定义镜像的一些配置\n- `tar:`一个对镜像打包的文件,日后可以还原成镜像\n\n## 6. Docker 配置阿里镜像加速服务\n\n### 6.1 docker 运行流程\n\n![image-20200404120356784](Docker_1.assets/image-20200404120356784.png)\n\n### 6.2 docker配置阿里云镜像加速\n\n- `访问阿里云登录自己账号查看docker镜像加速服务`\n\n```shell\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  \"registry-mirrors\": [\"https://lz2nib3q.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n- `验证docker的镜像加速是否生效`\n\n```shell\n[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n```\n\n-----\n\n## 7.Docker的入门应用\n\n### 7.1 docker 的第一个程序\n\n> docker  run hello-world\n\n```shell\n[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n\n----\n\n## 8.常用命令\n\n### 6.1 辅助命令\n\n~~~markdown\n# 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n~~~\n\n### 6.2 Images 镜像命令\n\n~~~markdown\n# 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n~~~\n\n### 6.3 Contrainer 容器命令\n\n~~~markdown\n# 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m \"描述信息\" -a \"作者信息\"   （容器id或者名称）打包的镜像名称:标签\n~~~\n\n----\n\n## 7.docker的镜像原理\n\n### 7.1 镜像是什么？\n\n> 镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。\n\n### 7.2 为什么一个镜像会那么大？\n\n![image-20200404142950068](Docker_1.assets/image-20200404142950068.png)\n\n`镜像就是花卷`\n\n- UnionFS（联合文件系统）:\n\n  Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。	\n\n### 7.3 Docker镜像原理\n\n> `docker的镜像实际是由一层一层的文件系统组成。`\n\n- bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。\n\n- rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。\n\n- 我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。\n\n\n\n![](Docker_1.assets/1567585172(1).jpg)\n\n### 7.4 为什么docker镜像要采用这种分层结构呢?\n\n> `最大的一个好处就是资源共享`\n\n- 比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。\n\n---\n\n## 8.Docker安装常用服务\n\n### 8.1 安装mysql\n\n```markdown\n# 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' < /root/xxx.sql\n```\n\n### 8.2 安装Redis服务\n\n```markdown\n# 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n```\n\n### 8.3 安装Nginx\n\n```markdown\n# 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n```\n\n----\n\n### 8.4 安装Tomcat\n\n```markdown\n# 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n```\n\n-----\n\n### 8.5 安装MongoDB数据库\n\n```markdown\n# 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:\"root\",pwd:\"root\",roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n```\n\n### 8.6 安装ElasticSearch\n\n- `注意:`**调高JVM线程数限制数量**\n\n#### 0.拉取镜像运行elasticsearch\n\n```markdown\n# 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n```\n\n- 启动出现如下错误\n- ![image-20200602184321790](Docker_1.assets/image-20200602184321790.png)\n\n#### 1. 预先配置\n\n```markdown\n# 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n```\n\n#### 2.启动EleasticSearch容器\n\n```markdown\n# 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=\"-Xms128m -Xmx128m\" -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n```\n\n#### 3.安装IK分词器\n\n```markdown\n# 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	<properties>\n		<comment>IK Analyzer 扩展配置</comment>\n		<!--用户可以在这里配置自己的扩展字典 -->\n		<entry key=\"ext_dict\">ext_dict.dic</entry>\n		<!--用户可以在这里配置自己的扩展停止词字典-->\n		<entry key=\"ext_stopwords\">ext_stopwords.dic</entry>\n	</properties>\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=\"xiaochen\" -m=\"es with IKAnalyzer\" 容器id xiaochen/elasticsearch:6.4.2\n```\n\n#### 4. 安装Kibana\n\n```markdown\n# 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n```\n\n----\n\n## 10.Docker中出现如下错误解决方案\n\n```powershell\n[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&n=25: x509: certificate has expired or is not yet valid\n```\n\n![image-20200602183429286](Docker_1.assets/image-20200602183429286.png)\n\n- 注意:**这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步**\n\n```markdown\n# 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n```\n\n![image-20200602183718623](Docker_1.assets/image-20200602183718623.png)\n\n## 9.Dockerfile\n\n### 9.1 什么是Dockerfile\n\nDockerfile可以认为是**Docker镜像的描述文件，是由一系列命令和参数构成的脚本**。主要作用是**用来构建docker镜像的构建文件**。\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085.png)\n\n- **通过架构图可以看出通过DockerFile可以直接构建镜像**\n\n### 9.2 Dockerfile解析过程\n\n![image-20200603181253804](Docker_1.assets/image-20200603181253804.png)\n\n### 9.3 Dockerfile的保留命令\n\n官方说明:https://docs.docker.com/engine/reference/builder/\n\n| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| **FROM**       | **当前镜像是基于哪个镜像的** `第一个指令必须是FROM`          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| **RUN**        | **构建镜像时需要运行的指令**                                 |\n| **EXPOSE**     | **当前容器对外暴露出的端口号**                               |\n| **WORKDIR**    | **指定在创建容器后，终端默认登录进来的工作目录，一个落脚点** |\n| **ENV**        | **用来在构建镜像过程中设置环境变量**                         |\n| **ADD**        | **将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包** |\n| **COPY**       | **类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置** |\n| **VOLUME**     | **容器数据卷，用于数据保存和持久化工作**                     |\n| **CMD**        | **指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换** |\n| **ENTRYPOINT** | **指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数** |\n\n#### 9.3.1 FROM 命令\n\n- 基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现\n\n- 语法:\n\n  ```dockerfile\n  FROM  <image>\n  FROM  <image>[:<tag>]     使用版本不写为latest\n  FROM  <image>[@<digest>]  使用摘要\n  ```\n\n#### 9.3.2 MAINTAINER  命令\n\n- 镜像维护者的姓名和邮箱地址[废弃]\n\n- 语法:\n\n  ```dockerfile\n  MAINTAINER <name>\n  ```\n\n#### 9.3.3 RUN 命令\n\n- RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步\n\n- 语法:\n\n  ```dockerfile\n  RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\n  RUN echo hello\n  \n  RUN [\"executable\", \"param1\", \"param2\"] (exec form)\n  RUN [\"/bin/bash\", \"-c\", \"echo hello\"]\n  ```\n\n#### 9.3.4 EXPOSE 命令\n\n- 用来指定构建的镜像在运行为容器时对外暴露的端口\n\n- 语法:\n\n  ```dockerfile\n  EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\n  EXPOSE 80/udp\n  ```\n\n#### 9.3.5 CMD 命令\n\n- 用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n- 注意: **Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。**\n\n- 语法:\n\n  ```dockerfile\n  CMD [\"executable\",\"param1\",\"param2\"] (exec form, this is the preferred form)\n  CMD [\"param1\",\"param2\"] (as default parameters to ENTRYPOINT)\n  CMD command param1 param2 (shell form)\n  ```\n\n#### 9.3.6 WORKDIR 命令\n\n- 用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。\n\n- 语法:\n\n  ```dockerfile\n  WORKDIR /path/to/workdir\n  \n  WORKDIR /a\n  WORKDIR b\n  WORKDIR c\n  `注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n  ```\n\n#### 9.3.7 ENV 命令\n\n- 用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。\n\n- 语法：\n\n  ```dockerfile\n  ENV <key> <value>\n  ENV <key>=<value> ...\n  ```\n\n#### 9.3.8 ADD 命令\n\n- 用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。\n\n- 语法:\n\n  ```dockerfile\n  ADD hom* /mydir/       通配符添加多个文件\n  ADD hom?.txt /mydir/   通配符添加\n  ADD test.txt relativeDir/  可以指定相对路径\n  ADD test.txt /absoluteDir/ 也可以指定绝对路径\n  ADD url \n  ```\n\n#### 9.3.9 COPY 命令\n\n- 用来将context目录中指定文件复制到镜像的指定目录中\n\n- 语法:\n\n  ```dockerfile\n  COPY src dest\n  COPY [\"<src>\",... \"<dest>\"]\n  ```\n\n#### 9.3.10 VOLUME 命令\n\n- 用来定义容器运行时可以挂在到宿主机的目录\n\n- 语法:\n\n  ```dockerfile\n  VOLUME [\"/data\"]\n  ```\n\n#### 9.3.11 ENTRYPOINT命令\n\n- 用来指定容器启动时执行命令和CMD类似\n\n- 语法:\n\n  ```dockerfile\n    [\"executable\", \"param1\", \"param2\"]\n  ENTRYPOINT command param1 param2\n  ```\n\n  ENTRYPOINT指令，往往用于设置容器启动后的**第一个命令**，这对一个容器来说往往是固定的。\n  CMD指令，往往用于设置容器启动的第一个命令的**默认参数**，这对一个容器来说可以是变化的。\n\n#### 9.3.11 ENTRYPOINT命令\n\n### 9.4 Dockerfile构建springboot项目部署\n\n##### 1.准备springboot可运行项目\n\n![image-20200605172151266](Docker_1.assets/image-20200605172151266.png)\n\n##### 2.将可运行项目放入linux虚拟机中\n\n![image-20200605172340380](Docker_1.assets/image-20200605172340380.png)\n\n##### 3.编写Dockerfile\n\n```dockerfile\nFROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [\"java\",\"-jar\"]\nCMD [\"ems.jar\"]\n```\n\n##### 4.构建镜像\n\n```shell\n[root@localhost ems]# docker build -t ems .\n```\n\n##### 5.运行镜像\n\n```shell\n[root@localhost ems]# docker run -p 8989:8989 ems\n```\n\n##### 6.访问项目\n\n```http\nhttp://10.15.0.8:8989/ems/login.html\n```\n\n![image-20200605173141636](Docker_1.assets/image-20200605173141636.png)\n\n---\n\n## 10.高级网络配置\n\n### 10.1 说明\n\n当 Docker 启动时，会自动在主机上创建一个 `docker0` 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n同时，Docker 随机分配一个本地未占用的私有网段（在 [RFC1918](https://tools.ietf.org/html/rfc1918) 中定义）中的一个地址给 `docker0` 接口。比如典型的 `172.17.42.1`，掩码为 `255.255.0.0`。此后启动的容器内的网口也会自动分配一个同一网段（`172.17.0.0/16`）的地址。\n\n当创建一个 Docker 容器的时候，同时会创建了一对 `veth pair` 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 `eth0`；另一端在本地并被挂载到 `docker0` 网桥，名称以 `veth` 开头（例如 `vethAQI2QT`）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。\n\n![image-20201125105847896](Docker_1.assets/image-20201125105847896.png)\n\n### 10.2 查看网络信息\n\n```markdown\n# docker network ls\n```\n\n### 10.3 创建一个网桥\n\n```markdown\n# docker network create -d bridge 网桥名称\n```\n\n### 10.4 删除一个网桥\n\n```markdown\n# docker network rm 网桥名称\n```\n\n### 10.5 容器之前使用网络通信\n\n```markdown\n# 1.查询当前网络配置\n- docker network ls\n```\n\n```shell\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n```\n\n```markdown\n# 2.创建桥接网络\n- docker network create -d bridge info\n```\n\n```shell\n[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n```\n\n```markdown\n# 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n```\n\n```shell\n[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               \"/docker-entrypoint.…\"   3 seconds ago       Up 2 seconds        0.0.0.0:8891->80/tcp   nginx002\nc315bcc94e9d        nginx               \"/docker-entrypoint.…\"   7 minutes ago       Up 7 minutes        0.0.0.0:8890->80/tcp   nginx001\nb63169d43792        mysql:5.7.19        \"docker-entrypoint.s…\"   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n.....\n```\n\n---\n\n## 11.高级数据卷配置\n\n### 11.1 说明\n\n`数据卷` 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：\n\n- `数据卷` 可以在容器之间共享和重用\n- 对 `数据卷` 的修改会立马生效\n- 对 `数据卷` 的更新，不会影响镜像\n- `数据卷` 默认会一直存在，即使容器被删除\n\n> 注意：`数据卷` 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n\n### 11.2 创建数据卷\n\n```shell\n[root@centos ~]# docker volume create my-vol\nmy-vol\n```\n\n### 11.3 查看数据卷\n\n```shell\n[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        \"CreatedAt\": \"2020-11-25T11:43:56+08:00\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\",\n        \"Name\": \"my-vol\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n```\n\n### 11.4 挂载数据卷\n\n```shell\n[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				\"Mounts\": [\n            {\n                \"Type\": \"volume\",\n                \"Name\": \"my-vol\",\n                \"Source\": \"/var/lib/docker/volumes/my-vol/_data\",\n                \"Destination\": \"/usr/share/nginx/html\",\n                \"Driver\": \"local\",\n                \"Mode\": \"z\",\n                \"RW\": true,\n                \"Propagation\": \"\"\n            }\n        ],\n```\n\n### 11.5 删除数据卷\n\n```shell\ndocker volume rm my-vol\n```\n\n---\n\n## 12.Docker Compose\n\n### 12.1 简介\n\n`Compose` 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 `OpenStack` 中的 `Heat` 十分类似。\n\n其代码目前在 https://github.com/docker/compose 上开源。\n\n`Compose` 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。\n\n通过第一部分中的介绍，我们知道使用一个 `Dockerfile` 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。\n\n`Compose` 恰好满足了这样的需求。它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\n\n`Compose` 中有两个重要的概念：\n\n- 服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。\n\n`Compose` 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n`Compose` 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 `Compose` 来进行编排管理。\n\n### 12.2 安装与卸载\n\n###### 1.linux\n\n- 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。\n\n```bash\n$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n```\n\n###### 2.macos、window\n\n- Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。`Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用`。\n\n###### 3.bash命令补全\n\n```shell\n$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose\n```\n\n###### 4.卸载\n\n- 如果是二进制包方式安装的，删除二进制文件即可。\n\n```shell\n$ sudo rm /usr/local/bin/docker-compose\n```\n\n###### 5.测试安装成功\n\n```shell\n$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n```\n\n### 12.3 docker compose使用\n\n```markdown\n# 1.相关概念\n```\n\n首先介绍几个术语。\n\n- 服务 (`service`)：一个应用容器，实际上可以运行多个相同镜像的实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，`Compose` 面向项目进行管理。\n\n```markdown\n# 2.场景\n```\n\n最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。\n\n- springboot应用\n- mysql服务\n- redis服务\n- elasticsearch服务\n- .......\n\n````markdown\n# 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n````\n\n```yml\nversion: \"3.0\"\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - \"6379:6379\"\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n```\n\n```markdown\n# 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n```\n\n```bash\n[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n```\n\n---\n\n### 12.4 docker-compose 模板文件\n\n模板文件是使用 `Compose` 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 `docker run` 相关参数的含义都是类似的。\n\n默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式。\n\n```yaml\nversion: \"3\"\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - \"80:80\"\n    volumes:\n      - \"/data\"\n```\n\n注意每个服务都必须通过 `image` 指令指定镜像或 `build` 指令（需要 Dockerfile）等来自动构建生成镜像。\n\n如果使用 `build` 指令，在 `Dockerfile` 中设置的选项(例如：`CMD`, `EXPOSE`, `VOLUME`, `ENV` 等) 将会自动被获取，无需在 `docker-compose.yml` 中重复设置。\n\n下面分别介绍各个指令的用法。\n\n#### `build`\n\n指定 `Dockerfile` 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 `Compose` 将会利用它自动构建这个镜像，然后使用这个镜像。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n```\n\n你也可以使用 `context` 指令指定 `Dockerfile` 所在文件夹的路径。\n\n使用 `dockerfile` 指令指定 `Dockerfile` 文件名。\n\n使用 `arg` 指令指定构建镜像时的变量。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n```\n\n#### `command`\n\n覆盖容器启动后默认执行的命令。\n\n```yaml\ncommand: echo \"hello world\"\n```\n\n#### `container_name`\n\n指定容器名称。默认将会使用 `项目名称_服务名称_序号` 这样的格式。\n\n```yaml\ncontainer_name: docker-web-container\n```\n\n> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。\n\n#### `depends_on`\n\n解决容器的依赖、启动先后的问题。以下例子中会先启动 `redis` `db` 再启动 `web`\n\n```yaml\nversion: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n```\n\n> 注意：`web` 服务不会等待 `redis` `db` 「完全启动」之后才启动。\n\n#### `env_file`\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 `env_file` 中变量的路径会基于模板文件路径。\n\n如果有变量名称与 `environment` 指令冲突，则按照惯例，以后者为准。\n\n```bash\nenv_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n```\n\n环境变量文件中每一行必须符合格式，支持 `#` 开头的注释行。\n\n```bash\n# common.env: Set development environment\nPROG_ENV=development\n```\n\n#### `environment`\n\n设置环境变量。你可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。\n\n```yaml\nenvironment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n```\n\n如果变量名称或者值中用到 `true|false，yes|no` 等表达 [布尔](https://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括\n\n```bash\ny|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n```\n\n#### `healthcheck`\n\n通过命令检查容器是否健康运行。\n\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n```\n\n#### `image`\n\n指定为镜像名称或镜像 ID。如果镜像在本地不存在，`Compose` 将会尝试拉取这个镜像。\n\n```yaml\nimage: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n```\n\n#### `networks`\n\n配置容器连接的网络。\n\n```yaml\nversion: \"3\"\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n```\n\n#### `ports`\n\n暴露端口信息。\n\n使用宿主端口：容器端口 `(HOST:CONTAINER)` 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。\n\n```yaml\nports:\n - \"3000\"\n - \"8000:8000\"\n - \"49100:22\"\n - \"127.0.0.1:8001:8001\"\n```\n\n*注意：当使用 `HOST:CONTAINER` 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 `YAML` 会自动解析 `xx:yy` 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。*\n\n#### `sysctls`\n\n配置容器内核参数。\n\n```yaml\nsysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n```\n\n#### `ulimits`\n\n指定容器的 ulimits 限制值。\n\n例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。\n\n```yaml\n  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n```\n\n#### `volumes`\n\n数据卷所挂载路径设置。可以设置为宿主机路径(`HOST:CONTAINER`)或者数据卷名称(`VOLUME:CONTAINER`)，并且可以设置访问模式 （`HOST:CONTAINER:ro`）。\n\n该指令中路径支持相对路径。\n\n```yaml\nvolumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n```\n\n如果路径为数据卷名称，必须在文件中配置数据卷。\n\n```yaml\nversion: \"3\"\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n```\n\n---\n\n### 12.5 docker-compose 常用命令\n\n##### 1. 命令对象与格式\n\n对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。\n\n执行 `docker-compose [COMMAND] --help` 或者 `docker-compose help [COMMAND]` 可以查看具体某个命令的使用格式。\n\n`docker-compose` 命令的基本的使用格式是\n\n```bash\ndocker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]\n```\n\n##### 2. 命令选项\n\n- `-f, --file FILE` 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。\n- `-p, --project-name NAME` 指定项目名称，默认将使用所在目录名称作为项目名。\n- `--x-networking` 使用 Docker 的可拔插网络后端特性\n- `--x-network-driver DRIVER` 指定网络后端的驱动，默认为 `bridge`\n- `--verbose` 输出更多调试信息。\n- `-v, --version` 打印版本并退出。\n\n##### 3.命令使用说明\n\n##### `up`\n\n格式为 `docker-compose up [options] [SERVICE...]`。\n\n- 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。\n\n- 链接的服务都将会被自动启动，除非已经处于运行状态。\n\n- 可以说，大部分时候都可以直接通过该命令来启动一个项目。\n\n- 默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。\n\n- 当通过 `Ctrl-C` 停止命令时，所有容器将会停止。\n\n- 如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。\n\n- 默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 `volumes-from` 挂载的卷），以保证新启动的服务匹配 `docker-compose.yml` 文件的最新内容\n\n---\n\n##### `down`\n\n- 此命令将会停止 `up` 命令所启动的容器，并移除网络\n\n----\n\n##### `exec`\n\n- 进入指定的容器。\n\n----\n\n##### `ps`\n\n格式为 `docker-compose ps [options] [SERVICE...]`。\n\n列出项目中目前的所有容器。\n\n选项：\n\n- `-q` 只打印容器的 ID 信息。\n\n----\n\n##### `restart`\n\n格式为 `docker-compose restart [options] [SERVICE...]`。\n\n重启项目中的服务。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 指定重启前停止容器的超时（默认为 10 秒）。\n\n----\n\n##### `rm`\n\n格式为 `docker-compose rm [options] [SERVICE...]`。\n\n删除所有（停止状态的）服务容器。推荐先执行 `docker-compose stop` 命令来停止容器。\n\n选项：\n\n- `-f, --force` 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\n- `-v` 删除容器所挂载的数据卷。\n\n---\n\n##### `start`\n\n格式为 `docker-compose start [SERVICE...]`。\n\n启动已经存在的服务容器。\n\n----\n\n##### `stop`\n\n格式为 `docker-compose stop [options] [SERVICE...]`。\n\n停止已经处于运行状态的容器，但不删除它。通过 `docker-compose start` 可以再次启动这些容器。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。\n\n----\n\n##### `top`\n\n查看各个服务容器内运行的进程。\n\n---\n\n##### `unpause`\n\n格式为 `docker-compose unpause [SERVICE...]`。\n\n恢复处于暂停状态中的服务。\n\n------\n\n## 13.docker可视化工具\n\n#### 13.1 安装Portainer\n\n官方安装说明：[https://www.portainer.io/installation/](http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=)\n\n```shell\n[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   \"/portainer\"        5 seconds ago       Up 4 seconds        0.0.0.0:8000->8000/tcp, 0.0.0.0:9000->9000/tcp   portainer\n```\n\n#### 13.2 登录和使用Portainer\n\n> 用浏览器访问：`http://localhost:9000`\n\n![image-20201223231707738](Docker_1.assets/image-20201223231707738.png)\n\n----\n\n', 'Docker_1', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 13:56:23', 1, '2023-02-21 13:56:23', 1);
INSERT INTO `lzh_article` VALUES (1627910505083465730, 'Docker_1', '<h1>Docker</h1>\n<ul>\n<li>\n<p>官方文档地址:https://www.docker.com/get-started</p>\n</li>\n<li>\n<p>中文参考手册:https://docker_practice.gitee.io/zh-cn/</p>\n</li>\n</ul>\n<hr />\n<h2>1.什么是 Docker</h2>\n<h3>1.1 官方定义</h3>\n<ul>\n<li>最新官网首页</li>\n</ul>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202133061281676959071052.png\" alt=\"image-20201220213306128\" /></p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202142109941676959071070.png\" alt=\"image-20201220214210994\" /></p>\n<pre><code class=\"language-markdown\"># 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n</code></pre>\n<h3>1.2 Docker的起源</h3>\n<pre><code class=\"language-markdown\">Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n</code></pre>\n<h2>2.为什么是Docker</h2>\n<ul>\n<li>\n<p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p>\n<p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p>\n<p><strong>优势1:  一致的运行环境,更轻松的迁移</strong></p>\n</li>\n<li>\n<p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p>\n<p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p>\n<p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p>\n</li>\n<li>\n<p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p>\n<p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p>\n<p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p>\n</li>\n</ul>\n<hr />\n<h2>3.Docker和虚拟机区别</h2>\n<blockquote>\n<p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012202224566751676959071091.png\" alt=\"image-20201220222456675\" /></p>\n<p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p>\n<p>|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |</p>\n<hr />\n<h2>4.Docker的安装</h2>\n<h3>4.1 安装docker(centos7.x)</h3>\n<ul>\n<li>\n<p>卸载原始docker</p>\n<pre><code class=\"language-sh\">$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n</code></pre>\n</li>\n<li>\n<p>安装docker依赖</p>\n<pre><code class=\"language-shell\">$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre>\n</li>\n<li>\n<p>设置docker的yum源</p>\n<pre><code class=\"language-bash\">$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n</code></pre>\n</li>\n<li>\n<p>安装最新版的docker</p>\n<pre><code class=\"language-bash\">$ sudo yum install docker-ce docker-ce-cli containerd.io\n</code></pre>\n</li>\n<li>\n<p>指定版本安装docker</p>\n<pre><code class=\"language-bash\">$ yum list docker-ce --showduplicates | sort -r\n$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>关闭docker</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo systemctl stop docker\n</code></pre>\n<ul>\n<li>\n<p>测试docker安装</p>\n<pre><code class=\"language-bash\">$ sudo docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h3>4.2 bash安装(通用所有平台)</h3>\n<ul>\n<li>\n<p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>\n<pre><code class=\"language-bash\">$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n</code></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><code class=\"language-bash\">$ sudo systemctl enable docker\n$ sudo systemctl start docker\n</code></pre>\n</li>\n<li>\n<p>创建docker用户组</p>\n<pre><code class=\"language-bash\">$ sudo groupadd docker\n</code></pre>\n</li>\n<li>\n<p>将当前用户加入docker组</p>\n<pre><code class=\"language-bash\">$ sudo usermod -aG docker $USER\n</code></pre>\n</li>\n<li>\n<p>测试docker安装是否正确</p>\n<pre><code class=\"language-bash\">$ docker run hello-world\n</code></pre>\n</li>\n</ul>\n<h2>5.Docker 的核心架构</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-20200404111908085-02913231676959070708.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>\n<li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>\n<li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>\n<li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>\n<li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li>\n</ul>\n<h2>6. Docker 配置阿里镜像加速服务</h2>\n<h3>6.1 docker 运行流程</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202004041203567841676959070708.png\" alt=\"image-20200404120356784\" /></p>\n<h3>6.2 docker配置阿里云镜像加速</h3>\n<ul>\n<li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li>\n</ul>\n<pre><code class=\"language-shell\">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-\'EOF\'\n{\n  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre>\n<ul>\n<li><code>验证docker的镜像加速是否生效</code></li>\n</ul>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n</code></pre>\n<hr />\n<h2>7.Docker的入门应用</h2>\n<h3>7.1 docker 的第一个程序</h3>\n<blockquote>\n<p>docker  run hello-world</p>\n</blockquote>\n<pre><code class=\"language-shell\">[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>\n<hr />\n<h2>8.常用命令</h2>\n<h3>6.1 辅助命令</h3>\n<pre><code class=\"language-markdown\"># 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n</code></pre>\n<h3>6.2 Images 镜像命令</h3>\n<pre><code class=\"language-markdown\"># 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n</code></pre>\n<h3>6.3 Contrainer 容器命令</h3>\n<pre><code class=\"language-markdown\"># 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签\n</code></pre>\n<hr />\n<h2>7.docker的镜像原理</h2>\n<h3>7.1 镜像是什么？</h3>\n<blockquote>\n<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>\n</blockquote>\n<h3>7.2 为什么一个镜像会那么大？</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202004041429500681676959070708.png\" alt=\"image-20200404142950068\" /></p>\n<p><code>镜像就是花卷</code></p>\n<ul>\n<li>\n<p>UnionFS（联合文件系统）:</p>\n<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p>\n</li>\n</ul>\n<h3>7.3 Docker镜像原理</h3>\n<blockquote>\n<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>\n</blockquote>\n<ul>\n<li>\n<p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>\n</li>\n<li>\n<p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>\n</li>\n<li>\n<p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p>\n</li>\n</ul>\n<p><img src=\"Docker_1.assets/1567585172(1).jpg\" alt=\"\" /></p>\n<h3>7.4 为什么docker镜像要采用这种分层结构呢?</h3>\n<blockquote>\n<p><code>最大的一个好处就是资源共享</code></p>\n</blockquote>\n<ul>\n<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>\n</ul>\n<hr />\n<h2>8.Docker安装常用服务</h2>\n<h3>8.1 安装mysql</h3>\n<pre><code class=\"language-markdown\"># 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &gt; /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;\' &lt; /root/xxx.sql\n</code></pre>\n<h3>8.2 安装Redis服务</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n</code></pre>\n<h3>8.3 安装Nginx</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n</code></pre>\n<hr />\n<h3>8.4 安装Tomcat</h3>\n<pre><code class=\"language-markdown\"># 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n</code></pre>\n<hr />\n<h3>8.5 安装MongoDB数据库</h3>\n<pre><code class=\"language-markdown\"># 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n</code></pre>\n<h3>8.6 安装ElasticSearch</h3>\n<ul>\n<li><code>注意:</code><strong>调高JVM线程数限制数量</strong></li>\n</ul>\n<h4>0.拉取镜像运行elasticsearch</h4>\n<pre><code class=\"language-markdown\"># 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n</code></pre>\n<ul>\n<li>启动出现如下错误</li>\n<li><img src=\"http://1.117.218.230:9000/test/img_image-202006021843217901676959070709.png\" alt=\"image-20200602184321790\" /></li>\n</ul>\n<h4>1. 预先配置</h4>\n<pre><code class=\"language-markdown\"># 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n</code></pre>\n<h4>2.启动EleasticSearch容器</h4>\n<pre><code class=\"language-markdown\"># 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n</code></pre>\n<h4>3.安装IK分词器</h4>\n<pre><code class=\"language-markdown\"># 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	&lt;properties&gt;\n		&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;\n		&lt;!--用户可以在这里配置自己的扩展字典 --&gt;\n		&lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;\n		&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;\n		&lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;\n	&lt;/properties&gt;\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2\n</code></pre>\n<h4>4. 安装Kibana</h4>\n<pre><code class=\"language-markdown\"># 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n</code></pre>\n<hr />\n<h2>10.Docker中出现如下错误解决方案</h2>\n<pre><code class=\"language-powershell\">[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid\n</code></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006021834292861676959070708.png\" alt=\"image-20200602183429286\" /></p>\n<ul>\n<li>注意:<strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></li>\n</ul>\n<pre><code class=\"language-markdown\"># 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n</code></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006021837186231676959070709.png\" alt=\"image-20200602183718623\" /></p>\n<h2>9.Dockerfile</h2>\n<h3>9.1 什么是Dockerfile</h3>\n<p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202004041119080851676959070708.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>\n</ul>\n<h3>9.2 Dockerfile解析过程</h3>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006031812538041676959070709.png\" alt=\"image-20200603181253804\" /></p>\n<h3>9.3 Dockerfile的保留命令</h3>\n<p>官方说明:https://docs.docker.com/engine/reference/builder/</p>\n<p>| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| <strong>FROM</strong>       | <strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code>          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| <strong>RUN</strong>        | <strong>构建镜像时需要运行的指令</strong>                                 |\n| <strong>EXPOSE</strong>     | <strong>当前容器对外暴露出的端口号</strong>                               |\n| <strong>WORKDIR</strong>    | <strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong> |\n| <strong>ENV</strong>        | <strong>用来在构建镜像过程中设置环境变量</strong>                         |\n| <strong>ADD</strong>        | <strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong> |\n| <strong>COPY</strong>       | <strong>类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong> |\n| <strong>VOLUME</strong>     | <strong>容器数据卷，用于数据保存和持久化工作</strong>                     |\n| <strong>CMD</strong>        | <strong>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong> |\n| <strong>ENTRYPOINT</strong> | <strong>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong> |</p>\n<h4>9.3.1 FROM 命令</h4>\n<ul>\n<li>\n<p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">FROM  &lt;image&gt;\nFROM  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest\nFROM  &lt;image&gt;[@&lt;digest&gt;]  使用摘要\n</code></pre>\n</li>\n</ul>\n<h4>9.3.2 MAINTAINER  命令</h4>\n<ul>\n<li>\n<p>镜像维护者的姓名和邮箱地址[废弃]</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">MAINTAINER &lt;name&gt;\n</code></pre>\n</li>\n</ul>\n<h4>9.3.3 RUN 命令</h4>\n<ul>\n<li>\n<p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\nRUN echo hello\n\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)\nRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.4 EXPOSE 命令</h4>\n<ul>\n<li>\n<p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\nEXPOSE 80/udp\n</code></pre>\n</li>\n</ul>\n<h4>9.3.5 CMD 命令</h4>\n<ul>\n<li>\n<p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>\n</li>\n<li>\n<p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)\nCMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)\nCMD command param1 param2 (shell form)\n</code></pre>\n</li>\n</ul>\n<h4>9.3.6 WORKDIR 命令</h4>\n<ul>\n<li>\n<p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">WORKDIR /path/to/workdir\n\nWORKDIR /a\nWORKDIR b\nWORKDIR c\n`注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n</code></pre>\n</li>\n</ul>\n<h4>9.3.7 ENV 命令</h4>\n<ul>\n<li>\n<p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>\n</li>\n<li>\n<p>语法：</p>\n<pre><code class=\"language-dockerfile\">ENV &lt;key&gt; &lt;value&gt;\nENV &lt;key&gt;=&lt;value&gt; ...\n</code></pre>\n</li>\n</ul>\n<h4>9.3.8 ADD 命令</h4>\n<ul>\n<li>\n<p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">ADD hom* /mydir/       通配符添加多个文件\nADD hom?.txt /mydir/   通配符添加\nADD test.txt relativeDir/  可以指定相对路径\nADD test.txt /absoluteDir/ 也可以指定绝对路径\nADD url \n</code></pre>\n</li>\n</ul>\n<h4>9.3.9 COPY 命令</h4>\n<ul>\n<li>\n<p>用来将context目录中指定文件复制到镜像的指定目录中</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">COPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.10 VOLUME 命令</h4>\n<ul>\n<li>\n<p>用来定义容器运行时可以挂在到宿主机的目录</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">VOLUME [&quot;/data&quot;]\n</code></pre>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<ul>\n<li>\n<p>用来指定容器启动时执行命令和CMD类似</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"language-dockerfile\">  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2\n</code></pre>\n<p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。\nCMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p>\n</li>\n</ul>\n<h4>9.3.11 ENTRYPOINT命令</h4>\n<h3>9.4 Dockerfile构建springboot项目部署</h3>\n<h5>1.准备springboot可运行项目</h5>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006051721512661676959070710.png\" alt=\"image-20200605172151266\" /></p>\n<h5>2.将可运行项目放入linux虚拟机中</h5>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006051723403801676959070710.png\" alt=\"image-20200605172340380\" /></p>\n<h5>3.编写Dockerfile</h5>\n<pre><code class=\"language-dockerfile\">FROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]\nCMD [&quot;ems.jar&quot;]\n</code></pre>\n<h5>4.构建镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker build -t ems .\n</code></pre>\n<h5>5.运行镜像</h5>\n<pre><code class=\"language-shell\">[root@localhost ems]# docker run -p 8989:8989 ems\n</code></pre>\n<h5>6.访问项目</h5>\n<pre><code class=\"language-http\">http://10.15.0.8:8989/ems/login.html\n</code></pre>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202006051731416361676959070972.png\" alt=\"image-20200605173141636\" /></p>\n<hr />\n<h2>10.高级网络配置</h2>\n<h3>10.1 说明</h3>\n<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href=\"https://tools.ietf.org/html/rfc1918\">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>\n<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202011251058478961676959070985.png\" alt=\"image-20201125105847896\" /></p>\n<h3>10.2 查看网络信息</h3>\n<pre><code class=\"language-markdown\"># docker network ls\n</code></pre>\n<h3>10.3 创建一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network create -d bridge 网桥名称\n</code></pre>\n<h3>10.4 删除一个网桥</h3>\n<pre><code class=\"language-markdown\"># docker network rm 网桥名称\n</code></pre>\n<h3>10.5 容器之前使用网络通信</h3>\n<pre><code class=\"language-markdown\"># 1.查询当前网络配置\n- docker network ls\n</code></pre>\n<pre><code class=\"language-shell\">NETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n</code></pre>\n<pre><code class=\"language-markdown\"># 2.创建桥接网络\n- docker network create -d bridge info\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n</code></pre>\n<pre><code class=\"language-markdown\"># 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n</code></pre>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002\nc315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001\nb63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n.....\n</code></pre>\n<hr />\n<h2>11.高级数据卷配置</h2>\n<h3>11.1 说明</h3>\n<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>\n<ul>\n<li><code>数据卷</code> 可以在容器之间共享和重用</li>\n<li>对 <code>数据卷</code> 的修改会立马生效</li>\n<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>\n<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>\n</ul>\n<blockquote>\n<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>\n</blockquote>\n<h3>11.2 创建数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume create my-vol\nmy-vol\n</code></pre>\n<h3>11.3 查看数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: {},\n        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n        &quot;Name&quot;: &quot;my-vol&quot;,\n        &quot;Options&quot;: {},\n        &quot;Scope&quot;: &quot;local&quot;\n    }\n]\n</code></pre>\n<h3>11.4 挂载数据卷</h3>\n<pre><code class=\"language-shell\">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				&quot;Mounts&quot;: [\n            {\n                &quot;Type&quot;: &quot;volume&quot;,\n                &quot;Name&quot;: &quot;my-vol&quot;,\n                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,\n                &quot;Driver&quot;: &quot;local&quot;,\n                &quot;Mode&quot;: &quot;z&quot;,\n                &quot;RW&quot;: true,\n                &quot;Propagation&quot;: &quot;&quot;\n            }\n        ],\n</code></pre>\n<h3>11.5 删除数据卷</h3>\n<pre><code class=\"language-shell\">docker volume rm my-vol\n</code></pre>\n<hr />\n<h2>12.Docker Compose</h2>\n<h3>12.1 简介</h3>\n<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>\n<p>其代码目前在 https://github.com/docker/compose 上开源。</p>\n<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>\n<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>\n<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>\n<p><code>Compose</code> 中有两个重要的概念：</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>\n</ul>\n<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>\n<h3>12.2 安装与卸载</h3>\n<h6>1.linux</h6>\n<ul>\n<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>\n</ul>\n<pre><code class=\"language-bash\">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n</code></pre>\n<h6>2.macos、window</h6>\n<ul>\n<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>\n</ul>\n<h6>3.bash命令补全</h6>\n<pre><code class=\"language-shell\">$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose\n</code></pre>\n<h6>4.卸载</h6>\n<ul>\n<li>如果是二进制包方式安装的，删除二进制文件即可。</li>\n</ul>\n<pre><code class=\"language-shell\">$ sudo rm /usr/local/bin/docker-compose\n</code></pre>\n<h6>5.测试安装成功</h6>\n<pre><code class=\"language-shell\">$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n</code></pre>\n<h3>12.3 docker compose使用</h3>\n<pre><code class=\"language-markdown\"># 1.相关概念\n</code></pre>\n<p>首先介绍几个术语。</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>\n</ul>\n<pre><code class=\"language-markdown\"># 2.场景\n</code></pre>\n<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>\n<ul>\n<li>springboot应用</li>\n<li>mysql服务</li>\n<li>redis服务</li>\n<li>elasticsearch服务</li>\n<li>.......</li>\n</ul>\n<pre><code class=\"language-markdown\"># 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n</code></pre>\n<pre><code class=\"language-yml\">version: &quot;3.0&quot;\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - &quot;3306:3306&quot;\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - &quot;6379:6379&quot;\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n</code></pre>\n<pre><code class=\"language-markdown\"># 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n</code></pre>\n<pre><code class=\"language-bash\">[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n</code></pre>\n<hr />\n<h3>12.4 docker-compose 模板文件</h3>\n<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>\n<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      - &quot;/data&quot;\n</code></pre>\n<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>\n<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>\n<p>下面分别介绍各个指令的用法。</p>\n<h4><code>build</code></h4>\n<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n</code></pre>\n<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>\n<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>\n<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>\n<pre><code class=\"language-yaml\">version: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n</code></pre>\n<h4><code>command</code></h4>\n<p>覆盖容器启动后默认执行的命令。</p>\n<pre><code class=\"language-yaml\">command: echo &quot;hello world&quot;\n</code></pre>\n<h4><code>container_name</code></h4>\n<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>\n<pre><code class=\"language-yaml\">container_name: docker-web-container\n</code></pre>\n<blockquote>\n<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>\n</blockquote>\n<h4><code>depends_on</code></h4>\n<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>\n<pre><code class=\"language-yaml\">version: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n</code></pre>\n<blockquote>\n<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>\n</blockquote>\n<h4><code>env_file</code></h4>\n<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>\n<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>\n<pre><code class=\"language-bash\">env_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n</code></pre>\n<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>\n<pre><code class=\"language-bash\"># common.env: Set development environment\nPROG_ENV=development\n</code></pre>\n<h4><code>environment</code></h4>\n<p>设置环境变量。你可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>\n<pre><code class=\"language-yaml\">environment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n</code></pre>\n<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href=\"https://yaml.org/type/bool.html\">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>\n<pre><code class=\"language-bash\">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n</code></pre>\n<h4><code>healthcheck</code></h4>\n<p>通过命令检查容器是否健康运行。</p>\n<pre><code class=\"language-yaml\">healthcheck:\n  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n</code></pre>\n<h4><code>image</code></h4>\n<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>\n<pre><code class=\"language-yaml\">image: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n</code></pre>\n<h4><code>networks</code></h4>\n<p>配置容器连接的网络。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n</code></pre>\n<h4><code>ports</code></h4>\n<p>暴露端口信息。</p>\n<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>\n<pre><code class=\"language-yaml\">ports:\n - &quot;3000&quot;\n - &quot;8000:8000&quot;\n - &quot;49100:22&quot;\n - &quot;127.0.0.1:8001:8001&quot;\n</code></pre>\n<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>\n<h4><code>sysctls</code></h4>\n<p>配置容器内核参数。</p>\n<pre><code class=\"language-yaml\">sysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n</code></pre>\n<h4><code>ulimits</code></h4>\n<p>指定容器的 ulimits 限制值。</p>\n<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>\n<pre><code class=\"language-yaml\">  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n</code></pre>\n<h4><code>volumes</code></h4>\n<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>\n<p>该指令中路径支持相对路径。</p>\n<pre><code class=\"language-yaml\">volumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n</code></pre>\n<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>\n<pre><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n</code></pre>\n<hr />\n<h3>12.5 docker-compose 常用命令</h3>\n<h5>1. 命令对象与格式</h5>\n<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>\n<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>\n<p><code>docker-compose</code> 命令的基本的使用格式是</p>\n<pre><code class=\"language-bash\">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]\n</code></pre>\n<h5>2. 命令选项</h5>\n<ul>\n<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>\n<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>\n<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>\n<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>\n<li><code>--verbose</code> 输出更多调试信息。</li>\n<li><code>-v, --version</code> 打印版本并退出。</li>\n</ul>\n<h5>3.命令使用说明</h5>\n<h5><code>up</code></h5>\n<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>\n<ul>\n<li>\n<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>\n</li>\n<li>\n<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>\n</li>\n<li>\n<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\n</li>\n<li>\n<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>\n</li>\n<li>\n<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>\n</li>\n<li>\n<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>\n</li>\n<li>\n<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>\n</li>\n</ul>\n<hr />\n<h5><code>down</code></h5>\n<ul>\n<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>\n</ul>\n<hr />\n<h5><code>exec</code></h5>\n<ul>\n<li>进入指定的容器。</li>\n</ul>\n<hr />\n<h5><code>ps</code></h5>\n<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>\n<p>列出项目中目前的所有容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-q</code> 只打印容器的 ID 信息。</li>\n</ul>\n<hr />\n<h5><code>restart</code></h5>\n<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>\n<p>重启项目中的服务。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>rm</code></h5>\n<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>\n<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>\n<li><code>-v</code> 删除容器所挂载的数据卷。</li>\n</ul>\n<hr />\n<h5><code>start</code></h5>\n<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>\n<p>启动已经存在的服务容器。</p>\n<hr />\n<h5><code>stop</code></h5>\n<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>\n<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><code>top</code></h5>\n<p>查看各个服务容器内运行的进程。</p>\n<hr />\n<h5><code>unpause</code></h5>\n<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>\n<p>恢复处于暂停状态中的服务。</p>\n<hr />\n<h2>13.docker可视化工具</h2>\n<h4>13.1 安装Portainer</h4>\n<p>官方安装说明：<a href=\"http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=\">https://www.portainer.io/installation/</a></p>\n<pre><code class=\"language-shell\">[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer\n</code></pre>\n<h4>13.2 登录和使用Portainer</h4>\n<blockquote>\n<p>用浏览器访问：<code>http://localhost:9000</code></p>\n</blockquote>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202012232317077381676959071161.png\" alt=\"image-20201223231707738\" /></p>\n<hr />\n', '# Docker\n\n- 官方文档地址:https://www.docker.com/get-started\n\n- 中文参考手册:https://docker_practice.gitee.io/zh-cn/\n\n-----\n\n## 1.什么是 Docker\n\n### 1.1 官方定义\n\n- 最新官网首页\n\n![image-20201220213306128](Docker_1.assets/image-20201220213306128.png)\n\n![image-20201220214210994](Docker_1.assets/image-20201220214210994.png)\n\n```markdown\n# 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n```\n\n### 1.2 Docker的起源\n\n```markdown\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n```\n\n## 2.为什么是Docker\n\n- `在开发的时候，在本机测试环境可以跑，生产环境跑不起来`\n\n  这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。\n\n  **优势1:  一致的运行环境,更轻松的迁移**\n\n  \n\n- `服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了`\n\n  这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。\n\n  **优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源**\n\n  \n\n- `公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器`\n\n  在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。\n  \n  **优势3: 通过镜像复制N多个环境一致容器**\n\n----\n\n## 3.Docker和虚拟机区别\n\n> 关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。\n\n![image-20201220222456675](Docker_1.assets/image-20201220222456675.png)\n\n`比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重`。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存->虚拟物理内存->真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存->真正物理内存。\n\n|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |\n\n---\n\n## 4.Docker的安装\n\n### 4.1 安装docker(centos7.x)\n\n- 卸载原始docker\n\n  ```sh\n  $ sudo yum remove docker \\\n                    docker-client \\\n                    docker-client-latest \\\n                    docker-common \\\n                    docker-latest \\\n                    docker-latest-logrotate \\\n                    docker-logrotate \\\n                    docker-engine\n  ```\n\n- 安装docker依赖\n\n  ```shell\n  $ sudo yum install -y yum-utils \\\n    device-mapper-persistent-data \\\n    lvm2\n  ```\n\n- 设置docker的yum源\n\n  ```bash\n  $ sudo yum-config-manager \\\n      --add-repo \\\n      https://download.docker.com/linux/centos/docker-ce.repo\n  ```\n\n- 安装最新版的docker\n\n  ```bash\n  $ sudo yum install docker-ce docker-ce-cli containerd.io\n  ```\n\n- 指定版本安装docker\n\n  ```bash\n  $ yum list docker-ce --showduplicates | sort -r\n  $ sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\n  $ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n-  关闭docker\n\n  ```bash\n  $ sudo systemctl stop docker\n  ```\n\n- 测试docker安装\n\n  ```bash\n  $ sudo docker run hello-world\n  ```\n\n### 4.2 bash安装(通用所有平台)\n\n- 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\n\n  ```bash\n  $ curl -fsSL get.docker.com -o get-docker.sh\n  $ sudo sh get-docker.sh --mirror Aliyun\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n- 创建docker用户组\n\n  ```bash\n  $ sudo groupadd docker\n  ```\n\n- 将当前用户加入docker组\n\n  ```bash\n  $ sudo usermod -aG docker $USER\n  ```\n\n- 测试docker安装是否正确\n\n  ```bash\n  $ docker run hello-world\n  ```\n\n## 5.Docker 的核心架构\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085-0291323.png)\n\n- `镜像:` 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等\n- `容器:` 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写\n- `仓库:`用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置\n- `dockerFile:`docker生成镜像配置文件,用来书写自定义镜像的一些配置\n- `tar:`一个对镜像打包的文件,日后可以还原成镜像\n\n## 6. Docker 配置阿里镜像加速服务\n\n### 6.1 docker 运行流程\n\n![image-20200404120356784](Docker_1.assets/image-20200404120356784.png)\n\n### 6.2 docker配置阿里云镜像加速\n\n- `访问阿里云登录自己账号查看docker镜像加速服务`\n\n```shell\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  \"registry-mirrors\": [\"https://lz2nib3q.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n- `验证docker的镜像加速是否生效`\n\n```shell\n[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n```\n\n-----\n\n## 7.Docker的入门应用\n\n### 7.1 docker 的第一个程序\n\n> docker  run hello-world\n\n```shell\n[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n\n----\n\n## 8.常用命令\n\n### 6.1 辅助命令\n\n~~~markdown\n# 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n~~~\n\n### 6.2 Images 镜像命令\n\n~~~markdown\n# 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n~~~\n\n### 6.3 Contrainer 容器命令\n\n~~~markdown\n# 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m \"描述信息\" -a \"作者信息\"   （容器id或者名称）打包的镜像名称:标签\n~~~\n\n----\n\n## 7.docker的镜像原理\n\n### 7.1 镜像是什么？\n\n> 镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。\n\n### 7.2 为什么一个镜像会那么大？\n\n![image-20200404142950068](Docker_1.assets/image-20200404142950068.png)\n\n`镜像就是花卷`\n\n- UnionFS（联合文件系统）:\n\n  Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。	\n\n### 7.3 Docker镜像原理\n\n> `docker的镜像实际是由一层一层的文件系统组成。`\n\n- bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。\n\n- rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。\n\n- 我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。\n\n\n\n![](Docker_1.assets/1567585172(1).jpg)\n\n### 7.4 为什么docker镜像要采用这种分层结构呢?\n\n> `最大的一个好处就是资源共享`\n\n- 比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。\n\n---\n\n## 8.Docker安装常用服务\n\n### 8.1 安装mysql\n\n```markdown\n# 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' < /root/xxx.sql\n```\n\n### 8.2 安装Redis服务\n\n```markdown\n# 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n```\n\n### 8.3 安装Nginx\n\n```markdown\n# 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n```\n\n----\n\n### 8.4 安装Tomcat\n\n```markdown\n# 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n```\n\n-----\n\n### 8.5 安装MongoDB数据库\n\n```markdown\n# 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:\"root\",pwd:\"root\",roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n```\n\n### 8.6 安装ElasticSearch\n\n- `注意:`**调高JVM线程数限制数量**\n\n#### 0.拉取镜像运行elasticsearch\n\n```markdown\n# 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n```\n\n- 启动出现如下错误\n- ![image-20200602184321790](Docker_1.assets/image-20200602184321790.png)\n\n#### 1. 预先配置\n\n```markdown\n# 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n```\n\n#### 2.启动EleasticSearch容器\n\n```markdown\n# 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=\"-Xms128m -Xmx128m\" -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n```\n\n#### 3.安装IK分词器\n\n```markdown\n# 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	<properties>\n		<comment>IK Analyzer 扩展配置</comment>\n		<!--用户可以在这里配置自己的扩展字典 -->\n		<entry key=\"ext_dict\">ext_dict.dic</entry>\n		<!--用户可以在这里配置自己的扩展停止词字典-->\n		<entry key=\"ext_stopwords\">ext_stopwords.dic</entry>\n	</properties>\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=\"xiaochen\" -m=\"es with IKAnalyzer\" 容器id xiaochen/elasticsearch:6.4.2\n```\n\n#### 4. 安装Kibana\n\n```markdown\n# 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n```\n\n----\n\n## 10.Docker中出现如下错误解决方案\n\n```powershell\n[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&n=25: x509: certificate has expired or is not yet valid\n```\n\n![image-20200602183429286](Docker_1.assets/image-20200602183429286.png)\n\n- 注意:**这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步**\n\n```markdown\n# 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n```\n\n![image-20200602183718623](Docker_1.assets/image-20200602183718623.png)\n\n## 9.Dockerfile\n\n### 9.1 什么是Dockerfile\n\nDockerfile可以认为是**Docker镜像的描述文件，是由一系列命令和参数构成的脚本**。主要作用是**用来构建docker镜像的构建文件**。\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085.png)\n\n- **通过架构图可以看出通过DockerFile可以直接构建镜像**\n\n### 9.2 Dockerfile解析过程\n\n![image-20200603181253804](Docker_1.assets/image-20200603181253804.png)\n\n### 9.3 Dockerfile的保留命令\n\n官方说明:https://docs.docker.com/engine/reference/builder/\n\n| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| **FROM**       | **当前镜像是基于哪个镜像的** `第一个指令必须是FROM`          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| **RUN**        | **构建镜像时需要运行的指令**                                 |\n| **EXPOSE**     | **当前容器对外暴露出的端口号**                               |\n| **WORKDIR**    | **指定在创建容器后，终端默认登录进来的工作目录，一个落脚点** |\n| **ENV**        | **用来在构建镜像过程中设置环境变量**                         |\n| **ADD**        | **将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包** |\n| **COPY**       | **类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置** |\n| **VOLUME**     | **容器数据卷，用于数据保存和持久化工作**                     |\n| **CMD**        | **指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换** |\n| **ENTRYPOINT** | **指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数** |\n\n#### 9.3.1 FROM 命令\n\n- 基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现\n\n- 语法:\n\n  ```dockerfile\n  FROM  <image>\n  FROM  <image>[:<tag>]     使用版本不写为latest\n  FROM  <image>[@<digest>]  使用摘要\n  ```\n\n#### 9.3.2 MAINTAINER  命令\n\n- 镜像维护者的姓名和邮箱地址[废弃]\n\n- 语法:\n\n  ```dockerfile\n  MAINTAINER <name>\n  ```\n\n#### 9.3.3 RUN 命令\n\n- RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步\n\n- 语法:\n\n  ```dockerfile\n  RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\n  RUN echo hello\n  \n  RUN [\"executable\", \"param1\", \"param2\"] (exec form)\n  RUN [\"/bin/bash\", \"-c\", \"echo hello\"]\n  ```\n\n#### 9.3.4 EXPOSE 命令\n\n- 用来指定构建的镜像在运行为容器时对外暴露的端口\n\n- 语法:\n\n  ```dockerfile\n  EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\n  EXPOSE 80/udp\n  ```\n\n#### 9.3.5 CMD 命令\n\n- 用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n- 注意: **Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。**\n\n- 语法:\n\n  ```dockerfile\n  CMD [\"executable\",\"param1\",\"param2\"] (exec form, this is the preferred form)\n  CMD [\"param1\",\"param2\"] (as default parameters to ENTRYPOINT)\n  CMD command param1 param2 (shell form)\n  ```\n\n#### 9.3.6 WORKDIR 命令\n\n- 用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。\n\n- 语法:\n\n  ```dockerfile\n  WORKDIR /path/to/workdir\n  \n  WORKDIR /a\n  WORKDIR b\n  WORKDIR c\n  `注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n  ```\n\n#### 9.3.7 ENV 命令\n\n- 用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。\n\n- 语法：\n\n  ```dockerfile\n  ENV <key> <value>\n  ENV <key>=<value> ...\n  ```\n\n#### 9.3.8 ADD 命令\n\n- 用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。\n\n- 语法:\n\n  ```dockerfile\n  ADD hom* /mydir/       通配符添加多个文件\n  ADD hom?.txt /mydir/   通配符添加\n  ADD test.txt relativeDir/  可以指定相对路径\n  ADD test.txt /absoluteDir/ 也可以指定绝对路径\n  ADD url \n  ```\n\n#### 9.3.9 COPY 命令\n\n- 用来将context目录中指定文件复制到镜像的指定目录中\n\n- 语法:\n\n  ```dockerfile\n  COPY src dest\n  COPY [\"<src>\",... \"<dest>\"]\n  ```\n\n#### 9.3.10 VOLUME 命令\n\n- 用来定义容器运行时可以挂在到宿主机的目录\n\n- 语法:\n\n  ```dockerfile\n  VOLUME [\"/data\"]\n  ```\n\n#### 9.3.11 ENTRYPOINT命令\n\n- 用来指定容器启动时执行命令和CMD类似\n\n- 语法:\n\n  ```dockerfile\n    [\"executable\", \"param1\", \"param2\"]\n  ENTRYPOINT command param1 param2\n  ```\n\n  ENTRYPOINT指令，往往用于设置容器启动后的**第一个命令**，这对一个容器来说往往是固定的。\n  CMD指令，往往用于设置容器启动的第一个命令的**默认参数**，这对一个容器来说可以是变化的。\n\n#### 9.3.11 ENTRYPOINT命令\n\n### 9.4 Dockerfile构建springboot项目部署\n\n##### 1.准备springboot可运行项目\n\n![image-20200605172151266](Docker_1.assets/image-20200605172151266.png)\n\n##### 2.将可运行项目放入linux虚拟机中\n\n![image-20200605172340380](Docker_1.assets/image-20200605172340380.png)\n\n##### 3.编写Dockerfile\n\n```dockerfile\nFROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [\"java\",\"-jar\"]\nCMD [\"ems.jar\"]\n```\n\n##### 4.构建镜像\n\n```shell\n[root@localhost ems]# docker build -t ems .\n```\n\n##### 5.运行镜像\n\n```shell\n[root@localhost ems]# docker run -p 8989:8989 ems\n```\n\n##### 6.访问项目\n\n```http\nhttp://10.15.0.8:8989/ems/login.html\n```\n\n![image-20200605173141636](Docker_1.assets/image-20200605173141636.png)\n\n---\n\n## 10.高级网络配置\n\n### 10.1 说明\n\n当 Docker 启动时，会自动在主机上创建一个 `docker0` 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n同时，Docker 随机分配一个本地未占用的私有网段（在 [RFC1918](https://tools.ietf.org/html/rfc1918) 中定义）中的一个地址给 `docker0` 接口。比如典型的 `172.17.42.1`，掩码为 `255.255.0.0`。此后启动的容器内的网口也会自动分配一个同一网段（`172.17.0.0/16`）的地址。\n\n当创建一个 Docker 容器的时候，同时会创建了一对 `veth pair` 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 `eth0`；另一端在本地并被挂载到 `docker0` 网桥，名称以 `veth` 开头（例如 `vethAQI2QT`）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。\n\n![image-20201125105847896](Docker_1.assets/image-20201125105847896.png)\n\n### 10.2 查看网络信息\n\n```markdown\n# docker network ls\n```\n\n### 10.3 创建一个网桥\n\n```markdown\n# docker network create -d bridge 网桥名称\n```\n\n### 10.4 删除一个网桥\n\n```markdown\n# docker network rm 网桥名称\n```\n\n### 10.5 容器之前使用网络通信\n\n```markdown\n# 1.查询当前网络配置\n- docker network ls\n```\n\n```shell\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n```\n\n```markdown\n# 2.创建桥接网络\n- docker network create -d bridge info\n```\n\n```shell\n[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n```\n\n```markdown\n# 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n```\n\n```shell\n[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               \"/docker-entrypoint.…\"   3 seconds ago       Up 2 seconds        0.0.0.0:8891->80/tcp   nginx002\nc315bcc94e9d        nginx               \"/docker-entrypoint.…\"   7 minutes ago       Up 7 minutes        0.0.0.0:8890->80/tcp   nginx001\nb63169d43792        mysql:5.7.19        \"docker-entrypoint.s…\"   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n.....\n```\n\n---\n\n## 11.高级数据卷配置\n\n### 11.1 说明\n\n`数据卷` 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：\n\n- `数据卷` 可以在容器之间共享和重用\n- 对 `数据卷` 的修改会立马生效\n- 对 `数据卷` 的更新，不会影响镜像\n- `数据卷` 默认会一直存在，即使容器被删除\n\n> 注意：`数据卷` 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n\n### 11.2 创建数据卷\n\n```shell\n[root@centos ~]# docker volume create my-vol\nmy-vol\n```\n\n### 11.3 查看数据卷\n\n```shell\n[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        \"CreatedAt\": \"2020-11-25T11:43:56+08:00\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\",\n        \"Name\": \"my-vol\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n```\n\n### 11.4 挂载数据卷\n\n```shell\n[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				\"Mounts\": [\n            {\n                \"Type\": \"volume\",\n                \"Name\": \"my-vol\",\n                \"Source\": \"/var/lib/docker/volumes/my-vol/_data\",\n                \"Destination\": \"/usr/share/nginx/html\",\n                \"Driver\": \"local\",\n                \"Mode\": \"z\",\n                \"RW\": true,\n                \"Propagation\": \"\"\n            }\n        ],\n```\n\n### 11.5 删除数据卷\n\n```shell\ndocker volume rm my-vol\n```\n\n---\n\n## 12.Docker Compose\n\n### 12.1 简介\n\n`Compose` 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 `OpenStack` 中的 `Heat` 十分类似。\n\n其代码目前在 https://github.com/docker/compose 上开源。\n\n`Compose` 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。\n\n通过第一部分中的介绍，我们知道使用一个 `Dockerfile` 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。\n\n`Compose` 恰好满足了这样的需求。它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\n\n`Compose` 中有两个重要的概念：\n\n- 服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。\n\n`Compose` 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n`Compose` 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 `Compose` 来进行编排管理。\n\n### 12.2 安装与卸载\n\n###### 1.linux\n\n- 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。\n\n```bash\n$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n```\n\n###### 2.macos、window\n\n- Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。`Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用`。\n\n###### 3.bash命令补全\n\n```shell\n$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose\n```\n\n###### 4.卸载\n\n- 如果是二进制包方式安装的，删除二进制文件即可。\n\n```shell\n$ sudo rm /usr/local/bin/docker-compose\n```\n\n###### 5.测试安装成功\n\n```shell\n$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n```\n\n### 12.3 docker compose使用\n\n```markdown\n# 1.相关概念\n```\n\n首先介绍几个术语。\n\n- 服务 (`service`)：一个应用容器，实际上可以运行多个相同镜像的实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，`Compose` 面向项目进行管理。\n\n```markdown\n# 2.场景\n```\n\n最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。\n\n- springboot应用\n- mysql服务\n- redis服务\n- elasticsearch服务\n- .......\n\n````markdown\n# 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n````\n\n```yml\nversion: \"3.0\"\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - \"6379:6379\"\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n```\n\n```markdown\n# 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n```\n\n```bash\n[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n```\n\n---\n\n### 12.4 docker-compose 模板文件\n\n模板文件是使用 `Compose` 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 `docker run` 相关参数的含义都是类似的。\n\n默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式。\n\n```yaml\nversion: \"3\"\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - \"80:80\"\n    volumes:\n      - \"/data\"\n```\n\n注意每个服务都必须通过 `image` 指令指定镜像或 `build` 指令（需要 Dockerfile）等来自动构建生成镜像。\n\n如果使用 `build` 指令，在 `Dockerfile` 中设置的选项(例如：`CMD`, `EXPOSE`, `VOLUME`, `ENV` 等) 将会自动被获取，无需在 `docker-compose.yml` 中重复设置。\n\n下面分别介绍各个指令的用法。\n\n#### `build`\n\n指定 `Dockerfile` 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 `Compose` 将会利用它自动构建这个镜像，然后使用这个镜像。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n```\n\n你也可以使用 `context` 指令指定 `Dockerfile` 所在文件夹的路径。\n\n使用 `dockerfile` 指令指定 `Dockerfile` 文件名。\n\n使用 `arg` 指令指定构建镜像时的变量。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n```\n\n#### `command`\n\n覆盖容器启动后默认执行的命令。\n\n```yaml\ncommand: echo \"hello world\"\n```\n\n#### `container_name`\n\n指定容器名称。默认将会使用 `项目名称_服务名称_序号` 这样的格式。\n\n```yaml\ncontainer_name: docker-web-container\n```\n\n> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。\n\n#### `depends_on`\n\n解决容器的依赖、启动先后的问题。以下例子中会先启动 `redis` `db` 再启动 `web`\n\n```yaml\nversion: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n```\n\n> 注意：`web` 服务不会等待 `redis` `db` 「完全启动」之后才启动。\n\n#### `env_file`\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 `env_file` 中变量的路径会基于模板文件路径。\n\n如果有变量名称与 `environment` 指令冲突，则按照惯例，以后者为准。\n\n```bash\nenv_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n```\n\n环境变量文件中每一行必须符合格式，支持 `#` 开头的注释行。\n\n```bash\n# common.env: Set development environment\nPROG_ENV=development\n```\n\n#### `environment`\n\n设置环境变量。你可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。\n\n```yaml\nenvironment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n```\n\n如果变量名称或者值中用到 `true|false，yes|no` 等表达 [布尔](https://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括\n\n```bash\ny|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n```\n\n#### `healthcheck`\n\n通过命令检查容器是否健康运行。\n\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n```\n\n#### `image`\n\n指定为镜像名称或镜像 ID。如果镜像在本地不存在，`Compose` 将会尝试拉取这个镜像。\n\n```yaml\nimage: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n```\n\n#### `networks`\n\n配置容器连接的网络。\n\n```yaml\nversion: \"3\"\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n```\n\n#### `ports`\n\n暴露端口信息。\n\n使用宿主端口：容器端口 `(HOST:CONTAINER)` 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。\n\n```yaml\nports:\n - \"3000\"\n - \"8000:8000\"\n - \"49100:22\"\n - \"127.0.0.1:8001:8001\"\n```\n\n*注意：当使用 `HOST:CONTAINER` 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 `YAML` 会自动解析 `xx:yy` 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。*\n\n#### `sysctls`\n\n配置容器内核参数。\n\n```yaml\nsysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n```\n\n#### `ulimits`\n\n指定容器的 ulimits 限制值。\n\n例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。\n\n```yaml\n  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n```\n\n#### `volumes`\n\n数据卷所挂载路径设置。可以设置为宿主机路径(`HOST:CONTAINER`)或者数据卷名称(`VOLUME:CONTAINER`)，并且可以设置访问模式 （`HOST:CONTAINER:ro`）。\n\n该指令中路径支持相对路径。\n\n```yaml\nvolumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n```\n\n如果路径为数据卷名称，必须在文件中配置数据卷。\n\n```yaml\nversion: \"3\"\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n```\n\n---\n\n### 12.5 docker-compose 常用命令\n\n##### 1. 命令对象与格式\n\n对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。\n\n执行 `docker-compose [COMMAND] --help` 或者 `docker-compose help [COMMAND]` 可以查看具体某个命令的使用格式。\n\n`docker-compose` 命令的基本的使用格式是\n\n```bash\ndocker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]\n```\n\n##### 2. 命令选项\n\n- `-f, --file FILE` 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。\n- `-p, --project-name NAME` 指定项目名称，默认将使用所在目录名称作为项目名。\n- `--x-networking` 使用 Docker 的可拔插网络后端特性\n- `--x-network-driver DRIVER` 指定网络后端的驱动，默认为 `bridge`\n- `--verbose` 输出更多调试信息。\n- `-v, --version` 打印版本并退出。\n\n##### 3.命令使用说明\n\n##### `up`\n\n格式为 `docker-compose up [options] [SERVICE...]`。\n\n- 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。\n\n- 链接的服务都将会被自动启动，除非已经处于运行状态。\n\n- 可以说，大部分时候都可以直接通过该命令来启动一个项目。\n\n- 默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。\n\n- 当通过 `Ctrl-C` 停止命令时，所有容器将会停止。\n\n- 如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。\n\n- 默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 `volumes-from` 挂载的卷），以保证新启动的服务匹配 `docker-compose.yml` 文件的最新内容\n\n---\n\n##### `down`\n\n- 此命令将会停止 `up` 命令所启动的容器，并移除网络\n\n----\n\n##### `exec`\n\n- 进入指定的容器。\n\n----\n\n##### `ps`\n\n格式为 `docker-compose ps [options] [SERVICE...]`。\n\n列出项目中目前的所有容器。\n\n选项：\n\n- `-q` 只打印容器的 ID 信息。\n\n----\n\n##### `restart`\n\n格式为 `docker-compose restart [options] [SERVICE...]`。\n\n重启项目中的服务。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 指定重启前停止容器的超时（默认为 10 秒）。\n\n----\n\n##### `rm`\n\n格式为 `docker-compose rm [options] [SERVICE...]`。\n\n删除所有（停止状态的）服务容器。推荐先执行 `docker-compose stop` 命令来停止容器。\n\n选项：\n\n- `-f, --force` 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\n- `-v` 删除容器所挂载的数据卷。\n\n---\n\n##### `start`\n\n格式为 `docker-compose start [SERVICE...]`。\n\n启动已经存在的服务容器。\n\n----\n\n##### `stop`\n\n格式为 `docker-compose stop [options] [SERVICE...]`。\n\n停止已经处于运行状态的容器，但不删除它。通过 `docker-compose start` 可以再次启动这些容器。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。\n\n----\n\n##### `top`\n\n查看各个服务容器内运行的进程。\n\n---\n\n##### `unpause`\n\n格式为 `docker-compose unpause [SERVICE...]`。\n\n恢复处于暂停状态中的服务。\n\n------\n\n## 13.docker可视化工具\n\n#### 13.1 安装Portainer\n\n官方安装说明：[https://www.portainer.io/installation/](http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=)\n\n```shell\n[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   \"/portainer\"        5 seconds ago       Up 4 seconds        0.0.0.0:8000->8000/tcp, 0.0.0.0:9000->9000/tcp   portainer\n```\n\n#### 13.2 登录和使用Portainer\n\n> 用浏览器访问：`http://localhost:9000`\n\n![image-20201223231707738](Docker_1.assets/image-20201223231707738.png)\n\n----\n\n', 'Docker_1', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 13:58:04', 1, '2023-02-21 13:58:04', 0);
INSERT INTO `lzh_article` VALUES (1627910571122782210, 'Docker_1', '<h1><a id=\"Docker_0\"></a>Docker</h1>\n<ul>\n<li>\n<p>官方文档地址:https://www.docker.com/get-started</p>\n</li>\n<li>\n<p>中文参考手册:https://docker_practice.gitee.io/zh-cn/</p>\n</li>\n</ul>\n<hr />\n<h2><a id=\"1_Docker_8\"></a>1.什么是 Docker</h2>\n<h3><a id=\"11__10\"></a>1.1 官方定义</h3>\n<ul>\n<li>最新官网首页</li>\n</ul>\n<p><img src=\"Docker_1.assets/image-20201220213306128.png\" alt=\"image-20201220213306128\" /></p>\n<p><img src=\"Docker_1.assets/image-20201220214210994.png\" alt=\"image-20201220214210994\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.官方介绍</span>\n<span class=\"hljs-bullet\">-</span> We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n<span class=\"hljs-bullet\">-</span> 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n<span class=\"hljs-bullet\">-</span> 官方定义: docker是一个容器技术。\n</code></div></pre>\n<h3><a id=\"12_Docker_25\"></a>1.2 Docker的起源</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\">Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n</code></div></pre>\n<h2><a id=\"2Docker_35\"></a>2.为什么是Docker</h2>\n<ul>\n<li>\n<p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p>\n<p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p>\n<p><strong>优势1:  一致的运行环境,更轻松的迁移</strong></p>\n</li>\n<li>\n<p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p>\n<p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p>\n<p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p>\n</li>\n<li>\n<p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p>\n<p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p>\n<p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p>\n</li>\n</ul>\n<hr />\n<h2><a id=\"3Docker_61\"></a>3.Docker和虚拟机区别</h2>\n<blockquote>\n<p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p>\n</blockquote>\n<p><img src=\"Docker_1.assets/image-20201220222456675.png\" alt=\"image-20201220222456675\" /></p>\n<p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>传统虚拟机</th>\n<th>Docker容器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>磁盘占用</td>\n<td>几个GB到几十个GB左右</td>\n<td>几十MB到几百MB左右</td>\n</tr>\n<tr>\n<td>CPU内存占用</td>\n<td>虚拟操作系统非常占用CPU和内存</td>\n<td>Docker引擎占用极低</td>\n</tr>\n<tr>\n<td>启动速度</td>\n<td>（从开机到运行项目）几分钟</td>\n<td>（从开启容器到运行项目）几秒</td>\n</tr>\n<tr>\n<td>安装管理</td>\n<td>需要专门的运维技术</td>\n<td>安装、管理方便</td>\n</tr>\n<tr>\n<td>应用部署</td>\n<td>每次部署都费时费力</td>\n<td>从第二次部署开始轻松简捷</td>\n</tr>\n<tr>\n<td>耦合性</td>\n<td>多个应用服务安装到一起，容易互相影响</td>\n<td>每个应用服务一个容器，达成隔离</td>\n</tr>\n<tr>\n<td>系统依赖</td>\n<td>无</td>\n<td>需求相同或相似的内核，目前推荐是Linux</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2><a id=\"4Docker_81\"></a>4.Docker的安装</h2>\n<h3><a id=\"41_dockercentos7x_83\"></a>4.1 安装docker(centos7.x)</h3>\n<ul>\n<li>\n<p>卸载原始docker</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n</code></div></pre>\n</li>\n<li>\n<p>安装docker依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2</span>\n</code></div></pre>\n</li>\n<li>\n<p>设置docker的yum源</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n</code></div></pre>\n</li>\n<li>\n<p>安装最新版的docker</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ sudo yum install docker-ce docker-ce-cli containerd.io\n</code></div></pre>\n</li>\n<li>\n<p>指定版本安装docker</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ yum list docker-ce --showduplicates | <span class=\"hljs-built_in\">sort</span> -r\n$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n</code></div></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ sudo systemctl <span class=\"hljs-built_in\">enable</span> docker\n$ sudo systemctl start docker\n</code></div></pre>\n</li>\n<li>\n<p>关闭docker</p>\n</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ sudo systemctl stop docker\n</code></div></pre>\n<ul>\n<li>\n<p>测试docker安装</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ sudo docker run hello-world\n</code></div></pre>\n</li>\n</ul>\n<h3><a id=\"42_bash_147\"></a>4.2 bash安装(通用所有平台)</h3>\n<ul>\n<li>\n<p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n</code></div></pre>\n</li>\n<li>\n<p>启动docker</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ sudo systemctl <span class=\"hljs-built_in\">enable</span> docker\n$ sudo systemctl start docker\n</code></div></pre>\n</li>\n<li>\n<p>创建docker用户组</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ sudo groupadd docker\n</code></div></pre>\n</li>\n<li>\n<p>将当前用户加入docker组</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ sudo usermod -aG docker <span class=\"hljs-variable\">$USER</span>\n</code></div></pre>\n</li>\n<li>\n<p>测试docker安装是否正确</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ docker run hello-world\n</code></div></pre>\n</li>\n</ul>\n<h2><a id=\"5Docker__181\"></a>5.Docker 的核心架构</h2>\n<p><img src=\"Docker_1.assets/image-20200404111908085-0291323.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>\n<li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>\n<li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>\n<li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>\n<li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li>\n</ul>\n<h2><a id=\"6_Docker__191\"></a>6. Docker 配置阿里镜像加速服务</h2>\n<h3><a id=\"61_docker__193\"></a>6.1 docker 运行流程</h3>\n<p><img src=\"Docker_1.assets/image-20200404120356784.png\" alt=\"image-20200404120356784\" /></p>\n<h3><a id=\"62_docker_197\"></a>6.2 docker配置阿里云镜像加速</h3>\n<ul>\n<li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;\n{\n  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></div></pre>\n<ul>\n<li><code>验证docker的镜像加速是否生效</code></li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    &#x27;https://lz2nib3q.mirror.aliyuncs.com/&#x27;\n   Live Restore Enabled: false\n   Product License: Community Engine\n</code></div></pre>\n<hr />\n<h2><a id=\"7Docker_226\"></a>7.Docker的入门应用</h2>\n<h3><a id=\"71_docker__228\"></a>7.1 docker 的第一个程序</h3>\n<blockquote>\n<p>docker  run hello-world</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n<span class=\"hljs-meta\"> $ </span><span class=\"language-bash\">docker run -it ubuntu bash</span>\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></div></pre>\n<hr />\n<h2><a id=\"8_259\"></a>8.常用命令</h2>\n<h3><a id=\"61__261\"></a>6.1 辅助命令</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.安装完成辅助命令</span>\n<span class=\"hljs-code\">		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n</span></code></div></pre>\n<h3><a id=\"62_Images__270\"></a>6.2 Images 镜像命令</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.查看本机中所有镜像</span>\n<span class=\"hljs-code\">	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n</span>\n<span class=\"hljs-section\"># 2.搜索镜像</span>\n<span class=\"hljs-code\">	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n</span>\n<span class=\"hljs-section\"># 3.从仓库下载镜像</span>\n<span class=\"hljs-code\">	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n</span>\n<span class=\"hljs-section\"># 4.删除镜像</span>\n<span class=\"hljs-code\">	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n</span></code></div></pre>\n<h3><a id=\"63_Contrainer__291\"></a>6.3 Contrainer 容器命令</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.运行容器</span>\n<span class=\"hljs-code\">	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n</span>\n<span class=\"hljs-code\">	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n</span>\n<span class=\"hljs-section\"># 2.查看运行的容器</span>\n<span class=\"hljs-code\">	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n</span>\n<span class=\"hljs-section\"># 3.停止|关闭|重启容器</span>\n<span class=\"hljs-code\">	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n</span>\n<span class=\"hljs-section\"># 4.删除容器</span>\n<span class=\"hljs-code\">	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n</span>\n<span class=\"hljs-section\"># 5.查看容器内进程</span>\n<span class=\"hljs-code\">	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n</span>\n<span class=\"hljs-section\"># 6.查看查看容器内部细节</span>\n<span class=\"hljs-code\">	docker inspect 容器id 		------------------ 查看容器内部细节\n</span>\n<span class=\"hljs-section\"># 7.查看容器的运行日志</span>\n<span class=\"hljs-code\">	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n</span>\n<span class=\"hljs-section\"># 8.进入容器内部</span>\n<span class=\"hljs-code\">	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n</span>\n<span class=\"hljs-section\"># 9.容器和宿主机之间复制文件</span>\n<span class=\"hljs-code\">	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n</span>\n<span class=\"hljs-section\"># 10.数据卷(volum)实现与宿主机共享目录</span>\n<span class=\"hljs-code\">	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n</span>\n<span class=\"hljs-section\"># 11.打包镜像</span>\n<span class=\"hljs-code\">		docker save 镜像名 -o  名称.tar\n</span>\n<span class=\"hljs-section\"># 12.载入镜像</span>\n<span class=\"hljs-code\">		docker load -i   名称.tar\n</span>\n<span class=\"hljs-section\"># 13.容器打包成新的镜像</span>\n<span class=\"hljs-code\">	  docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签\n</span></code></div></pre>\n<hr />\n<h2><a id=\"7docker_357\"></a>7.docker的镜像原理</h2>\n<h3><a id=\"71__359\"></a>7.1 镜像是什么？</h3>\n<blockquote>\n<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>\n</blockquote>\n<h3><a id=\"72__363\"></a>7.2 为什么一个镜像会那么大？</h3>\n<p><img src=\"Docker_1.assets/image-20200404142950068.png\" alt=\"image-20200404142950068\" /></p>\n<p><code>镜像就是花卷</code></p>\n<ul>\n<li>\n<p>UnionFS（联合文件系统）:</p>\n<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p>\n</li>\n</ul>\n<h3><a id=\"73_Docker_373\"></a>7.3 Docker镜像原理</h3>\n<blockquote>\n<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>\n</blockquote>\n<ul>\n<li>\n<p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>\n</li>\n<li>\n<p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>\n</li>\n<li>\n<p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p>\n</li>\n</ul>\n<p><img src=\"Docker_1.assets/1567585172(1).jpg\" alt=\"\" /></p>\n<h3><a id=\"74_docker_387\"></a>7.4 为什么docker镜像要采用这种分层结构呢?</h3>\n<blockquote>\n<p><code>最大的一个好处就是资源共享</code></p>\n</blockquote>\n<ul>\n<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>\n</ul>\n<hr />\n<h2><a id=\"8Docker_395\"></a>8.Docker安装常用服务</h2>\n<h3><a id=\"81_mysql_397\"></a>8.1 安装mysql</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.拉取mysql镜像到本地</span>\n<span class=\"hljs-code\">	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n</span>\n<span class=\"hljs-section\"># 3.进入mysql容器</span>\n<span class=\"hljs-code\">	docker exec -it 容器名称|容器id bash\n</span>\n<span class=\"hljs-section\"># 4.外部查看mysql日志</span>\n<span class=\"hljs-code\">	docker logs 容器名称|容器id\n</span>\n<span class=\"hljs-section\"># 5.使用自定义配置参数</span>\n<span class=\"hljs-code\">	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n</span>\n<span class=\"hljs-section\"># 6.将容器数据位置与宿主机位置挂载保证数据安全</span>\n<span class=\"hljs-code\">	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n</span>\n<span class=\"hljs-section\"># 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问</span>\n<span class=\"hljs-code\">	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c &#x27;exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c &#x27;exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c &#x27;exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出指定库数据不要数据\n</span>\n<span class=\"hljs-section\"># 9.执行sql文件到mysql中</span>\n<span class=\"hljs-code\">	docker exec -i mysql sh -c &#x27;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &lt; /root/xxx.sql\n</span></code></div></pre>\n<h3><a id=\"82_Redis_430\"></a>8.2 安装Redis服务</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.在docker hub搜索redis镜像</span>\n<span class=\"hljs-code\">	docker search redis\n</span>\n<span class=\"hljs-section\"># 2.拉取redis镜像到本地</span>\n<span class=\"hljs-code\">	docker pull redis\n</span>\n<span class=\"hljs-section\"># 3.启动redis服务运行容器</span>\n<span class=\"hljs-code\">	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n</span>\n<span class=\"hljs-section\"># 4.查看启动日志</span>\n<span class=\"hljs-code\">	docker logs -t -f 容器id|容器名称\n</span>\n<span class=\"hljs-section\"># 5.进入容器内部查看</span>\n<span class=\"hljs-code\">	docker exec -it 容器id|名称 bash  \n</span>\n<span class=\"hljs-section\"># 6.加载外部自定义配置启动redis容器</span>\n<span class=\"hljs-code\">	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n</span>\n<span class=\"hljs-section\"># 7.将数据目录挂在到本地保证数据安全</span>\n<span class=\"hljs-code\">	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n</span></code></div></pre>\n<h3><a id=\"83_Nginx_463\"></a>8.3 安装Nginx</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.在docker hub搜索nginx</span>\n<span class=\"hljs-code\">	docker search nginx\n</span>\n<span class=\"hljs-section\"># 2.拉取nginx镜像到本地</span>\n<span class=\"hljs-code\">	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n</span>\n<span class=\"hljs-section\"># 3.启动nginx容器</span>\n<span class=\"hljs-code\">		docker run -p 80:80 --name nginx01 -d nginx\n</span>\n<span class=\"hljs-section\"># 4.进入容器</span>\n<span class=\"hljs-code\">		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n</span>\n<span class=\"hljs-section\"># 5.复制配置文件到宿主机</span>\n<span class=\"hljs-code\">		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n</span>\n<span class=\"hljs-section\"># 6.挂在nginx配置以及html到宿主机外部</span>\n<span class=\"hljs-code\">		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n</span></code></div></pre>\n<hr />\n<h3><a id=\"84_Tomcat_497\"></a>8.4 安装Tomcat</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.在docker hub搜索tomcat</span>\n<span class=\"hljs-code\">	docker search tomcat\n</span>\n<span class=\"hljs-section\"># 2.下载tomcat镜像</span>\n<span class=\"hljs-code\">	docker pull tomcat\n</span>\n<span class=\"hljs-section\"># 3.运行tomcat镜像</span>\n<span class=\"hljs-code\">	docker run -p 8080:8080 -d --name mytomcat tomcat\n</span>\n<span class=\"hljs-section\"># 4.进入tomcat容器</span>\n<span class=\"hljs-code\">	docker exec -it mytomcat /bin/bash\n</span>\n<span class=\"hljs-section\"># 5.将webapps目录挂载在外部</span>\n<span class=\"hljs-code\">	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n</span>\n</code></div></pre>\n<hr />\n<h3><a id=\"85_MongoDB_519\"></a>8.5 安装MongoDB数据库</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.运行mongDB</span>\n<span class=\"hljs-code\">	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n</span>\n<span class=\"hljs-section\"># 2.进入mongodb容器</span>\n<span class=\"hljs-code\">	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n</span>\n<span class=\"hljs-section\"># 3.常见具有权限的容器</span>\n<span class=\"hljs-code\">	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n</span>\n<span class=\"hljs-section\"># 4.进入容器配置用户名密码</span>\n<span class=\"hljs-code\">	mongo\n	use admin 选择admin库\n	db.createUser({user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[{role:&#x27;root&#x27;,db:&#x27;admin&#x27;}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n</span>\n<span class=\"hljs-section\"># 5.将mongoDB中数据目录映射到宿主机中</span>\n<span class=\"hljs-code\">	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n</span></code></div></pre>\n<h3><a id=\"86_ElasticSearch_543\"></a>8.6 安装ElasticSearch</h3>\n<ul>\n<li><code>注意:</code><strong>调高JVM线程数限制数量</strong></li>\n</ul>\n<h4><a id=\"0elasticsearch_547\"></a>0.拉取镜像运行elasticsearch</h4>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.dockerhub 拉取镜像</span>\n<span class=\"hljs-code\">	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n</span></code></div></pre>\n<ul>\n<li>启动出现如下错误</li>\n<li><img src=\"Docker_1.assets/image-20200602184321790.png\" alt=\"image-20200602184321790\" /></li>\n</ul>\n<h4><a id=\"1__561\"></a>1. 预先配置</h4>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.在centos虚拟机中，修改配置sysctl.conf</span>\n<span class=\"hljs-code\">	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n</span>\n</code></div></pre>\n<h4><a id=\"2EleasticSearch_575\"></a>2.启动EleasticSearch容器</h4>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 0.复制容器中data目录到宿主机中</span>\n<span class=\"hljs-code\">	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n</span></code></div></pre>\n<h4><a id=\"3IK_584\"></a>3.安装IK分词器</h4>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.下载对应版本的IK分词器</span>\n<span class=\"hljs-code\">	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n</span>\n<span class=\"hljs-section\"># 2.解压到plugins文件夹中</span>\n<span class=\"hljs-code\">	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n</span>\n<span class=\"hljs-section\"># 3.添加自定义扩展词和停用词</span>\n<span class=\"hljs-code\">	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	&lt;properties&gt;\n		&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;\n		&lt;!--用户可以在这里配置自己的扩展字典 --&gt;\n		&lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;\n		&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;\n		&lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;\n	&lt;/properties&gt;\n</span>\n<span class=\"hljs-section\"># 4.在ik分词器目录下config目录中创建ext<span class=\"hljs-emphasis\">_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_</span>dict.dic 加入扩展词即可</span>\n<span class=\"hljs-section\"># 5. 在ik分词器目录下config目录中创建ext<span class=\"hljs-emphasis\">_stopword.dic文件 \n	vim ext_</span>stopwords.dic 加入停用词即可</span>\n\n<span class=\"hljs-section\"># 6.重启容器生效</span>\n<span class=\"hljs-code\">	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2\n</span></code></div></pre>\n<h4><a id=\"4_Kibana_616\"></a>4. 安装Kibana</h4>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.下载kibana镜像到本地</span>\n<span class=\"hljs-code\">	docker pull kibana:6.4.2\n</span>\n<span class=\"hljs-section\"># 2.启动kibana容器</span>\n<span class=\"hljs-code\">	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n</span></code></div></pre>\n<hr />\n<h2><a id=\"10Docker_628\"></a>10.Docker中出现如下错误解决方案</h2>\n<pre><code class=\"lang-powershell\">[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid\n</code></pre>\n<p><img src=\"Docker_1.assets/image-20200602183429286.png\" alt=\"image-20200602183429286\" /></p>\n<ul>\n<li>注意:<strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.安装时间同步</span>\n<span class=\"hljs-code\">	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n</span></code></div></pre>\n<p><img src=\"Docker_1.assets/image-20200602183718623.png\" alt=\"image-20200602183718623\" /></p>\n<h2><a id=\"9Dockerfile_651\"></a>9.Dockerfile</h2>\n<h3><a id=\"91_Dockerfile_653\"></a>9.1 什么是Dockerfile</h3>\n<p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p>\n<p><img src=\"Docker_1.assets/image-20200404111908085.png\" alt=\"image-20200404111908085\" /></p>\n<ul>\n<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>\n</ul>\n<h3><a id=\"92_Dockerfile_661\"></a>9.2 Dockerfile解析过程</h3>\n<p><img src=\"Docker_1.assets/image-20200603181253804.png\" alt=\"image-20200603181253804\" /></p>\n<h3><a id=\"93_Dockerfile_665\"></a>9.3 Dockerfile的保留命令</h3>\n<p>官方说明:https://docs.docker.com/engine/reference/builder/</p>\n<table>\n<thead>\n<tr>\n<th>保留字</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>FROM</strong></td>\n<td><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td>\n</tr>\n<tr>\n<td>MAINTAINER</td>\n<td>镜像维护者的姓名和邮箱地址</td>\n</tr>\n<tr>\n<td><strong>RUN</strong></td>\n<td><strong>构建镜像时需要运行的指令</strong></td>\n</tr>\n<tr>\n<td><strong>EXPOSE</strong></td>\n<td><strong>当前容器对外暴露出的端口号</strong></td>\n</tr>\n<tr>\n<td><strong>WORKDIR</strong></td>\n<td><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td>\n</tr>\n<tr>\n<td><strong>ENV</strong></td>\n<td><strong>用来在构建镜像过程中设置环境变量</strong></td>\n</tr>\n<tr>\n<td><strong>ADD</strong></td>\n<td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td>\n</tr>\n<tr>\n<td><strong>COPY</strong></td>\n<td><strong>类似于ADD，拷贝文件和目录到镜像中<br />将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td>\n</tr>\n<tr>\n<td><strong>VOLUME</strong></td>\n<td><strong>容器数据卷，用于数据保存和持久化工作</strong></td>\n</tr>\n<tr>\n<td><strong>CMD</strong></td>\n<td><strong>指定一个容器启动时要运行的命令<br />Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td>\n</tr>\n<tr>\n<td><strong>ENTRYPOINT</strong></td>\n<td><strong>指定一个容器启动时要运行的命令<br />ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td>\n</tr>\n</tbody>\n</table>\n<h4><a id=\"931_FROM__683\"></a>9.3.1 FROM 命令</h4>\n<ul>\n<li>\n<p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">FROM  &lt;image&gt;\nFROM  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest\nFROM  &lt;image&gt;[@&lt;digest&gt;]  使用摘要\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"932_MAINTAINER___695\"></a>9.3.2 MAINTAINER  命令</h4>\n<ul>\n<li>\n<p>镜像维护者的姓名和邮箱地址[废弃]</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">MAINTAINER &lt;name&gt;\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"933_RUN__705\"></a>9.3.3 RUN 命令</h4>\n<ul>\n<li>\n<p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\nRUN echo hello\n\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)\nRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"934_EXPOSE__719\"></a>9.3.4 EXPOSE 命令</h4>\n<ul>\n<li>\n<p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\nEXPOSE 80/udp\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"935_CMD__730\"></a>9.3.5 CMD 命令</h4>\n<ul>\n<li>\n<p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>\n</li>\n<li>\n<p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)\nCMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)\nCMD command param1 param2 (shell form)\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"936_WORKDIR__744\"></a>9.3.6 WORKDIR 命令</h4>\n<ul>\n<li>\n<p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">WORKDIR /path/to/workdir\n\nWORKDIR /a\nWORKDIR b\nWORKDIR c\n`注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"937_ENV__759\"></a>9.3.7 ENV 命令</h4>\n<ul>\n<li>\n<p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>\n</li>\n<li>\n<p>语法：</p>\n<pre><code class=\"lang-dockerfile\">ENV &lt;key&gt; &lt;value&gt;\nENV &lt;key&gt;=&lt;value&gt; ...\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"938_ADD__770\"></a>9.3.8 ADD 命令</h4>\n<ul>\n<li>\n<p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">ADD hom* /mydir/       通配符添加多个文件\nADD hom?.txt /mydir/   通配符添加\nADD test.txt relativeDir/  可以指定相对路径\nADD test.txt /absoluteDir/ 也可以指定绝对路径\nADD url \n</code></pre>\n</li>\n</ul>\n<h4><a id=\"939_COPY__784\"></a>9.3.9 COPY 命令</h4>\n<ul>\n<li>\n<p>用来将context目录中指定文件复制到镜像的指定目录中</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">COPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"9310_VOLUME__795\"></a>9.3.10 VOLUME 命令</h4>\n<ul>\n<li>\n<p>用来定义容器运行时可以挂在到宿主机的目录</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">VOLUME [&quot;/data&quot;]\n</code></pre>\n</li>\n</ul>\n<h4><a id=\"9311_ENTRYPOINT_805\"></a>9.3.11 ENTRYPOINT命令</h4>\n<ul>\n<li>\n<p>用来指定容器启动时执行命令和CMD类似</p>\n</li>\n<li>\n<p>语法:</p>\n<pre><code class=\"lang-dockerfile\">  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2\n</code></pre>\n<p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。<br />\nCMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p>\n</li>\n</ul>\n<h4><a id=\"9311_ENTRYPOINT_819\"></a>9.3.11 ENTRYPOINT命令</h4>\n<h3><a id=\"94_Dockerfilespringboot_821\"></a>9.4 Dockerfile构建springboot项目部署</h3>\n<h5><a id=\"1springboot_823\"></a>1.准备springboot可运行项目</h5>\n<p><img src=\"Docker_1.assets/image-20200605172151266.png\" alt=\"image-20200605172151266\" /></p>\n<h5><a id=\"2linux_827\"></a>2.将可运行项目放入linux虚拟机中</h5>\n<p><img src=\"Docker_1.assets/image-20200605172340380.png\" alt=\"image-20200605172340380\" /></p>\n<h5><a id=\"3Dockerfile_831\"></a>3.编写Dockerfile</h5>\n<pre><code class=\"lang-dockerfile\">FROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]\nCMD [&quot;ems.jar&quot;]\n</code></pre>\n<h5><a id=\"4_842\"></a>4.构建镜像</h5>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@localhost ems]# docker build -t ems .\n</code></div></pre>\n<h5><a id=\"5_848\"></a>5.运行镜像</h5>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@localhost ems]# docker run -p 8989:8989 ems\n</code></div></pre>\n<h5><a id=\"6_854\"></a>6.访问项目</h5>\n<pre><code class=\"lang-http\">http://10.15.0.8:8989/ems/login.html\n</code></pre>\n<p><img src=\"Docker_1.assets/image-20200605173141636.png\" alt=\"image-20200605173141636\" /></p>\n<hr />\n<h2><a id=\"10_864\"></a>10.高级网络配置</h2>\n<h3><a id=\"101__866\"></a>10.1 说明</h3>\n<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href=\"https://tools.ietf.org/html/rfc1918\" target=\"_blank\">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>\n<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>\n<p><img src=\"Docker_1.assets/image-20201125105847896.png\" alt=\"image-20201125105847896\" /></p>\n<h3><a id=\"102__876\"></a>10.2 查看网络信息</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># docker network ls</span>\n</code></div></pre>\n<h3><a id=\"103__882\"></a>10.3 创建一个网桥</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># docker network create -d bridge 网桥名称</span>\n</code></div></pre>\n<h3><a id=\"104__888\"></a>10.4 删除一个网桥</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># docker network rm 网桥名称</span>\n</code></div></pre>\n<h3><a id=\"105__894\"></a>10.5 容器之前使用网络通信</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.查询当前网络配置</span>\n<span class=\"hljs-bullet\">-</span> docker network ls\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">NETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 2.创建桥接网络</span>\n<span class=\"hljs-bullet\">-</span> docker network create -d bridge info\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 3.启动容器指定使用网桥</span>\n<span class=\"hljs-bullet\">-</span> docker run -d -p 8890:80 --name nginx001 --network info nginx \n<span class=\"hljs-bullet\">-</span> docker run -d -p 8891:80 --name nginx002 --network info nginx \n<span class=\"hljs-code\">	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n</span></code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002\nc315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001\nb63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n.....\n</code></div></pre>\n<hr />\n<h2><a id=\"11_952\"></a>11.高级数据卷配置</h2>\n<h3><a id=\"111__954\"></a>11.1 说明</h3>\n<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>\n<ul>\n<li><code>数据卷</code> 可以在容器之间共享和重用</li>\n<li>对 <code>数据卷</code> 的修改会立马生效</li>\n<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>\n<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>\n</ul>\n<blockquote>\n<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>\n</blockquote>\n<h3><a id=\"112__965\"></a>11.2 创建数据卷</h3>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@centos ~]# docker volume create my-vol\nmy-vol\n</code></div></pre>\n<h3><a id=\"113__972\"></a>11.3 查看数据卷</h3>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: {},\n        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n        &quot;Name&quot;: &quot;my-vol&quot;,\n        &quot;Options&quot;: {},\n        &quot;Scope&quot;: &quot;local&quot;\n    }\n]\n</code></div></pre>\n<h3><a id=\"114__989\"></a>11.4 挂载数据卷</h3>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				&quot;Mounts&quot;: [\n            {\n                &quot;Type&quot;: &quot;volume&quot;,\n                &quot;Name&quot;: &quot;my-vol&quot;,\n                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,\n                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,\n                &quot;Driver&quot;: &quot;local&quot;,\n                &quot;Mode&quot;: &quot;z&quot;,\n                &quot;RW&quot;: true,\n                &quot;Propagation&quot;: &quot;&quot;\n            }\n        ],\n</code></div></pre>\n<h3><a id=\"115__1008\"></a>11.5 删除数据卷</h3>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">docker volume rm my-vol\n</code></div></pre>\n<hr />\n<h2><a id=\"12Docker_Compose_1016\"></a>12.Docker Compose</h2>\n<h3><a id=\"121__1018\"></a>12.1 简介</h3>\n<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>\n<p>其代码目前在 https://github.com/docker/compose 上开源。</p>\n<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>\n<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>\n<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>\n<p><code>Compose</code> 中有两个重要的概念：</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>\n</ul>\n<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>\n<h3><a id=\"122__1039\"></a>12.2 安装与卸载</h3>\n<h6><a id=\"1linux_1041\"></a>1.linux</h6>\n<ul>\n<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`<span class=\"hljs-built_in\">uname</span> -s`-`<span class=\"hljs-built_in\">uname</span> -m` &gt; /usr/local/bin/docker-compose\n$ sudo <span class=\"hljs-built_in\">chmod</span> +x /usr/local/bin/docker-compose\n</code></div></pre>\n<h6><a id=\"2macoswindow_1050\"></a>2.macos、window</h6>\n<ul>\n<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>\n</ul>\n<h6><a id=\"3bash_1054\"></a>3.bash命令补全</h6>\n<pre><div class=\"hljs\"><code class=\"lang-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span>\n</code></div></pre>\n<h6><a id=\"4_1060\"></a>4.卸载</h6>\n<ul>\n<li>如果是二进制包方式安装的，删除二进制文件即可。</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">sudo <span class=\"hljs-built_in\">rm</span> /usr/local/bin/docker-compose</span>\n</code></div></pre>\n<h6><a id=\"5_1068\"></a>5.测试安装成功</h6>\n<pre><div class=\"hljs\"><code class=\"lang-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">docker-compose --version</span>\n docker-compose version 1.25.5, build 4667896b\n</code></div></pre>\n<h3><a id=\"123_docker_compose_1075\"></a>12.3 docker compose使用</h3>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 1.相关概念</span>\n</code></div></pre>\n<p>首先介绍几个术语。</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 2.场景</span>\n</code></div></pre>\n<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>\n<ul>\n<li>springboot应用</li>\n<li>mysql服务</li>\n<li>redis服务</li>\n<li>elasticsearch服务</li>\n<li>…</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 3.docker-compose模板</span>\n<span class=\"hljs-bullet\">-</span> 参考文档:https://docker<span class=\"hljs-emphasis\">_practice.gitee.io/zh-cn/compose/compose_</span>file.html\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-yml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&quot;3.0&quot;</span>\n<span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">mysqldb:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">mysql:5.7.19</span>\n    <span class=\"hljs-attr\">container_name:</span> <span class=\"hljs-string\">mysql</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;3306:3306&quot;</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">/root/mysql/conf:/etc/mysql/conf.d</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">/root/mysql/logs:/logs</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">/root/mysql/data:/var/lib/mysql</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-attr\">MYSQL_ROOT_PASSWORD:</span> <span class=\"hljs-string\">root</span>\n    <span class=\"hljs-attr\">networks:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">ems</span>\n    <span class=\"hljs-attr\">depends_on:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">redis</span>\n\n  <span class=\"hljs-attr\">redis:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">redis:4.0.14</span>\n    <span class=\"hljs-attr\">container_name:</span> <span class=\"hljs-string\">redis</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;6379:6379&quot;</span>\n    <span class=\"hljs-attr\">networks:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">ems</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">/root/redis/data:/data</span>\n    <span class=\"hljs-attr\">command:</span> <span class=\"hljs-string\">redis-server</span>\n    \n<span class=\"hljs-attr\">networks:</span>\n  <span class=\"hljs-attr\">ems:</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-markdown\"><span class=\"hljs-section\"># 4.通过docker-compose运行一组容器</span>\n<span class=\"hljs-bullet\">-</span> 参考文档:https://docker<span class=\"hljs-emphasis\">_practice.gitee.io/zh-cn/compose/commands.html\n</span></code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@centos ~]<span class=\"hljs-comment\"># docker-compose up    							//前台启动一组服务</span>\n[root@centos ~]<span class=\"hljs-comment\"># docker-compose up -d 							//后台启动一组服务</span>\n</code></div></pre>\n<hr />\n<h3><a id=\"124_dockercompose__1149\"></a>12.4 docker-compose 模板文件</h3>\n<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>\n<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&quot;3&quot;</span>\n\n<span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">webapp:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">examples/web</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;80:80&quot;</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;/data&quot;</span>\n</code></div></pre>\n<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>\n<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>\n<p>下面分别介绍各个指令的用法。</p>\n<h4><a id=\"build_1173\"></a><code>build</code></h4>\n<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&#x27;3&#x27;</span>\n<span class=\"hljs-attr\">services:</span>\n\n  <span class=\"hljs-attr\">webapp:</span>\n    <span class=\"hljs-attr\">build:</span> <span class=\"hljs-string\">./dir</span>\n</code></div></pre>\n<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>\n<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>\n<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&#x27;3&#x27;</span>\n<span class=\"hljs-attr\">services:</span>\n\n  <span class=\"hljs-attr\">webapp:</span>\n    <span class=\"hljs-attr\">build:</span>\n      <span class=\"hljs-attr\">context:</span> <span class=\"hljs-string\">./dir</span>\n      <span class=\"hljs-attr\">dockerfile:</span> <span class=\"hljs-string\">Dockerfile-alternate</span>\n      <span class=\"hljs-attr\">args:</span>\n        <span class=\"hljs-attr\">buildno:</span> <span class=\"hljs-number\">1</span>\n</code></div></pre>\n<h4><a id=\"command_1203\"></a><code>command</code></h4>\n<p>覆盖容器启动后默认执行的命令。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">command:</span> <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">&quot;hello world&quot;</span>\n</code></div></pre>\n<h4><a id=\"container_name_1211\"></a><code>container_name</code></h4>\n<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">container_name:</span> <span class=\"hljs-string\">docker-web-container</span>\n</code></div></pre>\n<blockquote>\n<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>\n</blockquote>\n<h4><a id=\"depends_on_1221\"></a><code>depends_on</code></h4>\n<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&#x27;3&#x27;</span>\n\n<span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">web:</span>\n    <span class=\"hljs-attr\">build:</span> <span class=\"hljs-string\">.</span>\n    <span class=\"hljs-attr\">depends_on:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">db</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">redis</span>\n\n  <span class=\"hljs-attr\">redis:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">redis</span>\n\n  <span class=\"hljs-attr\">db:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">postgres</span>\n</code></div></pre>\n<blockquote>\n<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>\n</blockquote>\n<h4><a id=\"env_file_1244\"></a><code>env_file</code></h4>\n<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>\n<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">env_file: .<span class=\"hljs-built_in\">env</span>\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n</code></div></pre>\n<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-comment\"># common.env: Set development environment</span>\nPROG_ENV=development\n</code></div></pre>\n<h4><a id=\"environment_1268\"></a><code>environment</code></h4>\n<p>设置环境变量。你可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">environment:</span>\n  <span class=\"hljs-attr\">RACK_ENV:</span> <span class=\"hljs-string\">development</span>\n  <span class=\"hljs-attr\">SESSION_SECRET:</span>\n\n<span class=\"hljs-attr\">environment:</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">RACK_ENV=development</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SESSION_SECRET</span>\n</code></div></pre>\n<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href=\"https://yaml.org/type/bool.html\" target=\"_blank\">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">y|Y|<span class=\"hljs-built_in\">yes</span>|Yes|YES|n|N|no|No|NO|<span class=\"hljs-literal\">true</span>|True|TRUE|<span class=\"hljs-literal\">false</span>|False|FALSE|on|On|ON|off|Off|OFF\n</code></div></pre>\n<h4><a id=\"healthcheck_1290\"></a><code>healthcheck</code></h4>\n<p>通过命令检查容器是否健康运行。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">healthcheck:</span>\n  <span class=\"hljs-attr\">test:</span> [<span class=\"hljs-string\">&quot;CMD&quot;</span>, <span class=\"hljs-string\">&quot;curl&quot;</span>, <span class=\"hljs-string\">&quot;-f&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost&quot;</span>]\n  <span class=\"hljs-attr\">interval:</span> <span class=\"hljs-string\">1m30s</span>\n  <span class=\"hljs-attr\">timeout:</span> <span class=\"hljs-string\">10s</span>\n  <span class=\"hljs-attr\">retries:</span> <span class=\"hljs-number\">3</span>\n</code></div></pre>\n<h4><a id=\"image_1302\"></a><code>image</code></h4>\n<p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">ubuntu</span>\n<span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">orchardup/postgresql</span>\n<span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">a4bc65fd</span>\n</code></div></pre>\n<h4><a id=\"networks_1312\"></a><code>networks</code></h4>\n<p>配置容器连接的网络。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&quot;3&quot;</span>\n<span class=\"hljs-attr\">services:</span>\n\n  <span class=\"hljs-attr\">some-service:</span>\n    <span class=\"hljs-attr\">networks:</span>\n     <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">some-network</span>\n     <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">other-network</span>\n\n<span class=\"hljs-attr\">networks:</span>\n  <span class=\"hljs-attr\">some-network:</span>\n  <span class=\"hljs-attr\">other-network:</span>\n</code></div></pre>\n<h4><a id=\"ports_1330\"></a><code>ports</code></h4>\n<p>暴露端口信息。</p>\n<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">ports:</span>\n <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;3000&quot;</span>\n <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;8000:8000&quot;</span>\n <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;49100:22&quot;</span>\n <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;127.0.0.1:8001:8001&quot;</span>\n</code></div></pre>\n<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>\n<h4><a id=\"sysctls_1346\"></a><code>sysctls</code></h4>\n<p>配置容器内核参数。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">sysctls:</span>\n  <span class=\"hljs-attr\">net.core.somaxconn:</span> <span class=\"hljs-number\">1024</span>\n  <span class=\"hljs-attr\">net.ipv4.tcp_syncookies:</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-attr\">sysctls:</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">net.core.somaxconn=1024</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">net.ipv4.tcp_syncookies=0</span>\n</code></div></pre>\n<h4><a id=\"ulimits_1360\"></a><code>ulimits</code></h4>\n<p>指定容器的 ulimits 限制值。</p>\n<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\">  <span class=\"hljs-attr\">ulimits:</span>\n    <span class=\"hljs-attr\">nproc:</span> <span class=\"hljs-number\">65535</span>\n    <span class=\"hljs-attr\">nofile:</span>\n      <span class=\"hljs-attr\">soft:</span> <span class=\"hljs-number\">20000</span>\n      <span class=\"hljs-attr\">hard:</span> <span class=\"hljs-number\">40000</span>\n</code></div></pre>\n<h4><a id=\"volumes_1374\"></a><code>volumes</code></h4>\n<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>\n<p>该指令中路径支持相对路径。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">volumes:</span>\n <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">/var/lib/mysql</span>\n <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">cache/:/tmp/cache</span>\n <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">~/configs:/etc/configs/:ro</span>\n</code></div></pre>\n<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&quot;3&quot;</span>\n\n<span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">my_src:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">mysql:8.0</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">mysql_data:/var/lib/mysql</span>\n\n<span class=\"hljs-attr\">volumes:</span>\n  <span class=\"hljs-attr\">mysql_data:</span>\n</code></div></pre>\n<hr />\n<h3><a id=\"125_dockercompose__1404\"></a>12.5 docker-compose 常用命令</h3>\n<h5><a id=\"1__1406\"></a>1. 命令对象与格式</h5>\n<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>\n<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>\n<p><code>docker-compose</code> 命令的基本的使用格式是</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]\n</code></div></pre>\n<h5><a id=\"2__1418\"></a>2. 命令选项</h5>\n<ul>\n<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>\n<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>\n<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>\n<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>\n<li><code>--verbose</code> 输出更多调试信息。</li>\n<li><code>-v, --version</code> 打印版本并退出。</li>\n</ul>\n<h5><a id=\"3_1427\"></a>3.命令使用说明</h5>\n<h5><a id=\"up_1429\"></a><code>up</code></h5>\n<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>\n<ul>\n<li>\n<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>\n</li>\n<li>\n<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>\n</li>\n<li>\n<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\n</li>\n<li>\n<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>\n</li>\n<li>\n<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>\n</li>\n<li>\n<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>\n</li>\n<li>\n<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>\n</li>\n</ul>\n<hr />\n<h5><a id=\"down_1449\"></a><code>down</code></h5>\n<ul>\n<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>\n</ul>\n<hr />\n<h5><a id=\"exec_1455\"></a><code>exec</code></h5>\n<ul>\n<li>进入指定的容器。</li>\n</ul>\n<hr />\n<h5><a id=\"ps_1461\"></a><code>ps</code></h5>\n<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>\n<p>列出项目中目前的所有容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-q</code> 只打印容器的 ID 信息。</li>\n</ul>\n<hr />\n<h5><a id=\"restart_1473\"></a><code>restart</code></h5>\n<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>\n<p>重启项目中的服务。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><a id=\"rm_1485\"></a><code>rm</code></h5>\n<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>\n<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>\n<li><code>-v</code> 删除容器所挂载的数据卷。</li>\n</ul>\n<hr />\n<h5><a id=\"start_1498\"></a><code>start</code></h5>\n<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>\n<p>启动已经存在的服务容器。</p>\n<hr />\n<h5><a id=\"stop_1506\"></a><code>stop</code></h5>\n<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>\n<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>\n</ul>\n<hr />\n<h5><a id=\"top_1518\"></a><code>top</code></h5>\n<p>查看各个服务容器内运行的进程。</p>\n<hr />\n<h5><a id=\"unpause_1524\"></a><code>unpause</code></h5>\n<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>\n<p>恢复处于暂停状态中的服务。</p>\n<hr />\n<h2><a id=\"13docker_1532\"></a>13.docker可视化工具</h2>\n<h4><a id=\"131_Portainer_1534\"></a>13.1 安装Portainer</h4>\n<p>官方安装说明：<a href=\"http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=\" target=\"_blank\">https://www.portainer.io/installation/</a></p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer\n</code></div></pre>\n<h4><a id=\"132_Portainer_1550\"></a>13.2 登录和使用Portainer</h4>\n<blockquote>\n<p>用浏览器访问：<code>http://localhost:9000</code></p>\n</blockquote>\n<p><img src=\"Docker_1.assets/image-20201223231707738.png\" alt=\"image-20201223231707738\" /></p>\n<hr />\n', '# Docker\n\n- 官方文档地址:https://www.docker.com/get-started\n\n- 中文参考手册:https://docker_practice.gitee.io/zh-cn/\n\n-----\n\n## 1.什么是 Docker\n\n### 1.1 官方定义\n\n- 最新官网首页\n\n![image-20201220213306128](Docker_1.assets/image-20201220213306128.png)\n\n![image-20201220214210994](Docker_1.assets/image-20201220214210994.png)\n\n```markdown\n# 1.官方介绍\n- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.\n- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。\n- 官方定义: docker是一个容器技术。\n```\n\n### 1.2 Docker的起源\n\n```markdown\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\n\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n```\n\n## 2.为什么是Docker\n\n- `在开发的时候，在本机测试环境可以跑，生产环境跑不起来`\n\n  这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。\n\n  **优势1:  一致的运行环境,更轻松的迁移**\n\n  \n\n- `服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了`\n\n  这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。\n\n  **优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源**\n\n  \n\n- `公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器`\n\n  在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。\n  \n  **优势3: 通过镜像复制N多个环境一致容器**\n\n----\n\n## 3.Docker和虚拟机区别\n\n> 关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。\n\n![image-20201220222456675](Docker_1.assets/image-20201220222456675.png)\n\n`比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重`。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存->虚拟物理内存->真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存->真正物理内存。\n\n|             | 传统虚拟机                           | Docker容器                            |\n| ----------- | ------------------------------------ | ------------------------------------- |\n| 磁盘占用    | 几个GB到几十个GB左右                 | 几十MB到几百MB左右                    |\n| CPU内存占用 | 虚拟操作系统非常占用CPU和内存        | Docker引擎占用极低                    |\n| 启动速度    | （从开机到运行项目）几分钟           | （从开启容器到运行项目）几秒          |\n| 安装管理    | 需要专门的运维技术                   | 安装、管理方便                        |\n| 应用部署    | 每次部署都费时费力                   | 从第二次部署开始轻松简捷              |\n| 耦合性      | 多个应用服务安装到一起，容易互相影响 | 每个应用服务一个容器，达成隔离        |\n| 系统依赖    | 无                                   | 需求相同或相似的内核，目前推荐是Linux |\n\n---\n\n## 4.Docker的安装\n\n### 4.1 安装docker(centos7.x)\n\n- 卸载原始docker\n\n  ```sh\n  $ sudo yum remove docker \\\n                    docker-client \\\n                    docker-client-latest \\\n                    docker-common \\\n                    docker-latest \\\n                    docker-latest-logrotate \\\n                    docker-logrotate \\\n                    docker-engine\n  ```\n\n- 安装docker依赖\n\n  ```shell\n  $ sudo yum install -y yum-utils \\\n    device-mapper-persistent-data \\\n    lvm2\n  ```\n\n- 设置docker的yum源\n\n  ```bash\n  $ sudo yum-config-manager \\\n      --add-repo \\\n      https://download.docker.com/linux/centos/docker-ce.repo\n  ```\n\n- 安装最新版的docker\n\n  ```bash\n  $ sudo yum install docker-ce docker-ce-cli containerd.io\n  ```\n\n- 指定版本安装docker\n\n  ```bash\n  $ yum list docker-ce --showduplicates | sort -r\n  $ sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\n  $ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n-  关闭docker\n\n  ```bash\n  $ sudo systemctl stop docker\n  ```\n\n- 测试docker安装\n\n  ```bash\n  $ sudo docker run hello-world\n  ```\n\n### 4.2 bash安装(通用所有平台)\n\n- 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。\n\n  ```bash\n  $ curl -fsSL get.docker.com -o get-docker.sh\n  $ sudo sh get-docker.sh --mirror Aliyun\n  ```\n\n- 启动docker\n\n  ```bash\n  $ sudo systemctl enable docker\n  $ sudo systemctl start docker\n  ```\n\n- 创建docker用户组\n\n  ```bash\n  $ sudo groupadd docker\n  ```\n\n- 将当前用户加入docker组\n\n  ```bash\n  $ sudo usermod -aG docker $USER\n  ```\n\n- 测试docker安装是否正确\n\n  ```bash\n  $ docker run hello-world\n  ```\n\n## 5.Docker 的核心架构\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085-0291323.png)\n\n- `镜像:` 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等\n- `容器:` 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写\n- `仓库:`用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置\n- `dockerFile:`docker生成镜像配置文件,用来书写自定义镜像的一些配置\n- `tar:`一个对镜像打包的文件,日后可以还原成镜像\n\n## 6. Docker 配置阿里镜像加速服务\n\n### 6.1 docker 运行流程\n\n![image-20200404120356784](Docker_1.assets/image-20200404120356784.png)\n\n### 6.2 docker配置阿里云镜像加速\n\n- `访问阿里云登录自己账号查看docker镜像加速服务`\n\n```shell\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  \"registry-mirrors\": [\"https://lz2nib3q.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n- `验证docker的镜像加速是否生效`\n\n```shell\n[root@localhost ~]# docker info\n		..........\n    127.0.0.0/8\n   Registry Mirrors:\n    \'https://lz2nib3q.mirror.aliyuncs.com/\'\n   Live Restore Enabled: false\n   Product License: Community Engine\n```\n\n-----\n\n## 7.Docker的入门应用\n\n### 7.1 docker 的第一个程序\n\n> docker  run hello-world\n\n```shell\n[root@localhost ~]# docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n\n----\n\n## 8.常用命令\n\n### 6.1 辅助命令\n\n~~~markdown\n# 1.安装完成辅助命令\n		docker version	--------------------------	查看docker的信息\n		docker info		--------------------------	查看更详细的信息\n		docker --help	--------------------------	帮助命令\n~~~\n\n### 6.2 Images 镜像命令\n\n~~~markdown\n# 1.查看本机中所有镜像\n	docker images	--------------------------	列出本地所有镜像\n		-a			列出所有镜像（包含中间映像层）\n  	-q			只显示镜像id\n\n# 2.搜索镜像\n	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像\n		-s 指定值		列出收藏数不少于指定值的镜像\n  	--no-trunc	  显示完整的镜像信息\n\n# 3.从仓库下载镜像\n	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像\n\n# 4.删除镜像\n	docker rmi 镜像名	--------------------------  删除镜像\n		-f		强制删除\n~~~\n\n### 6.3 Contrainer 容器命令\n\n~~~markdown\n# 1.运行容器\n	docker run 镜像名	--------------------------	镜像名新建并启动容器\n    --name 					别名为容器起一个名字\n    -d							启动守护式容器（在后台启动容器）\n    -p 							映射端口号：原始端口号		 指定端口号启动\n\n	例：docker run -it --name myTomcat -p 8888:8080 tomcat\n   	 docker run -d --name myTomcat -P tomcat\n\n# 2.查看运行的容器\n	docker ps					--------------------------	列出所有正在运行的容器\n	-a			正在运行的和历史运行过的容器\n	-q			静默模式，只显示容器编号\n\n# 3.停止|关闭|重启容器\n	docker start   容器名字或者容器id  --------------- 开启容器\n	docker restart 容器名或者容器id    --------------- 重启容器\n	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行\n	docker kill  容器名或者容器id      ------------------ 立即停止容器运行\n\n# 4.删除容器\n	docker rm -f 容器id和容器名     \n	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器\n\n# 5.查看容器内进程\n	docker top 容器id或者容器名 ------------------ 查看容器内的进程\n\n# 6.查看查看容器内部细节\n	docker inspect 容器id 		------------------ 查看容器内部细节\n\n# 7.查看容器的运行日志\n	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志\n    -t			 加入时间戳\n    -f			 跟随最新的日志打印\n    --tail 	 数字	显示最后多少条\n\n# 8.进入容器内部\n	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令\n		-i		以交互模式运行容器，通常与-t一起使用\n    -t		分配一个伪终端    shell窗口   bash \n\n# 9.容器和宿主机之间复制文件\n	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部\n	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上\n\n# 10.数据卷(volum)实现与宿主机共享目录\n	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名\n		注意: \n				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容\n				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中\n\n# 11.打包镜像\n		docker save 镜像名 -o  名称.tar\n\n# 12.载入镜像\n		docker load -i   名称.tar\n\n# 13.容器打包成新的镜像\n	  docker commit -m \"描述信息\" -a \"作者信息\"   （容器id或者名称）打包的镜像名称:标签\n~~~\n\n----\n\n## 7.docker的镜像原理\n\n### 7.1 镜像是什么？\n\n> 镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。\n\n### 7.2 为什么一个镜像会那么大？\n\n![image-20200404142950068](Docker_1.assets/image-20200404142950068.png)\n\n`镜像就是花卷`\n\n- UnionFS（联合文件系统）:\n\n  Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。	\n\n### 7.3 Docker镜像原理\n\n> `docker的镜像实际是由一层一层的文件系统组成。`\n\n- bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。\n\n- rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。\n\n- 我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。\n\n\n\n![](Docker_1.assets/1567585172(1).jpg)\n\n### 7.4 为什么docker镜像要采用这种分层结构呢?\n\n> `最大的一个好处就是资源共享`\n\n- 比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。\n\n---\n\n## 8.Docker安装常用服务\n\n### 8.1 安装mysql\n\n```markdown\n# 1.拉取mysql镜像到本地\n	docker pull mysql:tag (tag不加默认最新版本)\n	\n# 2.运行mysql服务\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接\n	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口\n\n# 3.进入mysql容器\n	docker exec -it 容器名称|容器id bash\n\n# 4.外部查看mysql日志\n	docker logs 容器名称|容器id\n\n# 5.使用自定义配置参数\n	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag\n\n# 6.将容器数据位置与宿主机位置挂载保证数据安全\n	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag\n\n# 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问\n	\n# 8.将mysql数据库备份为sql文件\n	docker exec mysql|容器id sh -c \'exec mysqldump --all-databases -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出全部数据\n	docker exec mysql sh -c \'exec mysqldump --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据\n	docker exec mysql sh -c \'exec mysqldump --no-data --databases 库表 -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' > /root/all-databases.sql  --导出指定库数据不要数据\n\n# 9.执行sql文件到mysql中\n	docker exec -i mysql sh -c \'exec mysql -uroot -p\"$MYSQL_ROOT_PASSWORD\"\' < /root/xxx.sql\n```\n\n### 8.2 安装Redis服务\n\n```markdown\n# 1.在docker hub搜索redis镜像\n	docker search redis\n\n# 2.拉取redis镜像到本地\n	docker pull redis\n\n# 3.启动redis服务运行容器\n	docker run --name redis -d redis:tag (没有暴露外部端口)\n	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) \n\n# 4.查看启动日志\n	docker logs -t -f 容器id|容器名称\n\n# 5.进入容器内部查看\n	docker exec -it 容器id|名称 bash  \n\n# 6.加载外部自定义配置启动redis容器\n	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件\n	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包\n	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件\n	3. 修改需要自定义的配置\n		 bind 0.0.0.0 开启远程权限\n		 appenonly yes 开启aof持久化\n	4. 加载配置启动\n	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  \n\n# 7.将数据目录挂在到本地保证数据安全\n	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  \n```\n\n### 8.3 安装Nginx\n\n```markdown\n# 1.在docker hub搜索nginx\n	docker search nginx\n\n# 2.拉取nginx镜像到本地\n	[root@localhost ~]# docker pull nginx\n    Using default tag: latest\n    latest: Pulling from library/nginx\n    afb6ec6fdc1c: Pull complete \n    b90c53a0b692: Pull complete \n    11fa52a0fdc0: Pull complete \n    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097\n    Status: Downloaded newer image for nginx:latest\n    docker.io/library/nginx:latest\n\n# 3.启动nginx容器\n		docker run -p 80:80 --name nginx01 -d nginx\n\n# 4.进入容器\n		docker exec -it nginx01 /bin/bash\n		查找目录:  whereis nginx\n		配置文件:  /etc/nginx/nginx.conf\n\n# 5.复制配置文件到宿主机\n		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录\n\n# 6.挂在nginx配置以及html到宿主机外部\n		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		\n```\n\n----\n\n### 8.4 安装Tomcat\n\n```markdown\n# 1.在docker hub搜索tomcat\n	docker search tomcat\n\n# 2.下载tomcat镜像\n	docker pull tomcat\n\n# 3.运行tomcat镜像\n	docker run -p 8080:8080 -d --name mytomcat tomcat\n\n# 4.进入tomcat容器\n	docker exec -it mytomcat /bin/bash\n\n# 5.将webapps目录挂载在外部\n	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat\n\n```\n\n-----\n\n### 8.5 安装MongoDB数据库\n\n```markdown\n# 1.运行mongDB\n	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限\n	docker logs -f mymongo --查看mongo运行日志\n\n# 2.进入mongodb容器\n	docker exec -it mymongo /bin/bash\n		直接执行mongo命令进行操作\n\n# 3.常见具有权限的容器\n	docker run --name  mymongo  -p 27017:27017  -d mongo --auth\n\n# 4.进入容器配置用户名密码\n	mongo\n	use admin 选择admin库\n	db.createUser({user:\"root\",pwd:\"root\",roles:[{role:\'root\',db:\'admin\'}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证\n	exit\n\n# 5.将mongoDB中数据目录映射到宿主机中\n	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo \n```\n\n### 8.6 安装ElasticSearch\n\n- `注意:`**调高JVM线程数限制数量**\n\n#### 0.拉取镜像运行elasticsearch\n\n```markdown\n# 1.dockerhub 拉取镜像\n	docker pull elasticsearch:6.4.2\n# 2.查看docker镜像\n	docker images\n# 3.运行docker镜像\n	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2\n```\n\n- 启动出现如下错误\n- ![image-20200602184321790](Docker_1.assets/image-20200602184321790.png)\n\n#### 1. 预先配置\n\n```markdown\n# 1.在centos虚拟机中，修改配置sysctl.conf\n	vim /etc/sysctl.conf\n# 2.加入如下配置\n	vm.max_map_count=262144 \n# 3.启用配置\n	sysctl -p\n	注：这一步是为了防止启动容器时，报出如下错误：\n	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]\n\n```\n\n#### 2.启动EleasticSearch容器\n\n```markdown\n# 0.复制容器中data目录到宿主机中\n	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es\n# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置\n	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=\"-Xms128m -Xmx128m\" -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2\n```\n\n#### 3.安装IK分词器\n\n```markdown\n# 1.下载对应版本的IK分词器\n	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip\n\n# 2.解压到plugins文件夹中\n	yum install -y unzip\n	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip\n\n# 3.添加自定义扩展词和停用词\n	cd plugins/elasticsearch/config\n	vim IKAnalyzer.cfg.xml\n	<properties>\n		<comment>IK Analyzer 扩展配置</comment>\n		<!--用户可以在这里配置自己的扩展字典 -->\n		<entry key=\"ext_dict\">ext_dict.dic</entry>\n		<!--用户可以在这里配置自己的扩展停止词字典-->\n		<entry key=\"ext_stopwords\">ext_stopwords.dic</entry>\n	</properties>\n\n# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效\n	vim ext_dict.dic 加入扩展词即可\n# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 \n	vim ext_stopwords.dic 加入停用词即可\n\n# 6.重启容器生效\n	docker restart 容器id\n# 7.将此容器提交成为一个新的镜像\n	docker commit -a=\"xiaochen\" -m=\"es with IKAnalyzer\" 容器id xiaochen/elasticsearch:6.4.2\n```\n\n#### 4. 安装Kibana\n\n```markdown\n# 1.下载kibana镜像到本地\n	docker pull kibana:6.4.2\n\n# 2.启动kibana容器\n	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2\n```\n\n----\n\n## 10.Docker中出现如下错误解决方案\n\n```powershell\n[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用\nError response from daemon: Get https://index.docker.io/v1/search?q=mysql&n=25: x509: certificate has expired or is not yet valid\n```\n\n![image-20200602183429286](Docker_1.assets/image-20200602183429286.png)\n\n- 注意:**这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步**\n\n```markdown\n# 1.安装时间同步\n	sudo yum -y install ntp ntpdate\n# 2.同步时间\n	sudo ntpdate cn.pool.ntp.org\n# 3.查看本机时间\n	date\n# 4.从新测试\n```\n\n![image-20200602183718623](Docker_1.assets/image-20200602183718623.png)\n\n## 9.Dockerfile\n\n### 9.1 什么是Dockerfile\n\nDockerfile可以认为是**Docker镜像的描述文件，是由一系列命令和参数构成的脚本**。主要作用是**用来构建docker镜像的构建文件**。\n\n![image-20200404111908085](Docker_1.assets/image-20200404111908085.png)\n\n- **通过架构图可以看出通过DockerFile可以直接构建镜像**\n\n### 9.2 Dockerfile解析过程\n\n![image-20200603181253804](Docker_1.assets/image-20200603181253804.png)\n\n### 9.3 Dockerfile的保留命令\n\n官方说明:https://docs.docker.com/engine/reference/builder/\n\n| 保留字         | 作用                                                         |\n| -------------- | ------------------------------------------------------------ |\n| **FROM**       | **当前镜像是基于哪个镜像的** `第一个指令必须是FROM`          |\n| MAINTAINER     | 镜像维护者的姓名和邮箱地址                                   |\n| **RUN**        | **构建镜像时需要运行的指令**                                 |\n| **EXPOSE**     | **当前容器对外暴露出的端口号**                               |\n| **WORKDIR**    | **指定在创建容器后，终端默认登录进来的工作目录，一个落脚点** |\n| **ENV**        | **用来在构建镜像过程中设置环境变量**                         |\n| **ADD**        | **将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包** |\n| **COPY**       | **类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中<原路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置** |\n| **VOLUME**     | **容器数据卷，用于数据保存和持久化工作**                     |\n| **CMD**        | **指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换** |\n| **ENTRYPOINT** | **指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数** |\n\n#### 9.3.1 FROM 命令\n\n- 基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现\n\n- 语法:\n\n  ```dockerfile\n  FROM  <image>\n  FROM  <image>[:<tag>]     使用版本不写为latest\n  FROM  <image>[@<digest>]  使用摘要\n  ```\n\n#### 9.3.2 MAINTAINER  命令\n\n- 镜像维护者的姓名和邮箱地址[废弃]\n\n- 语法:\n\n  ```dockerfile\n  MAINTAINER <name>\n  ```\n\n#### 9.3.3 RUN 命令\n\n- RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步\n\n- 语法:\n\n  ```dockerfile\n  RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)\n  RUN echo hello\n  \n  RUN [\"executable\", \"param1\", \"param2\"] (exec form)\n  RUN [\"/bin/bash\", \"-c\", \"echo hello\"]\n  ```\n\n#### 9.3.4 EXPOSE 命令\n\n- 用来指定构建的镜像在运行为容器时对外暴露的端口\n\n- 语法:\n\n  ```dockerfile\n  EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp\n  EXPOSE 80/udp\n  ```\n\n#### 9.3.5 CMD 命令\n\n- 用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n- 注意: **Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。**\n\n- 语法:\n\n  ```dockerfile\n  CMD [\"executable\",\"param1\",\"param2\"] (exec form, this is the preferred form)\n  CMD [\"param1\",\"param2\"] (as default parameters to ENTRYPOINT)\n  CMD command param1 param2 (shell form)\n  ```\n\n#### 9.3.6 WORKDIR 命令\n\n- 用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。\n\n- 语法:\n\n  ```dockerfile\n  WORKDIR /path/to/workdir\n  \n  WORKDIR /a\n  WORKDIR b\n  WORKDIR c\n  `注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`\n  ```\n\n#### 9.3.7 ENV 命令\n\n- 用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。\n\n- 语法：\n\n  ```dockerfile\n  ENV <key> <value>\n  ENV <key>=<value> ...\n  ```\n\n#### 9.3.8 ADD 命令\n\n- 用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。\n\n- 语法:\n\n  ```dockerfile\n  ADD hom* /mydir/       通配符添加多个文件\n  ADD hom?.txt /mydir/   通配符添加\n  ADD test.txt relativeDir/  可以指定相对路径\n  ADD test.txt /absoluteDir/ 也可以指定绝对路径\n  ADD url \n  ```\n\n#### 9.3.9 COPY 命令\n\n- 用来将context目录中指定文件复制到镜像的指定目录中\n\n- 语法:\n\n  ```dockerfile\n  COPY src dest\n  COPY [\"<src>\",... \"<dest>\"]\n  ```\n\n#### 9.3.10 VOLUME 命令\n\n- 用来定义容器运行时可以挂在到宿主机的目录\n\n- 语法:\n\n  ```dockerfile\n  VOLUME [\"/data\"]\n  ```\n\n#### 9.3.11 ENTRYPOINT命令\n\n- 用来指定容器启动时执行命令和CMD类似\n\n- 语法:\n\n  ```dockerfile\n    [\"executable\", \"param1\", \"param2\"]\n  ENTRYPOINT command param1 param2\n  ```\n\n  ENTRYPOINT指令，往往用于设置容器启动后的**第一个命令**，这对一个容器来说往往是固定的。\n  CMD指令，往往用于设置容器启动的第一个命令的**默认参数**，这对一个容器来说可以是变化的。\n\n#### 9.3.11 ENTRYPOINT命令\n\n### 9.4 Dockerfile构建springboot项目部署\n\n##### 1.准备springboot可运行项目\n\n![image-20200605172151266](Docker_1.assets/image-20200605172151266.png)\n\n##### 2.将可运行项目放入linux虚拟机中\n\n![image-20200605172340380](Docker_1.assets/image-20200605172340380.png)\n\n##### 3.编写Dockerfile\n\n```dockerfile\nFROM openjdk:8\nWORKDIR /ems\nADD ems.jar /ems\nEXPOSE 8989\nENTRYPOINT [\"java\",\"-jar\"]\nCMD [\"ems.jar\"]\n```\n\n##### 4.构建镜像\n\n```shell\n[root@localhost ems]# docker build -t ems .\n```\n\n##### 5.运行镜像\n\n```shell\n[root@localhost ems]# docker run -p 8989:8989 ems\n```\n\n##### 6.访问项目\n\n```http\nhttp://10.15.0.8:8989/ems/login.html\n```\n\n![image-20200605173141636](Docker_1.assets/image-20200605173141636.png)\n\n---\n\n## 10.高级网络配置\n\n### 10.1 说明\n\n当 Docker 启动时，会自动在主机上创建一个 `docker0` 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n同时，Docker 随机分配一个本地未占用的私有网段（在 [RFC1918](https://tools.ietf.org/html/rfc1918) 中定义）中的一个地址给 `docker0` 接口。比如典型的 `172.17.42.1`，掩码为 `255.255.0.0`。此后启动的容器内的网口也会自动分配一个同一网段（`172.17.0.0/16`）的地址。\n\n当创建一个 Docker 容器的时候，同时会创建了一对 `veth pair` 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 `eth0`；另一端在本地并被挂载到 `docker0` 网桥，名称以 `veth` 开头（例如 `vethAQI2QT`）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。\n\n![image-20201125105847896](Docker_1.assets/image-20201125105847896.png)\n\n### 10.2 查看网络信息\n\n```markdown\n# docker network ls\n```\n\n### 10.3 创建一个网桥\n\n```markdown\n# docker network create -d bridge 网桥名称\n```\n\n### 10.4 删除一个网桥\n\n```markdown\n# docker network rm 网桥名称\n```\n\n### 10.5 容器之前使用网络通信\n\n```markdown\n# 1.查询当前网络配置\n- docker network ls\n```\n\n```shell\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n```\n\n```markdown\n# 2.创建桥接网络\n- docker network create -d bridge info\n```\n\n```shell\n[root@centos ~]# docker network create -d bridge info\n6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f\n[root@centos ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n8e424e5936b7        bridge              bridge              local\n17d974db02da        docker_gwbridge     bridge              local\nd6c326e433f7        host                host                local\n6e4aaebff79b        info                bridge              local\n```\n\n```markdown\n# 3.启动容器指定使用网桥\n- docker run -d -p 8890:80 --name nginx001 --network info nginx \n- docker run -d -p 8891:80 --name nginx002 --network info nginx \n	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`\n```\n\n```shell\n[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx \nc315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe\n[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx\nf8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5\n[root@centos ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nf8682db35dd7        nginx               \"/docker-entrypoint.…\"   3 seconds ago       Up 2 seconds        0.0.0.0:8891->80/tcp   nginx002\nc315bcc94e9d        nginx               \"/docker-entrypoint.…\"   7 minutes ago       Up 7 minutes        0.0.0.0:8890->80/tcp   nginx001\nb63169d43792        mysql:5.7.19        \"docker-entrypoint.s…\"   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda\n[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash\nroot@f8682db35dd7:/# curl http://nginx001\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n.....\n```\n\n---\n\n## 11.高级数据卷配置\n\n### 11.1 说明\n\n`数据卷` 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：\n\n- `数据卷` 可以在容器之间共享和重用\n- 对 `数据卷` 的修改会立马生效\n- 对 `数据卷` 的更新，不会影响镜像\n- `数据卷` 默认会一直存在，即使容器被删除\n\n> 注意：`数据卷` 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。\n\n### 11.2 创建数据卷\n\n```shell\n[root@centos ~]# docker volume create my-vol\nmy-vol\n```\n\n### 11.3 查看数据卷\n\n```shell\n[root@centos ~]# docker volume inspect my-vol       \n[\n    {\n        \"CreatedAt\": \"2020-11-25T11:43:56+08:00\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\",\n        \"Name\": \"my-vol\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n```\n\n### 11.4 挂载数据卷\n\n```shell\n[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx\n[root@centos ~]# docker inspect web\n				\"Mounts\": [\n            {\n                \"Type\": \"volume\",\n                \"Name\": \"my-vol\",\n                \"Source\": \"/var/lib/docker/volumes/my-vol/_data\",\n                \"Destination\": \"/usr/share/nginx/html\",\n                \"Driver\": \"local\",\n                \"Mode\": \"z\",\n                \"RW\": true,\n                \"Propagation\": \"\"\n            }\n        ],\n```\n\n### 11.5 删除数据卷\n\n```shell\ndocker volume rm my-vol\n```\n\n---\n\n## 12.Docker Compose\n\n### 12.1 简介\n\n`Compose` 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 `OpenStack` 中的 `Heat` 十分类似。\n\n其代码目前在 https://github.com/docker/compose 上开源。\n\n`Compose` 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。\n\n通过第一部分中的介绍，我们知道使用一个 `Dockerfile` 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。\n\n`Compose` 恰好满足了这样的需求。它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\n\n`Compose` 中有两个重要的概念：\n\n- 服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。\n\n`Compose` 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n`Compose` 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 `Compose` 来进行编排管理。\n\n### 12.2 安装与卸载\n\n###### 1.linux\n\n- 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。\n\n```bash\n$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n```\n\n###### 2.macos、window\n\n- Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。`Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用`。\n\n###### 3.bash命令补全\n\n```shell\n$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose\n```\n\n###### 4.卸载\n\n- 如果是二进制包方式安装的，删除二进制文件即可。\n\n```shell\n$ sudo rm /usr/local/bin/docker-compose\n```\n\n###### 5.测试安装成功\n\n```shell\n$ docker-compose --version\n docker-compose version 1.25.5, build 4667896b\n```\n\n### 12.3 docker compose使用\n\n```markdown\n# 1.相关概念\n```\n\n首先介绍几个术语。\n\n- 服务 (`service`)：一个应用容器，实际上可以运行多个相同镜像的实例。\n- 项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，`Compose` 面向项目进行管理。\n\n```markdown\n# 2.场景\n```\n\n最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。\n\n- springboot应用\n- mysql服务\n- redis服务\n- elasticsearch服务\n- .......\n\n````markdown\n# 3.docker-compose模板\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/compose_file.html\n````\n\n```yml\nversion: \"3.0\"\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - /root/mysql/conf:/etc/mysql/conf.d\n      - /root/mysql/logs:/logs\n      - /root/mysql/data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - \"6379:6379\"\n    networks:\n      - ems\n    volumes:\n      - /root/redis/data:/data\n    command: redis-server\n    \nnetworks:\n  ems:\n```\n\n```markdown\n# 4.通过docker-compose运行一组容器\n- 参考文档:https://docker_practice.gitee.io/zh-cn/compose/commands.html\n```\n\n```bash\n[root@centos ~]# docker-compose up    							//前台启动一组服务\n[root@centos ~]# docker-compose up -d 							//后台启动一组服务\n```\n\n---\n\n### 12.4 docker-compose 模板文件\n\n模板文件是使用 `Compose` 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 `docker run` 相关参数的含义都是类似的。\n\n默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式。\n\n```yaml\nversion: \"3\"\n\nservices:\n  webapp:\n    image: examples/web\n    ports:\n      - \"80:80\"\n    volumes:\n      - \"/data\"\n```\n\n注意每个服务都必须通过 `image` 指令指定镜像或 `build` 指令（需要 Dockerfile）等来自动构建生成镜像。\n\n如果使用 `build` 指令，在 `Dockerfile` 中设置的选项(例如：`CMD`, `EXPOSE`, `VOLUME`, `ENV` 等) 将会自动被获取，无需在 `docker-compose.yml` 中重复设置。\n\n下面分别介绍各个指令的用法。\n\n#### `build`\n\n指定 `Dockerfile` 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 `Compose` 将会利用它自动构建这个镜像，然后使用这个镜像。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build: ./dir\n```\n\n你也可以使用 `context` 指令指定 `Dockerfile` 所在文件夹的路径。\n\n使用 `dockerfile` 指令指定 `Dockerfile` 文件名。\n\n使用 `arg` 指令指定构建镜像时的变量。\n\n```yaml\nversion: \'3\'\nservices:\n\n  webapp:\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n```\n\n#### `command`\n\n覆盖容器启动后默认执行的命令。\n\n```yaml\ncommand: echo \"hello world\"\n```\n\n#### `container_name`\n\n指定容器名称。默认将会使用 `项目名称_服务名称_序号` 这样的格式。\n\n```yaml\ncontainer_name: docker-web-container\n```\n\n> 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。\n\n#### `depends_on`\n\n解决容器的依赖、启动先后的问题。以下例子中会先启动 `redis` `db` 再启动 `web`\n\n```yaml\nversion: \'3\'\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres\n```\n\n> 注意：`web` 服务不会等待 `redis` `db` 「完全启动」之后才启动。\n\n#### `env_file`\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果通过 `docker-compose -f FILE` 方式来指定 Compose 模板文件，则 `env_file` 中变量的路径会基于模板文件路径。\n\n如果有变量名称与 `environment` 指令冲突，则按照惯例，以后者为准。\n\n```bash\nenv_file: .env\n\nenv_file:\n  - ./common.env\n  - ./apps/web.env\n  - /opt/secrets.env\n```\n\n环境变量文件中每一行必须符合格式，支持 `#` 开头的注释行。\n\n```bash\n# common.env: Set development environment\nPROG_ENV=development\n```\n\n#### `environment`\n\n设置环境变量。你可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。\n\n```yaml\nenvironment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SESSION_SECRET\n```\n\n如果变量名称或者值中用到 `true|false，yes|no` 等表达 [布尔](https://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括\n\n```bash\ny|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF\n```\n\n#### `healthcheck`\n\n通过命令检查容器是否健康运行。\n\n```yaml\nhealthcheck:\n  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n```\n\n#### `image`\n\n指定为镜像名称或镜像 ID。如果镜像在本地不存在，`Compose` 将会尝试拉取这个镜像。\n\n```yaml\nimage: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n```\n\n#### `networks`\n\n配置容器连接的网络。\n\n```yaml\nversion: \"3\"\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:\n```\n\n#### `ports`\n\n暴露端口信息。\n\n使用宿主端口：容器端口 `(HOST:CONTAINER)` 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。\n\n```yaml\nports:\n - \"3000\"\n - \"8000:8000\"\n - \"49100:22\"\n - \"127.0.0.1:8001:8001\"\n```\n\n*注意：当使用 `HOST:CONTAINER` 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 `YAML` 会自动解析 `xx:yy` 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。*\n\n#### `sysctls`\n\n配置容器内核参数。\n\n```yaml\nsysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn=1024\n  - net.ipv4.tcp_syncookies=0\n```\n\n#### `ulimits`\n\n指定容器的 ulimits 限制值。\n\n例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。\n\n```yaml\n  ulimits:\n    nproc: 65535\n    nofile:\n      soft: 20000\n      hard: 40000\n```\n\n#### `volumes`\n\n数据卷所挂载路径设置。可以设置为宿主机路径(`HOST:CONTAINER`)或者数据卷名称(`VOLUME:CONTAINER`)，并且可以设置访问模式 （`HOST:CONTAINER:ro`）。\n\n该指令中路径支持相对路径。\n\n```yaml\nvolumes:\n - /var/lib/mysql\n - cache/:/tmp/cache\n - ~/configs:/etc/configs/:ro\n```\n\n如果路径为数据卷名称，必须在文件中配置数据卷。\n\n```yaml\nversion: \"3\"\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:/var/lib/mysql\n\nvolumes:\n  mysql_data:\n```\n\n---\n\n### 12.5 docker-compose 常用命令\n\n##### 1. 命令对象与格式\n\n对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。\n\n执行 `docker-compose [COMMAND] --help` 或者 `docker-compose help [COMMAND]` 可以查看具体某个命令的使用格式。\n\n`docker-compose` 命令的基本的使用格式是\n\n```bash\ndocker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]\n```\n\n##### 2. 命令选项\n\n- `-f, --file FILE` 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。\n- `-p, --project-name NAME` 指定项目名称，默认将使用所在目录名称作为项目名。\n- `--x-networking` 使用 Docker 的可拔插网络后端特性\n- `--x-network-driver DRIVER` 指定网络后端的驱动，默认为 `bridge`\n- `--verbose` 输出更多调试信息。\n- `-v, --version` 打印版本并退出。\n\n##### 3.命令使用说明\n\n##### `up`\n\n格式为 `docker-compose up [options] [SERVICE...]`。\n\n- 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。\n\n- 链接的服务都将会被自动启动，除非已经处于运行状态。\n\n- 可以说，大部分时候都可以直接通过该命令来启动一个项目。\n\n- 默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。\n\n- 当通过 `Ctrl-C` 停止命令时，所有容器将会停止。\n\n- 如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。\n\n- 默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 `volumes-from` 挂载的卷），以保证新启动的服务匹配 `docker-compose.yml` 文件的最新内容\n\n---\n\n##### `down`\n\n- 此命令将会停止 `up` 命令所启动的容器，并移除网络\n\n----\n\n##### `exec`\n\n- 进入指定的容器。\n\n----\n\n##### `ps`\n\n格式为 `docker-compose ps [options] [SERVICE...]`。\n\n列出项目中目前的所有容器。\n\n选项：\n\n- `-q` 只打印容器的 ID 信息。\n\n----\n\n##### `restart`\n\n格式为 `docker-compose restart [options] [SERVICE...]`。\n\n重启项目中的服务。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 指定重启前停止容器的超时（默认为 10 秒）。\n\n----\n\n##### `rm`\n\n格式为 `docker-compose rm [options] [SERVICE...]`。\n\n删除所有（停止状态的）服务容器。推荐先执行 `docker-compose stop` 命令来停止容器。\n\n选项：\n\n- `-f, --force` 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\n- `-v` 删除容器所挂载的数据卷。\n\n---\n\n##### `start`\n\n格式为 `docker-compose start [SERVICE...]`。\n\n启动已经存在的服务容器。\n\n----\n\n##### `stop`\n\n格式为 `docker-compose stop [options] [SERVICE...]`。\n\n停止已经处于运行状态的容器，但不删除它。通过 `docker-compose start` 可以再次启动这些容器。\n\n选项：\n\n- `-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。\n\n----\n\n##### `top`\n\n查看各个服务容器内运行的进程。\n\n---\n\n##### `unpause`\n\n格式为 `docker-compose unpause [SERVICE...]`。\n\n恢复处于暂停状态中的服务。\n\n------\n\n## 13.docker可视化工具\n\n#### 13.1 安装Portainer\n\n官方安装说明：[https://www.portainer.io/installation/](http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=)\n\n```shell\n[root@ubuntu1804 ~]#docker pull  portainer/portainer\n\n[root@ubuntu1804 ~]#docker volume create portainer_data\nportainer_data\n[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3\n[root@ubuntu1804 ~]#docker ps \nCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES\n20db26b67b79        portainer/portainer   \"/portainer\"        5 seconds ago       Up 4 seconds        0.0.0.0:8000->8000/tcp, 0.0.0.0:9000->9000/tcp   portainer\n```\n\n#### 13.2 登录和使用Portainer\n\n> 用浏览器访问：`http://localhost:9000`\n\n![image-20201223231707738](Docker_1.assets/image-20201223231707738.png)\n\n----\n\n', 'Docker_1', 1, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 13:58:20', 1, '2023-02-22 13:39:15', 1);
INSERT INTO `lzh_article` VALUES (1627911270841741313, 'Maven', '<h1><a id=\"Maven__0\"></a>Maven 自动化的构建工具</h1>\n<h1><a id=\"_Maven_2\"></a>第一章 Maven简介</h1>\n<h2><a id=\"11__4\"></a>1.1 软件开发中的阶段</h2>\n<p>需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。</p>\n<p>设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。</p>\n<p>开发阶段：编码实现功能。 编译代码。自我测试</p>\n<p>测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。</p>\n<p>项目的打包，发布阶段： 给用户安装项目</p>\n<h2><a id=\"12_Maven_18\"></a>1.2 Maven能做什么</h2>\n<p>1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。</p>\n<p>2）管理依赖（管理项目中使用的各种jar包）。</p>\n<p>​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。</p>\n<h2><a id=\"13_maven_28\"></a>1.3 没有使用maven怎么管理依赖</h2>\n<p>管理jar ，需要从网络中单独下载某个jar</p>\n<p>需要选择正确版本</p>\n<p>手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。</p>\n<h2><a id=\"14_maven_38\"></a>1.4 什么是maven</h2>\n<p>maven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[\'meɪv(ə)n]  或  [\'mevn]。</p>\n<p>maven是项目的自动化构建工具。 管理项目的依赖。</p>\n<h2><a id=\"15_maven_46\"></a>1.5 maven中的概念</h2>\n<p>①POM<br />\n②约定的目录结构<br />\n③坐标<br />\n④依赖管理<br />\n⑤仓库管理<br />\n⑥生命周期<br />\n⑦插件和目标<br />\n⑧继承<br />\n⑨聚合</p>\n<h2><a id=\"16_maven_60\"></a>1.6 maven工具的获取和安装</h2>\n<p>地址： http://maven.apache.org/  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip</p>\n<p>安装：</p>\n<ol>\n<li>\n<p>确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录</p>\n</li>\n<li>\n<p>解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。</p>\n<p>目录的路径不要有中文， 不要有空格。</p>\n</li>\n<li>\n<p>把maven安装目录中下的bin的路径添加到path中</p>\n</li>\n<li>\n<p>测试maven的安装。 在命令行执行 mvn     -v</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">C:\\Users\\NING MEI&gt;mvn -v\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\nMaven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\nJava version: 1.8.0_101, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;\n</code></div></pre>\n</li>\n</ol>\n<p>maven解压后的目录结构</p>\n<p><img src=\"images/image-20201015162301261.png\" alt=\"image-20201015162301261\" /></p>\n<p>maven的其他安装方式：</p>\n<ol>\n<li>\n<p>确定JAVA_HOME是否有效</p>\n</li>\n<li>\n<p>在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录</p>\n<p>M2_HOME=D:\\tools\\apache-maven-3.3.9</p>\n</li>\n<li>\n<p>在path环境变量中，加入 %M2_HOME%\\bin</p>\n</li>\n<li>\n<p>测试maven的安装，再命令行执行 mvn  -v</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">C:\\Users\\NING MEI&gt;mvn -v\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\nMaven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\nJava version: 1.8.0_101, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;\n</code></div></pre>\n</li>\n</ol>\n<h1><a id=\"Maven_120\"></a>第二章Maven的核心概念</h1>\n<h2><a id=\"21__122\"></a>2.1 约定的目录结构</h2>\n<p>maven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。</p>\n<p>一个maven项目是一个文件夹。 比如项目叫做Hello</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\">Hello 项目文件夹\n    \\src\n    	\\main				叫做主程序目录（完成项目功能的代码和配置文件）\n             \\java          源代码（包和相关的类定义）\n    		 \\resources	    配置文件\n    	\\test               放置测试程序代码的（开发人员自己写的测试代码）\n    		 \\java          测试代码的（junit）\n    		 \\resources     测试程序需要的配置文件\n    \\pom.xml                maven的配置文件， 核心文件\n</code></div></pre>\n<p>maven的使用方式：</p>\n<p>1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等</p>\n<p>2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等</p>\n<h2><a id=\"22_POM_150\"></a>2.2 POM</h2>\n<p>POM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。</p>\n<p>maven通过pom.xml文件实现 项目的构建和依赖的管理。</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">\n<span class=\"hljs-meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- project是根标签， 后面的是约束文件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>\n  <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>\n    \n    \n  <span class=\"hljs-comment\">&lt;!-- pom模型的版本， 就是4.0.0 --&gt;</span>  \n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n  <span class=\"hljs-comment\">&lt;!-- 坐标 --&gt;</span>  \n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.bjpowernode<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>ch01-maven<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n  \n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n  \n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<h2><a id=\"23__184\"></a>2.3 坐标</h2>\n<p>坐标组成是 groupid, artifiactId, version。  坐标概念来自数学。·</p>\n<p>坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.bjpowernode<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>ch01-maven<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">packaging</span>&gt;</span>jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">packaging</span>&gt;</span>\n\ngroupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。\n         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode\n\n         如果项目规模比较大， 也可以是 域名倒写+大项目名称。\n	     例如： www.baidu.com ,  无人车： com.baidu.appollo\nartifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。\nversion：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。\n         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      \n   \npackaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar\n</code></div></pre>\n<p>项目使用gav：</p>\n<p>1.每个maven项目，都需要有一个自己的gav</p>\n<p>2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。</p>\n<p>搜索坐标的地址： https://mvnrepository.com/</p>\n<h2><a id=\"24__dependency_220\"></a>2.4 依赖 dependency</h2>\n<p>依赖：项目中要使用的其他资源（jar）。</p>\n<p>需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用</p>\n<p>需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。</p>\n<p>格式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n  \n    <span class=\"hljs-comment\">&lt;!-- 日志 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>log4j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>log4j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.2.17<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    \n    <span class=\"hljs-comment\">&lt;!-- mysql驱动 --&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>mysql<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>5.1.16<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span> \n\nmaven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar\n</code></div></pre>\n<h2><a id=\"25__253\"></a>2.5 仓库</h2>\n<p>仓库是存东西的，maven的仓库存放的是：</p>\n<ol>\n<li>\n<p>maven工具自己的jar包。</p>\n</li>\n<li>\n<p>第三方的其他jar， 比如项目中要使用mysql驱动。</p>\n</li>\n<li>\n<p>自己写的程序，可以打包为jar 。 存放到仓库。</p>\n</li>\n</ol>\n<p>仓库的分类：</p>\n<ol>\n<li>\n<p>本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。</p>\n<p>本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">     C:\\Users\\NING MEI\\.m2\\repository\n</code></div></pre>\n<p>修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\\conf\\setting.xml）</p>\n<p>​	步骤：</p>\n<p>​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。</p>\n<p>​		   例如： D:\\openrepository</p>\n<p>​     2）修改setting.xml文件，指定 D:\\openrepository这个目录</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">localRepository</span>&gt;</span>D:/openrepository<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">localRepository</span>&gt;</span>\n</code></div></pre>\n<p>​    3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository</p>\n</li>\n<li>\n<p>远程仓库： 需要通过联网访问的</p>\n<p>1）中央仓库： 一个ftp服务器， 存放了所有的资源。</p>\n<p>2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。</p>\n<p>3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。</p>\n</li>\n</ol>\n<p>maven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。</p>\n<p><img src=\"images/image-20201016114322189.png\" alt=\"image-20201016114322189\" /></p>\n<h2><a id=\"26_maven_313\"></a>2.6 maven的生命周期，插件和命令</h2>\n<p>maven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署</p>\n<p>插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。</p>\n<p>命令： 执行maven功能是 由命令发出的。 比如 mvn compile</p>\n<p>单元测试（junit）：</p>\n<p>junit是一个单元测试的工具， 在java中经常使用。</p>\n<p>单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。</p>\n<p>作用：使用junit去测试方法是否完成了要求。 开发人员自测。</p>\n<p>使用单元测试：</p>\n<p>1）加入junit的依赖（一些类和方法）</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>junit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>junit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.12<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n</code></div></pre>\n<p>2)在src/test/java 目录中创建测试类文件。 写测试代码</p>\n<p>单元测试使用的建议：</p>\n<p>​    1.测试类的定义， 名称一般是Test+要测试的类名称</p>\n<p>​    2.测试类它的包名和要测试的类包名一样。</p>\n<p>​    3.在类中定义方法，要测试代码。</p>\n<p>​       方法的定义：public方法，</p>\n<p>​                               没有返回值</p>\n<p>​                               方法名称自定义（建议 Test+测试的方法名称）</p>\n<p>​                               方法没有参数</p>\n<p>4.在测试类中的方法，可以单独执行。 测试类也可以单独执行</p>\n<p>5.在方法的上面加入@Test</p>\n<p>命令：</p>\n<p>1） mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。</p>\n<p>​      插件： maven-clean-plugin   ， 版本是 2.5</p>\n<p>2）mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。</p>\n<p>​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）</p>\n<p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p>\n<p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的</p>\n<p>​                                                             文件拷贝target/classes目录中。</p>\n<p>3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录</p>\n<p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p>\n<p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的</p>\n<p>4）mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。</p>\n<p>​     插件： maven-surefire-plugin 版本 2.12.4</p>\n<p>5）mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。</p>\n<p>​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.</p>\n<p>​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。</p>\n<p>​    生成的是 ch01-maven-1.0-SNAPSHOT.jar</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.bjpowernode<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>ch01-maven<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">packaging</span>&gt;</span>jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">packaging</span>&gt;</span>\n打包的文件名： artifactId-version.packaging\n</code></div></pre>\n<p>6）mvn install : 把生成的打包的文件 ，安装到maven仓库。</p>\n<p>​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。</p>\n<p>​    查看查看中的jar文件：</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.bjpowernode<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>ch01-maven<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">packaging</span>&gt;</span>jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">packaging</span>&gt;</span>\n\ngroupId中的值， 如果有 &quot;.&quot; 前和后都是独立的文件夹。 com\\bjpowernode\nartifactId, 独立的文件夹\nversion，独立的文件夹\n</code></div></pre>\n<h2><a id=\"27__444\"></a>2.7 自定义配置插件</h2>\n<p>在pom.xml文件中， build标签中。设置插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-comment\">&lt;!-- 设置构建项目相关的内容 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 设置插件 --&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.8.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">source</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">source</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- 指定编译代码的jdk版本 --&gt;</span>\n			<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">target</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">target</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- 运行java程序使用的jdk版本--&gt;</span>\n		<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n	<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span> \n</code></div></pre>\n<h1><a id=\"_Mavenidea_469\"></a>第三章 Maven和idea的集成</h1>\n<h2><a id=\"31_ideamaven_471\"></a>3.1 idea中集成maven</h2>\n<p>idea中有一个自带的maven。  我们要让idea使用自己安装的maven。</p>\n<ol>\n<li>选择File- Settings</li>\n</ol>\n<p><img src=\"images/image-20201016151034872.png\" alt=\"image-20201016151034872\" /></p>\n<p><img src=\"images/image-20201016151528678.png\" alt=\"image-20201016151528678\" /></p>\n<p>设置项： -DarchetypeCatalog=internal</p>\n<p>2） File - Other Settings</p>\n<p><img src=\"images/image-20201016151823967.png\" alt=\"image-20201016151823967\" /></p>\n<p>同上的设置</p>\n<h2><a id=\"32_mavenjava_493\"></a>3.2 创建基于maven的普通java项目</h2>\n<p><img src=\"images/image-20201016161028977.png\" alt=\"image-20201016161028977\" /></p>\n<h2><a id=\"33_web_499\"></a>3.3 创建web项目</h2>\n<p><img src=\"images/image-20201016170153694.png\" alt=\"image-20201016170153694\" /></p>\n<h2><a id=\"34_moduleidea_503\"></a>3.4 导入module到idea</h2>\n<p><img src=\"images/image-20201017085816226.png\" alt=\"image-20201017085816226\" /></p>\n<h1><a id=\"4___511\"></a>4. 第四章 依赖管理</h1>\n<p>依赖范围：使用scope表示依赖的范围。</p>\n<p>依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。</p>\n<p>依赖范围scope ：</p>\n<p>​     compile:默认， 参与构建项目的所有阶段</p>\n<p>​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。</p>\n<p>​    provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包</p>\n<p>​					  明显的是servlet 和jsp 依赖</p>\n<h1><a id=\"5___529\"></a>5. 第五章 常用设置</h1>\n<p>1)讲的是properties它里面的配置</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span> 源码编译 jdk 版本\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span> 运行代码的 jdk 版本\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span> 项目\n构建使用的编码，避免中文乱码\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span> 生成报告的编码\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n</code></div></pre>\n<ol start=\"2\">\n<li>全局变量</li>\n</ol>\n<p>在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。</p>\n<p>使用全局变量表示 多个依赖使用的版本号。</p>\n<p>使用步骤：</p>\n<p>1.在properties标签中，定义一个标签，指定版本的值</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!--自定义变量--&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">spring.version</span>&gt;</span>5.2.5.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">spring.version</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">junit.version</span>&gt;</span>4.11<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">junit.version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n</code></div></pre>\n<ol start=\"2\">\n<li>使用全局变量， 语法 ${变量名}</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-core<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${spring.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${spring.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p>3）使用资源插件</p>\n<p>处理的配置文件的信息， maven默认处理配置文件</p>\n<p>①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下</p>\n<p>②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!--资源插件\n      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。\n  --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">resources</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">resource</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">directory</span>&gt;</span>src/main/java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">directory</span>&gt;</span><span class=\"hljs-comment\">&lt;!--所在的目录--&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">includes</span>&gt;</span>\n      <span class=\"hljs-comment\">&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">include</span>&gt;</span>**/*.properties<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">include</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">include</span>&gt;</span>**/*.xml<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">include</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">includes</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!--  filtering 选项 false 不启用过滤器， *.property 已经起到过\n        滤的作用了 --&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filtering</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filtering</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">resource</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">resources</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n', '# Maven 自动化的构建工具\r\n\r\n#  第一章 Maven简介\r\n\r\n## 1.1 软件开发中的阶段\r\n\r\n需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。\r\n\r\n设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。\r\n\r\n开发阶段：编码实现功能。 编译代码。自我测试\r\n\r\n测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。\r\n\r\n项目的打包，发布阶段： 给用户安装项目\r\n\r\n\r\n\r\n## 1.2 Maven能做什么\r\n\r\n1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。\r\n\r\n2）管理依赖（管理项目中使用的各种jar包）。\r\n\r\n​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。\r\n\r\n\r\n\r\n## 1.3 没有使用maven怎么管理依赖\r\n\r\n管理jar ，需要从网络中单独下载某个jar \r\n\r\n需要选择正确版本\r\n\r\n手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。\r\n\r\n\r\n\r\n## 1.4 什么是maven\r\n\r\nmaven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[\'meɪv(ə)n]  或  [\'mevn]。\r\n\r\nmaven是项目的自动化构建工具。 管理项目的依赖。\r\n\r\n\r\n\r\n## 1.5 maven中的概念\r\n\r\n①POM\r\n②约定的目录结构\r\n③坐标\r\n④依赖管理\r\n⑤仓库管理\r\n⑥生命周期\r\n⑦插件和目标\r\n⑧继承\r\n⑨聚合\r\n\r\n\r\n\r\n## 1.6 maven工具的获取和安装\r\n\r\n地址： http://maven.apache.org/  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip\r\n\r\n\r\n\r\n安装：\r\n\r\n1. 确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录\r\n\r\n2. 解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。 \r\n\r\n   目录的路径不要有中文， 不要有空格。\r\n\r\n3. 把maven安装目录中下的bin的路径添加到path中\r\n\r\n4. 测试maven的安装。 在命令行执行 mvn     -v\r\n\r\n   ```xml\r\n   C:\\Users\\NING MEI>mvn -v\r\n   Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\r\n   Maven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\r\n   Java version: 1.8.0_101, vendor: Oracle Corporation\r\n   Java home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\r\n   Default locale: zh_CN, platform encoding: GBK\r\n   OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\r\n   ```\r\n\r\n   \r\n\r\nmaven解压后的目录结构\r\n\r\n![image-20201015162301261](images/image-20201015162301261.png)	\r\n\r\n\r\n\r\nmaven的其他安装方式：\r\n\r\n1. 确定JAVA_HOME是否有效\r\n\r\n2. 在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录\r\n\r\n   M2_HOME=D:\\tools\\apache-maven-3.3.9\r\n\r\n3. 在path环境变量中，加入 %M2_HOME%\\bin    \r\n\r\n4. 测试maven的安装，再命令行执行 mvn  -v\r\n\r\n   ```xml\r\n   C:\\Users\\NING MEI>mvn -v\r\n   Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\r\n   Maven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\r\n   Java version: 1.8.0_101, vendor: Oracle Corporation\r\n   Java home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\r\n   Default locale: zh_CN, platform encoding: GBK\r\n   OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\r\n   ```\r\n\r\n   \r\n\r\n# 第二章Maven的核心概念\r\n\r\n## 2.1 约定的目录结构\r\n\r\nmaven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。\r\n\r\n一个maven项目是一个文件夹。 比如项目叫做Hello\r\n\r\n```java\r\nHello 项目文件夹\r\n    \\src\r\n    	\\main				叫做主程序目录（完成项目功能的代码和配置文件）\r\n             \\java          源代码（包和相关的类定义）\r\n    		 \\resources	    配置文件\r\n    	\\test               放置测试程序代码的（开发人员自己写的测试代码）\r\n    		 \\java          测试代码的（junit）\r\n    		 \\resources     测试程序需要的配置文件\r\n    \\pom.xml                maven的配置文件， 核心文件\r\n```\r\n\r\n\r\n\r\nmaven的使用方式：\r\n\r\n1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等\r\n\r\n2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等\r\n\r\n\r\n\r\n## 2.2 POM \r\n\r\nPOM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。\r\n\r\nmaven通过pom.xml文件实现 项目的构建和依赖的管理。\r\n\r\n```xml\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<!-- project是根标签， 后面的是约束文件 -->\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    \r\n    \r\n  <!-- pom模型的版本， 就是4.0.0 -->  \r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <!-- 坐标 -->  \r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  \r\n  <properties>\r\n     <java.version>1.8</java.version>\r\n     <maven.compiler.source>1.8</maven.compiler.source>\r\n     <maven.compiler.target>1.8</maven.compiler.target>\r\n  </properties>\r\n  \r\n</project>\r\n```\r\n\r\n\r\n\r\n## 2.3 坐标\r\n\r\n坐标组成是 groupid, artifiactId, version。  坐标概念来自数学。·\r\n\r\n坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n\r\ngroupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。\r\n         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode\r\n\r\n         如果项目规模比较大， 也可以是 域名倒写+大项目名称。\r\n	     例如： www.baidu.com ,  无人车： com.baidu.appollo\r\nartifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。\r\nversion：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。\r\n         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      \r\n   \r\npackaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar\r\n```\r\n\r\n项目使用gav：\r\n\r\n1.每个maven项目，都需要有一个自己的gav\r\n\r\n2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。\r\n\r\n\r\n\r\n搜索坐标的地址： https://mvnrepository.com/\r\n\r\n\r\n\r\n## 2.4 依赖 dependency\r\n\r\n依赖：项目中要使用的其他资源（jar）。  \r\n\r\n需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用\r\n\r\n需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。\r\n\r\n格式：\r\n\r\n```xml\r\n\r\n<dependencies>\r\n  \r\n    <!-- 日志 -->\r\n    <dependency>\r\n        <groupId>log4j</groupId>\r\n        <artifactId>log4j</artifactId>\r\n        <version>1.2.17</version>\r\n    </dependency>\r\n    \r\n    <!-- mysql驱动 -->\r\n     <dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n        <version>5.1.16</version>\r\n    </dependency>\r\n\r\n</dependencies> \r\n\r\nmaven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar\r\n```\r\n\r\n## 2.5 仓库\r\n\r\n仓库是存东西的，maven的仓库存放的是：\r\n\r\n1. maven工具自己的jar包。\r\n\r\n2. 第三方的其他jar， 比如项目中要使用mysql驱动。\r\n\r\n3. 自己写的程序，可以打包为jar 。 存放到仓库。\r\n\r\n   \r\n\r\n仓库的分类：\r\n\r\n1. 本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。\r\n\r\n   本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository\r\n\r\n   ```xml\r\n        C:\\Users\\NING MEI\\.m2\\repository\r\n   ```\r\n\r\n   \r\n\r\n   修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\\conf\\setting.xml）\r\n\r\n   ​	步骤：\r\n\r\n   ​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。\r\n\r\n   ​		   例如： D:\\openrepository\r\n\r\n   ​     2）修改setting.xml文件，指定 D:\\openrepository这个目录\r\n\r\n   ```xml\r\n       <localRepository>D:/openrepository</localRepository>\r\n   ```\r\n\r\n   ​    3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository\r\n\r\n     \r\n\r\n   \r\n\r\n2. 远程仓库： 需要通过联网访问的\r\n\r\n   1）中央仓库： 一个ftp服务器， 存放了所有的资源。 \r\n\r\n   2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。\r\n\r\n   3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。\r\n\r\n\r\n\r\nmaven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。\r\n\r\n\r\n\r\n![image-20201016114322189](images/image-20201016114322189.png)	\r\n\r\n## 2.6 maven的生命周期，插件和命令\r\n\r\nmaven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署\r\n\r\n插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。\r\n\r\n命令： 执行maven功能是 由命令发出的。 比如 mvn compile\r\n\r\n\r\n\r\n单元测试（junit）：\r\n\r\njunit是一个单元测试的工具， 在java中经常使用。\r\n\r\n单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。\r\n\r\n作用：使用junit去测试方法是否完成了要求。 开发人员自测。\r\n\r\n\r\n\r\n使用单元测试：\r\n\r\n1）加入junit的依赖（一些类和方法）\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>junit</groupId>\r\n    <artifactId>junit</artifactId>\r\n    <version>4.12</version>\r\n    <scope>test</scope>\r\n</dependency>\r\n\r\n```\r\n\r\n\r\n\r\n2)在src/test/java 目录中创建测试类文件。 写测试代码\r\n\r\n   单元测试使用的建议：\r\n\r\n​    1.测试类的定义， 名称一般是Test+要测试的类名称\r\n\r\n​    2.测试类它的包名和要测试的类包名一样。\r\n\r\n​    3.在类中定义方法，要测试代码。\r\n\r\n​       方法的定义：public方法， \r\n\r\n​                               没有返回值\r\n\r\n​                               方法名称自定义（建议 Test+测试的方法名称）\r\n\r\n​                               方法没有参数\r\n\r\n   4.在测试类中的方法，可以单独执行。 测试类也可以单独执行\r\n\r\n   5.在方法的上面加入@Test\r\n\r\n\r\n\r\n命令：\r\n\r\n1） mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。\r\n\r\n​      插件： maven-clean-plugin   ， 版本是 2.5\r\n\r\n2）mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。\r\n\r\n​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）\r\n\r\n\r\n\r\n​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件\r\n\r\n​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的                \r\n\r\n​                                                             文件拷贝target/classes目录中。\r\n\r\n3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录\r\n\r\n​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件\r\n\r\n​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的\r\n\r\n\r\n\r\n4）mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。\r\n\r\n​     插件： maven-surefire-plugin 版本 2.12.4\r\n\r\n\r\n\r\n5）mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。\r\n\r\n​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.\r\n\r\n​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。\r\n\r\n\r\n\r\n​    生成的是 ch01-maven-1.0-SNAPSHOT.jar\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n打包的文件名： artifactId-version.packaging\r\n```\r\n\r\n\r\n\r\n6）mvn install : 把生成的打包的文件 ，安装到maven仓库。\r\n\r\n​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。 \r\n\r\n​    查看查看中的jar文件：\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n\r\ngroupId中的值， 如果有 \".\" 前和后都是独立的文件夹。 com\\bjpowernode\r\nartifactId, 独立的文件夹\r\nversion，独立的文件夹\r\n```\r\n\r\n\r\n\r\n   ## 2.7 自定义配置插件\r\n\r\n在pom.xml文件中， build标签中。设置插件\r\n\r\n  \r\n\r\n```xml\r\n<!-- 设置构建项目相关的内容 -->\r\n<build>\r\n  <plugins>\r\n    <!-- 设置插件 -->\r\n	<plugin>\r\n		<groupId>org.apache.maven.plugins</groupId>\r\n		<artifactId>maven-compiler-plugin</artifactId>\r\n		<version>3.8.1</version>\r\n		<configuration>\r\n			<source>1.8</source> <!-- 指定编译代码的jdk版本 -->\r\n			<target>1.8</target> <!-- 运行java程序使用的jdk版本-->\r\n		</configuration>\r\n	</plugin>\r\n  </plugins>\r\n</build> \r\n```\r\n\r\n\r\n# 第三章 Maven和idea的集成\r\n\r\n## 3.1 idea中集成maven\r\n\r\nidea中有一个自带的maven。  我们要让idea使用自己安装的maven。\r\n\r\n1) 选择File- Settings \r\n\r\n![image-20201016151034872](images/image-20201016151034872.png)	\r\n\r\n![image-20201016151528678](images/image-20201016151528678.png)	\r\n\r\n设置项： -DarchetypeCatalog=internal\r\n\r\n\r\n\r\n2） File - Other Settings\r\n\r\n![image-20201016151823967](images/image-20201016151823967.png)\r\n\r\n同上的设置\r\n\r\n\r\n\r\n## 3.2 创建基于maven的普通java项目\r\n\r\n![image-20201016161028977](images/image-20201016161028977.png)	\r\n\r\n\r\n\r\n## 3.3 创建web项目\r\n\r\n![image-20201016170153694](images/image-20201016170153694.png)	\r\n\r\n## 3.4 导入module到idea\r\n\r\n\r\n\r\n![image-20201017085816226](images/image-20201017085816226.png)	\r\n\r\n\r\n\r\n# 4. 第四章 依赖管理\r\n\r\n依赖范围：使用scope表示依赖的范围。 \r\n\r\n依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。\r\n\r\n依赖范围scope ：\r\n\r\n​     compile:默认， 参与构建项目的所有阶段\r\n\r\n​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。\r\n\r\n​    provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包\r\n\r\n​					  明显的是servlet 和jsp 依赖\r\n\r\n\r\n\r\n# 5. 第五章 常用设置\r\n\r\n1)讲的是properties它里面的配置\r\n\r\n```xml\r\n<properties>\r\n<maven.compiler.source>1.8</maven.compiler.source> 源码编译 jdk 版本\r\n<maven.compiler.target>1.8</maven.compiler.target> 运行代码的 jdk 版本\r\n<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> 项目\r\n构建使用的编码，避免中文乱码\r\n<project.reporting.outputEncoding>UTF-8\r\n</project.reporting.outputEncoding> 生成报告的编码\r\n</properties>\r\n```\r\n\r\n\r\n\r\n2) 全局变量\r\n\r\n在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。 \r\n\r\n使用全局变量表示 多个依赖使用的版本号。\r\n\r\n\r\n\r\n使用步骤：\r\n\r\n1.在properties标签中，定义一个标签，指定版本的值\r\n\r\n```xml\r\n<properties>\r\n  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n  <maven.compiler.source>1.8</maven.compiler.source>\r\n  <maven.compiler.target>1.8</maven.compiler.target>\r\n  <!--自定义变量-->\r\n  <spring.version>5.2.5.RELEASE</spring.version>\r\n  <junit.version>4.11</junit.version>\r\n</properties>\r\n```\r\n\r\n\r\n\r\n2. 使用全局变量， 语法 ${变量名}\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>org.springframework</groupId>\r\n  <artifactId>spring-core</artifactId>\r\n  <version>${spring.version}</version>\r\n</dependency>\r\n\r\n<dependency>\r\n  <groupId>org.springframework</groupId>\r\n  <artifactId>spring-web</artifactId>\r\n  <version>${spring.version}</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n3）使用资源插件\r\n\r\n处理的配置文件的信息， maven默认处理配置文件\r\n\r\n①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下\r\n\r\n②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。\r\n\r\n\r\n\r\n```xml\r\n<build>\r\n  <!--资源插件\r\n      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。\r\n  -->\r\n  <resources>\r\n    <resource>\r\n      <directory>src/main/java</directory><!--所在的目录-->\r\n      <includes>\r\n      <!--包括目录下的.properties,.xml 文件都会扫描到-->\r\n        <include>**/*.properties</include>\r\n        <include>**/*.xml</include>\r\n      </includes>\r\n        <!--  filtering 选项 false 不启用过滤器， *.property 已经起到过\r\n        滤的作用了 -->\r\n      <filtering>false</filtering>\r\n    </resource>\r\n  </resources>\r\n</build>\r\n```\r\n\r\n', 'Maven', 15, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 14:01:07', 1, '2023-02-22 13:39:34', 1);
INSERT INTO `lzh_article` VALUES (1627912236588675074, 'Maven', '<h1>Maven 自动化的构建工具</h1>\n<h1>第一章 Maven简介</h1>\n<h2>1.1 软件开发中的阶段</h2>\n<p>需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。</p>\n<p>设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。</p>\n<p>开发阶段：编码实现功能。 编译代码。自我测试</p>\n<p>测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。</p>\n<p>项目的打包，发布阶段： 给用户安装项目</p>\n<h2>1.2 Maven能做什么</h2>\n<p>1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。</p>\n<p>2）管理依赖（管理项目中使用的各种jar包）。</p>\n<p>​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。</p>\n<h2>1.3 没有使用maven怎么管理依赖</h2>\n<p>管理jar ，需要从网络中单独下载某个jar</p>\n<p>需要选择正确版本</p>\n<p>手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。</p>\n<h2>1.4 什么是maven</h2>\n<p>maven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[\'meɪv(ə)n]  或  [\'mevn]。</p>\n<p>maven是项目的自动化构建工具。 管理项目的依赖。</p>\n<h2>1.5 maven中的概念</h2>\n<p>①POM\n②约定的目录结构\n③坐标\n④依赖管理\n⑤仓库管理\n⑥生命周期\n⑦插件和目标\n⑧继承\n⑨聚合</p>\n<h2>1.6 maven工具的获取和安装</h2>\n<p>地址： http://maven.apache.org/  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip</p>\n<p>安装：</p>\n<ol>\n<li>\n<p>确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录</p>\n</li>\n<li>\n<p>解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。</p>\n<p>目录的路径不要有中文， 不要有空格。</p>\n</li>\n<li>\n<p>把maven安装目录中下的bin的路径添加到path中</p>\n</li>\n<li>\n<p>测试maven的安装。 在命令行执行 mvn     -v</p>\n<pre><code class=\"language-xml\">C:\\Users\\NING MEI&gt;mvn -v\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\nMaven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\nJava version: 1.8.0_101, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;\n</code></pre>\n</li>\n</ol>\n<p>maven解压后的目录结构</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010151623012611676959478388.png\" alt=\"image-20201015162301261\" /></p>\n<p>maven的其他安装方式：</p>\n<ol>\n<li>\n<p>确定JAVA_HOME是否有效</p>\n</li>\n<li>\n<p>在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录</p>\n<p>M2_HOME=D:\\tools\\apache-maven-3.3.9</p>\n</li>\n<li>\n<p>在path环境变量中，加入 %M2_HOME%\\bin</p>\n</li>\n<li>\n<p>测试maven的安装，再命令行执行 mvn  -v</p>\n<pre><code class=\"language-xml\">C:\\Users\\NING MEI&gt;mvn -v\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\nMaven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\nJava version: 1.8.0_101, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;\n</code></pre>\n</li>\n</ol>\n<h1>第二章Maven的核心概念</h1>\n<h2>2.1 约定的目录结构</h2>\n<p>maven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。</p>\n<p>一个maven项目是一个文件夹。 比如项目叫做Hello</p>\n<pre><code class=\"language-java\">Hello 项目文件夹\n    \\src\n    	\\main				叫做主程序目录（完成项目功能的代码和配置文件）\n             \\java          源代码（包和相关的类定义）\n    		 \\resources	    配置文件\n    	\\test               放置测试程序代码的（开发人员自己写的测试代码）\n    		 \\java          测试代码的（junit）\n    		 \\resources     测试程序需要的配置文件\n    \\pom.xml                maven的配置文件， 核心文件\n</code></pre>\n<p>maven的使用方式：</p>\n<p>1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等</p>\n<p>2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等</p>\n<h2>2.2 POM</h2>\n<p>POM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。</p>\n<p>maven通过pom.xml文件实现 项目的构建和依赖的管理。</p>\n<pre><code class=\"language-xml\">\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;!-- project是根标签， 后面的是约束文件 --&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    \n    \n  &lt;!-- pom模型的版本， 就是4.0.0 --&gt;  \n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;!-- 坐标 --&gt;  \n  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  \n  &lt;properties&gt;\n     &lt;java.version&gt;1.8&lt;/java.version&gt;\n     &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n     &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n  &lt;/properties&gt;\n  \n&lt;/project&gt;\n</code></pre>\n<h2>2.3 坐标</h2>\n<p>坐标组成是 groupid, artifiactId, version。  坐标概念来自数学。·</p>\n<p>坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav</p>\n<pre><code class=\"language-xml\">  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n\ngroupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。\n         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode\n\n         如果项目规模比较大， 也可以是 域名倒写+大项目名称。\n	     例如： www.baidu.com ,  无人车： com.baidu.appollo\nartifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。\nversion：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。\n         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      \n   \npackaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar\n</code></pre>\n<p>项目使用gav：</p>\n<p>1.每个maven项目，都需要有一个自己的gav</p>\n<p>2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。</p>\n<p>搜索坐标的地址： https://mvnrepository.com/</p>\n<h2>2.4 依赖 dependency</h2>\n<p>依赖：项目中要使用的其他资源（jar）。</p>\n<p>需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用</p>\n<p>需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。</p>\n<p>格式：</p>\n<pre><code class=\"language-xml\">\n&lt;dependencies&gt;\n  \n    &lt;!-- 日志 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n        &lt;version&gt;1.2.17&lt;/version&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!-- mysql驱动 --&gt;\n     &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;version&gt;5.1.16&lt;/version&gt;\n    &lt;/dependency&gt;\n\n&lt;/dependencies&gt; \n\nmaven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar\n</code></pre>\n<h2>2.5 仓库</h2>\n<p>仓库是存东西的，maven的仓库存放的是：</p>\n<ol>\n<li>\n<p>maven工具自己的jar包。</p>\n</li>\n<li>\n<p>第三方的其他jar， 比如项目中要使用mysql驱动。</p>\n</li>\n<li>\n<p>自己写的程序，可以打包为jar 。 存放到仓库。</p>\n</li>\n</ol>\n<p>仓库的分类：</p>\n<ol>\n<li>\n<p>本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。</p>\n<p>本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository</p>\n<pre><code class=\"language-xml\">     C:\\Users\\NING MEI\\.m2\\repository\n</code></pre>\n<p>修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\\conf\\setting.xml）</p>\n<p>​	步骤：</p>\n<p>​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。</p>\n<p>​		   例如： D:\\openrepository</p>\n<p>​     2）修改setting.xml文件，指定 D:\\openrepository这个目录</p>\n<pre><code class=\"language-xml\">    &lt;localRepository&gt;D:/openrepository&lt;/localRepository&gt;\n</code></pre>\n<p>​    3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository</p>\n</li>\n<li>\n<p>远程仓库： 需要通过联网访问的</p>\n<p>1）中央仓库： 一个ftp服务器， 存放了所有的资源。</p>\n<p>2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。</p>\n<p>3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。</p>\n</li>\n</ol>\n<p>maven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161143221891676959478388.png\" alt=\"image-20201016114322189\" /></p>\n<h2>2.6 maven的生命周期，插件和命令</h2>\n<p>maven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署</p>\n<p>插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。</p>\n<p>命令： 执行maven功能是 由命令发出的。 比如 mvn compile</p>\n<p>单元测试（junit）：</p>\n<p>junit是一个单元测试的工具， 在java中经常使用。</p>\n<p>单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。</p>\n<p>作用：使用junit去测试方法是否完成了要求。 开发人员自测。</p>\n<p>使用单元测试：</p>\n<p>1）加入junit的依赖（一些类和方法）</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<p>2)在src/test/java 目录中创建测试类文件。 写测试代码</p>\n<p>单元测试使用的建议：</p>\n<p>​    1.测试类的定义， 名称一般是Test+要测试的类名称</p>\n<p>​    2.测试类它的包名和要测试的类包名一样。</p>\n<p>​    3.在类中定义方法，要测试代码。</p>\n<p>​       方法的定义：public方法，</p>\n<p>​                               没有返回值</p>\n<p>​                               方法名称自定义（建议 Test+测试的方法名称）</p>\n<p>​                               方法没有参数</p>\n<p>4.在测试类中的方法，可以单独执行。 测试类也可以单独执行</p>\n<p>5.在方法的上面加入@Test</p>\n<p>命令：</p>\n<p>1） mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。</p>\n<p>​      插件： maven-clean-plugin   ， 版本是 2.5</p>\n<p>2）mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。</p>\n<p>​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）</p>\n<p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p>\n<p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的</p>\n<p>​                                                             文件拷贝target/classes目录中。</p>\n<p>3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录</p>\n<p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p>\n<p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的</p>\n<p>4）mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。</p>\n<p>​     插件： maven-surefire-plugin 版本 2.12.4</p>\n<p>5）mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。</p>\n<p>​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.</p>\n<p>​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。</p>\n<p>​    生成的是 ch01-maven-1.0-SNAPSHOT.jar</p>\n<pre><code class=\"language-xml\">  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n打包的文件名： artifactId-version.packaging\n</code></pre>\n<p>6）mvn install : 把生成的打包的文件 ，安装到maven仓库。</p>\n<p>​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。</p>\n<p>​    查看查看中的jar文件：</p>\n<pre><code class=\"language-xml\">  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n\ngroupId中的值， 如果有 &quot;.&quot; 前和后都是独立的文件夹。 com\\bjpowernode\nartifactId, 独立的文件夹\nversion，独立的文件夹\n</code></pre>\n<h2>2.7 自定义配置插件</h2>\n<p>在pom.xml文件中， build标签中。设置插件</p>\n<pre><code class=\"language-xml\">&lt;!-- 设置构建项目相关的内容 --&gt;\n&lt;build&gt;\n  &lt;plugins&gt;\n    &lt;!-- 设置插件 --&gt;\n	&lt;plugin&gt;\n		&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n		&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n		&lt;version&gt;3.8.1&lt;/version&gt;\n		&lt;configuration&gt;\n			&lt;source&gt;1.8&lt;/source&gt; &lt;!-- 指定编译代码的jdk版本 --&gt;\n			&lt;target&gt;1.8&lt;/target&gt; &lt;!-- 运行java程序使用的jdk版本--&gt;\n		&lt;/configuration&gt;\n	&lt;/plugin&gt;\n  &lt;/plugins&gt;\n&lt;/build&gt; \n</code></pre>\n<h1>第三章 Maven和idea的集成</h1>\n<h2>3.1 idea中集成maven</h2>\n<p>idea中有一个自带的maven。  我们要让idea使用自己安装的maven。</p>\n<ol>\n<li>选择File- Settings</li>\n</ol>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161510348721676959478389.png\" alt=\"image-20201016151034872\" /></p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161515286781676959478390.png\" alt=\"image-20201016151528678\" /></p>\n<p>设置项： -DarchetypeCatalog=internal</p>\n<p>2） File - Other Settings</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161518239671676959478389.png\" alt=\"image-20201016151823967\" /></p>\n<p>同上的设置</p>\n<h2>3.2 创建基于maven的普通java项目</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161610289771676959478390.png\" alt=\"image-20201016161028977\" /></p>\n<h2>3.3 创建web项目</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161701536941676959478390.png\" alt=\"image-20201016170153694\" /></p>\n<h2>3.4 导入module到idea</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010170858162261676959478390.png\" alt=\"image-20201017085816226\" /></p>\n<h1>4. 第四章 依赖管理</h1>\n<p>依赖范围：使用scope表示依赖的范围。</p>\n<p>依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。</p>\n<p>依赖范围scope ：</p>\n<p>​     compile:默认， 参与构建项目的所有阶段</p>\n<p>​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。</p>\n<p>​    provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包</p>\n<p>​					  明显的是servlet 和jsp 依赖</p>\n<h1>5. 第五章 常用设置</h1>\n<p>1)讲的是properties它里面的配置</p>\n<pre><code class=\"language-xml\">&lt;properties&gt;\n&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; 源码编译 jdk 版本\n&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; 运行代码的 jdk 版本\n&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; 项目\n构建使用的编码，避免中文乱码\n&lt;project.reporting.outputEncoding&gt;UTF-8\n&lt;/project.reporting.outputEncoding&gt; 生成报告的编码\n&lt;/properties&gt;\n</code></pre>\n<ol start=\"2\">\n<li>全局变量</li>\n</ol>\n<p>在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。</p>\n<p>使用全局变量表示 多个依赖使用的版本号。</p>\n<p>使用步骤：</p>\n<p>1.在properties标签中，定义一个标签，指定版本的值</p>\n<pre><code class=\"language-xml\">&lt;properties&gt;\n  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n  &lt;!--自定义变量--&gt;\n  &lt;spring.version&gt;5.2.5.RELEASE&lt;/spring.version&gt;\n  &lt;junit.version&gt;4.11&lt;/junit.version&gt;\n&lt;/properties&gt;\n</code></pre>\n<ol start=\"2\">\n<li>使用全局变量， 语法 ${变量名}</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n  &lt;version&gt;${spring.version}&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n  &lt;version&gt;${spring.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>3）使用资源插件</p>\n<p>处理的配置文件的信息， maven默认处理配置文件</p>\n<p>①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下</p>\n<p>②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。</p>\n<pre><code class=\"language-xml\">&lt;build&gt;\n  &lt;!--资源插件\n      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。\n  --&gt;\n  &lt;resources&gt;\n    &lt;resource&gt;\n      &lt;directory&gt;src/main/java&lt;/directory&gt;&lt;!--所在的目录--&gt;\n      &lt;includes&gt;\n      &lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;\n        &lt;include&gt;**/*.properties&lt;/include&gt;\n        &lt;include&gt;**/*.xml&lt;/include&gt;\n      &lt;/includes&gt;\n        &lt;!--  filtering 选项 false 不启用过滤器， *.property 已经起到过\n        滤的作用了 --&gt;\n      &lt;filtering&gt;false&lt;/filtering&gt;\n    &lt;/resource&gt;\n  &lt;/resources&gt;\n&lt;/build&gt;\n</code></pre>\n', '# Maven 自动化的构建工具\r\n\r\n#  第一章 Maven简介\r\n\r\n## 1.1 软件开发中的阶段\r\n\r\n需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。\r\n\r\n设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。\r\n\r\n开发阶段：编码实现功能。 编译代码。自我测试\r\n\r\n测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。\r\n\r\n项目的打包，发布阶段： 给用户安装项目\r\n\r\n\r\n\r\n## 1.2 Maven能做什么\r\n\r\n1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。\r\n\r\n2）管理依赖（管理项目中使用的各种jar包）。\r\n\r\n​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。\r\n\r\n\r\n\r\n## 1.3 没有使用maven怎么管理依赖\r\n\r\n管理jar ，需要从网络中单独下载某个jar \r\n\r\n需要选择正确版本\r\n\r\n手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。\r\n\r\n\r\n\r\n## 1.4 什么是maven\r\n\r\nmaven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[\'meɪv(ə)n]  或  [\'mevn]。\r\n\r\nmaven是项目的自动化构建工具。 管理项目的依赖。\r\n\r\n\r\n\r\n## 1.5 maven中的概念\r\n\r\n①POM\r\n②约定的目录结构\r\n③坐标\r\n④依赖管理\r\n⑤仓库管理\r\n⑥生命周期\r\n⑦插件和目标\r\n⑧继承\r\n⑨聚合\r\n\r\n\r\n\r\n## 1.6 maven工具的获取和安装\r\n\r\n地址： http://maven.apache.org/  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip\r\n\r\n\r\n\r\n安装：\r\n\r\n1. 确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录\r\n\r\n2. 解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。 \r\n\r\n   目录的路径不要有中文， 不要有空格。\r\n\r\n3. 把maven安装目录中下的bin的路径添加到path中\r\n\r\n4. 测试maven的安装。 在命令行执行 mvn     -v\r\n\r\n   ```xml\r\n   C:\\Users\\NING MEI>mvn -v\r\n   Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\r\n   Maven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\r\n   Java version: 1.8.0_101, vendor: Oracle Corporation\r\n   Java home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\r\n   Default locale: zh_CN, platform encoding: GBK\r\n   OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\r\n   ```\r\n\r\n   \r\n\r\nmaven解压后的目录结构\r\n\r\n![image-20201015162301261](images/image-20201015162301261.png)	\r\n\r\n\r\n\r\nmaven的其他安装方式：\r\n\r\n1. 确定JAVA_HOME是否有效\r\n\r\n2. 在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录\r\n\r\n   M2_HOME=D:\\tools\\apache-maven-3.3.9\r\n\r\n3. 在path环境变量中，加入 %M2_HOME%\\bin    \r\n\r\n4. 测试maven的安装，再命令行执行 mvn  -v\r\n\r\n   ```xml\r\n   C:\\Users\\NING MEI>mvn -v\r\n   Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\r\n   Maven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\r\n   Java version: 1.8.0_101, vendor: Oracle Corporation\r\n   Java home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\r\n   Default locale: zh_CN, platform encoding: GBK\r\n   OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\r\n   ```\r\n\r\n   \r\n\r\n# 第二章Maven的核心概念\r\n\r\n## 2.1 约定的目录结构\r\n\r\nmaven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。\r\n\r\n一个maven项目是一个文件夹。 比如项目叫做Hello\r\n\r\n```java\r\nHello 项目文件夹\r\n    \\src\r\n    	\\main				叫做主程序目录（完成项目功能的代码和配置文件）\r\n             \\java          源代码（包和相关的类定义）\r\n    		 \\resources	    配置文件\r\n    	\\test               放置测试程序代码的（开发人员自己写的测试代码）\r\n    		 \\java          测试代码的（junit）\r\n    		 \\resources     测试程序需要的配置文件\r\n    \\pom.xml                maven的配置文件， 核心文件\r\n```\r\n\r\n\r\n\r\nmaven的使用方式：\r\n\r\n1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等\r\n\r\n2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等\r\n\r\n\r\n\r\n## 2.2 POM \r\n\r\nPOM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。\r\n\r\nmaven通过pom.xml文件实现 项目的构建和依赖的管理。\r\n\r\n```xml\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<!-- project是根标签， 后面的是约束文件 -->\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    \r\n    \r\n  <!-- pom模型的版本， 就是4.0.0 -->  \r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <!-- 坐标 -->  \r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  \r\n  <properties>\r\n     <java.version>1.8</java.version>\r\n     <maven.compiler.source>1.8</maven.compiler.source>\r\n     <maven.compiler.target>1.8</maven.compiler.target>\r\n  </properties>\r\n  \r\n</project>\r\n```\r\n\r\n\r\n\r\n## 2.3 坐标\r\n\r\n坐标组成是 groupid, artifiactId, version。  坐标概念来自数学。·\r\n\r\n坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n\r\ngroupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。\r\n         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode\r\n\r\n         如果项目规模比较大， 也可以是 域名倒写+大项目名称。\r\n	     例如： www.baidu.com ,  无人车： com.baidu.appollo\r\nartifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。\r\nversion：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。\r\n         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      \r\n   \r\npackaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar\r\n```\r\n\r\n项目使用gav：\r\n\r\n1.每个maven项目，都需要有一个自己的gav\r\n\r\n2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。\r\n\r\n\r\n\r\n搜索坐标的地址： https://mvnrepository.com/\r\n\r\n\r\n\r\n## 2.4 依赖 dependency\r\n\r\n依赖：项目中要使用的其他资源（jar）。  \r\n\r\n需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用\r\n\r\n需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。\r\n\r\n格式：\r\n\r\n```xml\r\n\r\n<dependencies>\r\n  \r\n    <!-- 日志 -->\r\n    <dependency>\r\n        <groupId>log4j</groupId>\r\n        <artifactId>log4j</artifactId>\r\n        <version>1.2.17</version>\r\n    </dependency>\r\n    \r\n    <!-- mysql驱动 -->\r\n     <dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n        <version>5.1.16</version>\r\n    </dependency>\r\n\r\n</dependencies> \r\n\r\nmaven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar\r\n```\r\n\r\n## 2.5 仓库\r\n\r\n仓库是存东西的，maven的仓库存放的是：\r\n\r\n1. maven工具自己的jar包。\r\n\r\n2. 第三方的其他jar， 比如项目中要使用mysql驱动。\r\n\r\n3. 自己写的程序，可以打包为jar 。 存放到仓库。\r\n\r\n   \r\n\r\n仓库的分类：\r\n\r\n1. 本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。\r\n\r\n   本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository\r\n\r\n   ```xml\r\n        C:\\Users\\NING MEI\\.m2\\repository\r\n   ```\r\n\r\n   \r\n\r\n   修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\\conf\\setting.xml）\r\n\r\n   ​	步骤：\r\n\r\n   ​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。\r\n\r\n   ​		   例如： D:\\openrepository\r\n\r\n   ​     2）修改setting.xml文件，指定 D:\\openrepository这个目录\r\n\r\n   ```xml\r\n       <localRepository>D:/openrepository</localRepository>\r\n   ```\r\n\r\n   ​    3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository\r\n\r\n     \r\n\r\n   \r\n\r\n2. 远程仓库： 需要通过联网访问的\r\n\r\n   1）中央仓库： 一个ftp服务器， 存放了所有的资源。 \r\n\r\n   2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。\r\n\r\n   3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。\r\n\r\n\r\n\r\nmaven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。\r\n\r\n\r\n\r\n![image-20201016114322189](images/image-20201016114322189.png)	\r\n\r\n## 2.6 maven的生命周期，插件和命令\r\n\r\nmaven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署\r\n\r\n插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。\r\n\r\n命令： 执行maven功能是 由命令发出的。 比如 mvn compile\r\n\r\n\r\n\r\n单元测试（junit）：\r\n\r\njunit是一个单元测试的工具， 在java中经常使用。\r\n\r\n单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。\r\n\r\n作用：使用junit去测试方法是否完成了要求。 开发人员自测。\r\n\r\n\r\n\r\n使用单元测试：\r\n\r\n1）加入junit的依赖（一些类和方法）\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>junit</groupId>\r\n    <artifactId>junit</artifactId>\r\n    <version>4.12</version>\r\n    <scope>test</scope>\r\n</dependency>\r\n\r\n```\r\n\r\n\r\n\r\n2)在src/test/java 目录中创建测试类文件。 写测试代码\r\n\r\n   单元测试使用的建议：\r\n\r\n​    1.测试类的定义， 名称一般是Test+要测试的类名称\r\n\r\n​    2.测试类它的包名和要测试的类包名一样。\r\n\r\n​    3.在类中定义方法，要测试代码。\r\n\r\n​       方法的定义：public方法， \r\n\r\n​                               没有返回值\r\n\r\n​                               方法名称自定义（建议 Test+测试的方法名称）\r\n\r\n​                               方法没有参数\r\n\r\n   4.在测试类中的方法，可以单独执行。 测试类也可以单独执行\r\n\r\n   5.在方法的上面加入@Test\r\n\r\n\r\n\r\n命令：\r\n\r\n1） mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。\r\n\r\n​      插件： maven-clean-plugin   ， 版本是 2.5\r\n\r\n2）mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。\r\n\r\n​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）\r\n\r\n\r\n\r\n​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件\r\n\r\n​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的                \r\n\r\n​                                                             文件拷贝target/classes目录中。\r\n\r\n3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录\r\n\r\n​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件\r\n\r\n​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的\r\n\r\n\r\n\r\n4）mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。\r\n\r\n​     插件： maven-surefire-plugin 版本 2.12.4\r\n\r\n\r\n\r\n5）mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。\r\n\r\n​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.\r\n\r\n​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。\r\n\r\n\r\n\r\n​    生成的是 ch01-maven-1.0-SNAPSHOT.jar\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n打包的文件名： artifactId-version.packaging\r\n```\r\n\r\n\r\n\r\n6）mvn install : 把生成的打包的文件 ，安装到maven仓库。\r\n\r\n​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。 \r\n\r\n​    查看查看中的jar文件：\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n\r\ngroupId中的值， 如果有 \".\" 前和后都是独立的文件夹。 com\\bjpowernode\r\nartifactId, 独立的文件夹\r\nversion，独立的文件夹\r\n```\r\n\r\n\r\n\r\n   ## 2.7 自定义配置插件\r\n\r\n在pom.xml文件中， build标签中。设置插件\r\n\r\n  \r\n\r\n```xml\r\n<!-- 设置构建项目相关的内容 -->\r\n<build>\r\n  <plugins>\r\n    <!-- 设置插件 -->\r\n	<plugin>\r\n		<groupId>org.apache.maven.plugins</groupId>\r\n		<artifactId>maven-compiler-plugin</artifactId>\r\n		<version>3.8.1</version>\r\n		<configuration>\r\n			<source>1.8</source> <!-- 指定编译代码的jdk版本 -->\r\n			<target>1.8</target> <!-- 运行java程序使用的jdk版本-->\r\n		</configuration>\r\n	</plugin>\r\n  </plugins>\r\n</build> \r\n```\r\n\r\n\r\n# 第三章 Maven和idea的集成\r\n\r\n## 3.1 idea中集成maven\r\n\r\nidea中有一个自带的maven。  我们要让idea使用自己安装的maven。\r\n\r\n1) 选择File- Settings \r\n\r\n![image-20201016151034872](images/image-20201016151034872.png)	\r\n\r\n![image-20201016151528678](images/image-20201016151528678.png)	\r\n\r\n设置项： -DarchetypeCatalog=internal\r\n\r\n\r\n\r\n2） File - Other Settings\r\n\r\n![image-20201016151823967](images/image-20201016151823967.png)\r\n\r\n同上的设置\r\n\r\n\r\n\r\n## 3.2 创建基于maven的普通java项目\r\n\r\n![image-20201016161028977](images/image-20201016161028977.png)	\r\n\r\n\r\n\r\n## 3.3 创建web项目\r\n\r\n![image-20201016170153694](images/image-20201016170153694.png)	\r\n\r\n## 3.4 导入module到idea\r\n\r\n\r\n\r\n![image-20201017085816226](images/image-20201017085816226.png)	\r\n\r\n\r\n\r\n# 4. 第四章 依赖管理\r\n\r\n依赖范围：使用scope表示依赖的范围。 \r\n\r\n依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。\r\n\r\n依赖范围scope ：\r\n\r\n​     compile:默认， 参与构建项目的所有阶段\r\n\r\n​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。\r\n\r\n​    provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包\r\n\r\n​					  明显的是servlet 和jsp 依赖\r\n\r\n\r\n\r\n# 5. 第五章 常用设置\r\n\r\n1)讲的是properties它里面的配置\r\n\r\n```xml\r\n<properties>\r\n<maven.compiler.source>1.8</maven.compiler.source> 源码编译 jdk 版本\r\n<maven.compiler.target>1.8</maven.compiler.target> 运行代码的 jdk 版本\r\n<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> 项目\r\n构建使用的编码，避免中文乱码\r\n<project.reporting.outputEncoding>UTF-8\r\n</project.reporting.outputEncoding> 生成报告的编码\r\n</properties>\r\n```\r\n\r\n\r\n\r\n2) 全局变量\r\n\r\n在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。 \r\n\r\n使用全局变量表示 多个依赖使用的版本号。\r\n\r\n\r\n\r\n使用步骤：\r\n\r\n1.在properties标签中，定义一个标签，指定版本的值\r\n\r\n```xml\r\n<properties>\r\n  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n  <maven.compiler.source>1.8</maven.compiler.source>\r\n  <maven.compiler.target>1.8</maven.compiler.target>\r\n  <!--自定义变量-->\r\n  <spring.version>5.2.5.RELEASE</spring.version>\r\n  <junit.version>4.11</junit.version>\r\n</properties>\r\n```\r\n\r\n\r\n\r\n2. 使用全局变量， 语法 ${变量名}\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>org.springframework</groupId>\r\n  <artifactId>spring-core</artifactId>\r\n  <version>${spring.version}</version>\r\n</dependency>\r\n\r\n<dependency>\r\n  <groupId>org.springframework</groupId>\r\n  <artifactId>spring-web</artifactId>\r\n  <version>${spring.version}</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n3）使用资源插件\r\n\r\n处理的配置文件的信息， maven默认处理配置文件\r\n\r\n①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下\r\n\r\n②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。\r\n\r\n\r\n\r\n```xml\r\n<build>\r\n  <!--资源插件\r\n      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。\r\n  -->\r\n  <resources>\r\n    <resource>\r\n      <directory>src/main/java</directory><!--所在的目录-->\r\n      <includes>\r\n      <!--包括目录下的.properties,.xml 文件都会扫描到-->\r\n        <include>**/*.properties</include>\r\n        <include>**/*.xml</include>\r\n      </includes>\r\n        <!--  filtering 选项 false 不启用过滤器， *.property 已经起到过\r\n        滤的作用了 -->\r\n      <filtering>false</filtering>\r\n    </resource>\r\n  </resources>\r\n</build>\r\n```\r\n\r\n', 'Maven', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 14:04:57', 1, '2023-02-21 14:04:57', 1);
INSERT INTO `lzh_article` VALUES (1627913469034573825, 'Maven', '<h1>Maven 自动化的构建工具</h1>\n<h1>第一章 Maven简介</h1>\n<h2>1.1 软件开发中的阶段</h2>\n<p>需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。</p>\n<p>设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。</p>\n<p>开发阶段：编码实现功能。 编译代码。自我测试</p>\n<p>测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。</p>\n<p>项目的打包，发布阶段： 给用户安装项目</p>\n<h2>1.2 Maven能做什么</h2>\n<p>1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。</p>\n<p>2）管理依赖（管理项目中使用的各种jar包）。</p>\n<p>​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。</p>\n<h2>1.3 没有使用maven怎么管理依赖</h2>\n<p>管理jar ，需要从网络中单独下载某个jar</p>\n<p>需要选择正确版本</p>\n<p>手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。</p>\n<h2>1.4 什么是maven</h2>\n<p>maven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[\'meɪv(ə)n]  或  [\'mevn]。</p>\n<p>maven是项目的自动化构建工具。 管理项目的依赖。</p>\n<h2>1.5 maven中的概念</h2>\n<p>①POM\n②约定的目录结构\n③坐标\n④依赖管理\n⑤仓库管理\n⑥生命周期\n⑦插件和目标\n⑧继承\n⑨聚合</p>\n<h2>1.6 maven工具的获取和安装</h2>\n<p>地址： http://maven.apache.org/  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip</p>\n<p>安装：</p>\n<ol>\n<li>\n<p>确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录</p>\n</li>\n<li>\n<p>解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。</p>\n<p>目录的路径不要有中文， 不要有空格。</p>\n</li>\n<li>\n<p>把maven安装目录中下的bin的路径添加到path中</p>\n</li>\n<li>\n<p>测试maven的安装。 在命令行执行 mvn     -v</p>\n<pre><code class=\"language-xml\">C:\\Users\\NING MEI&gt;mvn -v\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\nMaven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\nJava version: 1.8.0_101, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;\n</code></pre>\n</li>\n</ol>\n<p>maven解压后的目录结构</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010151623012611676959532668.png\" alt=\"image-20201015162301261\" /></p>\n<p>maven的其他安装方式：</p>\n<ol>\n<li>\n<p>确定JAVA_HOME是否有效</p>\n</li>\n<li>\n<p>在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录</p>\n<p>M2_HOME=D:\\tools\\apache-maven-3.3.9</p>\n</li>\n<li>\n<p>在path环境变量中，加入 %M2_HOME%\\bin</p>\n</li>\n<li>\n<p>测试maven的安装，再命令行执行 mvn  -v</p>\n<pre><code class=\"language-xml\">C:\\Users\\NING MEI&gt;mvn -v\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\nMaven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\nJava version: 1.8.0_101, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;\n</code></pre>\n</li>\n</ol>\n<h1>第二章Maven的核心概念</h1>\n<h2>2.1 约定的目录结构</h2>\n<p>maven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。</p>\n<p>一个maven项目是一个文件夹。 比如项目叫做Hello</p>\n<pre><code class=\"language-java\">Hello 项目文件夹\n    \\src\n    	\\main				叫做主程序目录（完成项目功能的代码和配置文件）\n             \\java          源代码（包和相关的类定义）\n    		 \\resources	    配置文件\n    	\\test               放置测试程序代码的（开发人员自己写的测试代码）\n    		 \\java          测试代码的（junit）\n    		 \\resources     测试程序需要的配置文件\n    \\pom.xml                maven的配置文件， 核心文件\n</code></pre>\n<p>maven的使用方式：</p>\n<p>1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等</p>\n<p>2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等</p>\n<h2>2.2 POM</h2>\n<p>POM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。</p>\n<p>maven通过pom.xml文件实现 项目的构建和依赖的管理。</p>\n<pre><code class=\"language-xml\">\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;!-- project是根标签， 后面的是约束文件 --&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    \n    \n  &lt;!-- pom模型的版本， 就是4.0.0 --&gt;  \n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;!-- 坐标 --&gt;  \n  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  \n  &lt;properties&gt;\n     &lt;java.version&gt;1.8&lt;/java.version&gt;\n     &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n     &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n  &lt;/properties&gt;\n  \n&lt;/project&gt;\n</code></pre>\n<h2>2.3 坐标</h2>\n<p>坐标组成是 groupid, artifiactId, version。  坐标概念来自数学。·</p>\n<p>坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav</p>\n<pre><code class=\"language-xml\">  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n\ngroupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。\n         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode\n\n         如果项目规模比较大， 也可以是 域名倒写+大项目名称。\n	     例如： www.baidu.com ,  无人车： com.baidu.appollo\nartifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。\nversion：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。\n         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      \n   \npackaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar\n</code></pre>\n<p>项目使用gav：</p>\n<p>1.每个maven项目，都需要有一个自己的gav</p>\n<p>2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。</p>\n<p>搜索坐标的地址： https://mvnrepository.com/</p>\n<h2>2.4 依赖 dependency</h2>\n<p>依赖：项目中要使用的其他资源（jar）。</p>\n<p>需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用</p>\n<p>需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。</p>\n<p>格式：</p>\n<pre><code class=\"language-xml\">\n&lt;dependencies&gt;\n  \n    &lt;!-- 日志 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n        &lt;version&gt;1.2.17&lt;/version&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!-- mysql驱动 --&gt;\n     &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;version&gt;5.1.16&lt;/version&gt;\n    &lt;/dependency&gt;\n\n&lt;/dependencies&gt; \n\nmaven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar\n</code></pre>\n<h2>2.5 仓库</h2>\n<p>仓库是存东西的，maven的仓库存放的是：</p>\n<ol>\n<li>\n<p>maven工具自己的jar包。</p>\n</li>\n<li>\n<p>第三方的其他jar， 比如项目中要使用mysql驱动。</p>\n</li>\n<li>\n<p>自己写的程序，可以打包为jar 。 存放到仓库。</p>\n</li>\n</ol>\n<p>仓库的分类：</p>\n<ol>\n<li>\n<p>本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。</p>\n<p>本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository</p>\n<pre><code class=\"language-xml\">     C:\\Users\\NING MEI\\.m2\\repository\n</code></pre>\n<p>修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\\conf\\setting.xml）</p>\n<p>​	步骤：</p>\n<p>​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。</p>\n<p>​		   例如： D:\\openrepository</p>\n<p>​     2）修改setting.xml文件，指定 D:\\openrepository这个目录</p>\n<pre><code class=\"language-xml\">    &lt;localRepository&gt;D:/openrepository&lt;/localRepository&gt;\n</code></pre>\n<p>​    3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository</p>\n</li>\n<li>\n<p>远程仓库： 需要通过联网访问的</p>\n<p>1）中央仓库： 一个ftp服务器， 存放了所有的资源。</p>\n<p>2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。</p>\n<p>3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。</p>\n</li>\n</ol>\n<p>maven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161143221891676959532668.png\" alt=\"image-20201016114322189\" /></p>\n<h2>2.6 maven的生命周期，插件和命令</h2>\n<p>maven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署</p>\n<p>插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。</p>\n<p>命令： 执行maven功能是 由命令发出的。 比如 mvn compile</p>\n<p>单元测试（junit）：</p>\n<p>junit是一个单元测试的工具， 在java中经常使用。</p>\n<p>单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。</p>\n<p>作用：使用junit去测试方法是否完成了要求。 开发人员自测。</p>\n<p>使用单元测试：</p>\n<p>1）加入junit的依赖（一些类和方法）</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<p>2)在src/test/java 目录中创建测试类文件。 写测试代码</p>\n<p>单元测试使用的建议：</p>\n<p>​    1.测试类的定义， 名称一般是Test+要测试的类名称</p>\n<p>​    2.测试类它的包名和要测试的类包名一样。</p>\n<p>​    3.在类中定义方法，要测试代码。</p>\n<p>​       方法的定义：public方法，</p>\n<p>​                               没有返回值</p>\n<p>​                               方法名称自定义（建议 Test+测试的方法名称）</p>\n<p>​                               方法没有参数</p>\n<p>4.在测试类中的方法，可以单独执行。 测试类也可以单独执行</p>\n<p>5.在方法的上面加入@Test</p>\n<p>命令：</p>\n<p>1） mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。</p>\n<p>​      插件： maven-clean-plugin   ， 版本是 2.5</p>\n<p>2）mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。</p>\n<p>​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）</p>\n<p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p>\n<p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的</p>\n<p>​                                                             文件拷贝target/classes目录中。</p>\n<p>3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录</p>\n<p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p>\n<p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的</p>\n<p>4）mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。</p>\n<p>​     插件： maven-surefire-plugin 版本 2.12.4</p>\n<p>5）mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。</p>\n<p>​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.</p>\n<p>​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。</p>\n<p>​    生成的是 ch01-maven-1.0-SNAPSHOT.jar</p>\n<pre><code class=\"language-xml\">  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n打包的文件名： artifactId-version.packaging\n</code></pre>\n<p>6）mvn install : 把生成的打包的文件 ，安装到maven仓库。</p>\n<p>​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。</p>\n<p>​    查看查看中的jar文件：</p>\n<pre><code class=\"language-xml\">  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n\ngroupId中的值， 如果有 &quot;.&quot; 前和后都是独立的文件夹。 com\\bjpowernode\nartifactId, 独立的文件夹\nversion，独立的文件夹\n</code></pre>\n<h2>2.7 自定义配置插件</h2>\n<p>在pom.xml文件中， build标签中。设置插件</p>\n<pre><code class=\"language-xml\">&lt;!-- 设置构建项目相关的内容 --&gt;\n&lt;build&gt;\n  &lt;plugins&gt;\n    &lt;!-- 设置插件 --&gt;\n	&lt;plugin&gt;\n		&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n		&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n		&lt;version&gt;3.8.1&lt;/version&gt;\n		&lt;configuration&gt;\n			&lt;source&gt;1.8&lt;/source&gt; &lt;!-- 指定编译代码的jdk版本 --&gt;\n			&lt;target&gt;1.8&lt;/target&gt; &lt;!-- 运行java程序使用的jdk版本--&gt;\n		&lt;/configuration&gt;\n	&lt;/plugin&gt;\n  &lt;/plugins&gt;\n&lt;/build&gt; \n</code></pre>\n<h1>第三章 Maven和idea的集成</h1>\n<h2>3.1 idea中集成maven</h2>\n<p>idea中有一个自带的maven。  我们要让idea使用自己安装的maven。</p>\n<ol>\n<li>选择File- Settings</li>\n</ol>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161510348721676959532668.png\" alt=\"image-20201016151034872\" /></p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161515286781676959532668.png\" alt=\"image-20201016151528678\" /></p>\n<p>设置项： -DarchetypeCatalog=internal</p>\n<p>2） File - Other Settings</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161518239671676959532669.png\" alt=\"image-20201016151823967\" /></p>\n<p>同上的设置</p>\n<h2>3.2 创建基于maven的普通java项目</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161610289771676959532668.png\" alt=\"image-20201016161028977\" /></p>\n<h2>3.3 创建web项目</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161701536941676959532668.png\" alt=\"image-20201016170153694\" /></p>\n<h2>3.4 导入module到idea</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010170858162261676959532668.png\" alt=\"image-20201017085816226\" /></p>\n<h1>4. 第四章 依赖管理</h1>\n<p>依赖范围：使用scope表示依赖的范围。</p>\n<p>依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。</p>\n<p>依赖范围scope ：</p>\n<p>​     compile:默认， 参与构建项目的所有阶段</p>\n<p>​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。</p>\n<p>​    provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包</p>\n<p>​					  明显的是servlet 和jsp 依赖</p>\n<h1>5. 第五章 常用设置</h1>\n<p>1)讲的是properties它里面的配置</p>\n<pre><code class=\"language-xml\">&lt;properties&gt;\n&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; 源码编译 jdk 版本\n&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; 运行代码的 jdk 版本\n&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; 项目\n构建使用的编码，避免中文乱码\n&lt;project.reporting.outputEncoding&gt;UTF-8\n&lt;/project.reporting.outputEncoding&gt; 生成报告的编码\n&lt;/properties&gt;\n</code></pre>\n<ol start=\"2\">\n<li>全局变量</li>\n</ol>\n<p>在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。</p>\n<p>使用全局变量表示 多个依赖使用的版本号。</p>\n<p>使用步骤：</p>\n<p>1.在properties标签中，定义一个标签，指定版本的值</p>\n<pre><code class=\"language-xml\">&lt;properties&gt;\n  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n  &lt;!--自定义变量--&gt;\n  &lt;spring.version&gt;5.2.5.RELEASE&lt;/spring.version&gt;\n  &lt;junit.version&gt;4.11&lt;/junit.version&gt;\n&lt;/properties&gt;\n</code></pre>\n<ol start=\"2\">\n<li>使用全局变量， 语法 ${变量名}</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n  &lt;version&gt;${spring.version}&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n  &lt;version&gt;${spring.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>3）使用资源插件</p>\n<p>处理的配置文件的信息， maven默认处理配置文件</p>\n<p>①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下</p>\n<p>②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。</p>\n<pre><code class=\"language-xml\">&lt;build&gt;\n  &lt;!--资源插件\n      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。\n  --&gt;\n  &lt;resources&gt;\n    &lt;resource&gt;\n      &lt;directory&gt;src/main/java&lt;/directory&gt;&lt;!--所在的目录--&gt;\n      &lt;includes&gt;\n      &lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;\n        &lt;include&gt;**/*.properties&lt;/include&gt;\n        &lt;include&gt;**/*.xml&lt;/include&gt;\n      &lt;/includes&gt;\n        &lt;!--  filtering 选项 false 不启用过滤器， *.property 已经起到过\n        滤的作用了 --&gt;\n      &lt;filtering&gt;false&lt;/filtering&gt;\n    &lt;/resource&gt;\n  &lt;/resources&gt;\n&lt;/build&gt;\n</code></pre>\n', '# Maven 自动化的构建工具\r\n\r\n#  第一章 Maven简介\r\n\r\n## 1.1 软件开发中的阶段\r\n\r\n需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。\r\n\r\n设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。\r\n\r\n开发阶段：编码实现功能。 编译代码。自我测试\r\n\r\n测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。\r\n\r\n项目的打包，发布阶段： 给用户安装项目\r\n\r\n\r\n\r\n## 1.2 Maven能做什么\r\n\r\n1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。\r\n\r\n2）管理依赖（管理项目中使用的各种jar包）。\r\n\r\n​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。\r\n\r\n\r\n\r\n## 1.3 没有使用maven怎么管理依赖\r\n\r\n管理jar ，需要从网络中单独下载某个jar \r\n\r\n需要选择正确版本\r\n\r\n手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。\r\n\r\n\r\n\r\n## 1.4 什么是maven\r\n\r\nmaven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[\'meɪv(ə)n]  或  [\'mevn]。\r\n\r\nmaven是项目的自动化构建工具。 管理项目的依赖。\r\n\r\n\r\n\r\n## 1.5 maven中的概念\r\n\r\n①POM\r\n②约定的目录结构\r\n③坐标\r\n④依赖管理\r\n⑤仓库管理\r\n⑥生命周期\r\n⑦插件和目标\r\n⑧继承\r\n⑨聚合\r\n\r\n\r\n\r\n## 1.6 maven工具的获取和安装\r\n\r\n地址： http://maven.apache.org/  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip\r\n\r\n\r\n\r\n安装：\r\n\r\n1. 确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录\r\n\r\n2. 解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。 \r\n\r\n   目录的路径不要有中文， 不要有空格。\r\n\r\n3. 把maven安装目录中下的bin的路径添加到path中\r\n\r\n4. 测试maven的安装。 在命令行执行 mvn     -v\r\n\r\n   ```xml\r\n   C:\\Users\\NING MEI>mvn -v\r\n   Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\r\n   Maven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\r\n   Java version: 1.8.0_101, vendor: Oracle Corporation\r\n   Java home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\r\n   Default locale: zh_CN, platform encoding: GBK\r\n   OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\r\n   ```\r\n\r\n   \r\n\r\nmaven解压后的目录结构\r\n\r\n![image-20201015162301261](images/image-20201015162301261.png)	\r\n\r\n\r\n\r\nmaven的其他安装方式：\r\n\r\n1. 确定JAVA_HOME是否有效\r\n\r\n2. 在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录\r\n\r\n   M2_HOME=D:\\tools\\apache-maven-3.3.9\r\n\r\n3. 在path环境变量中，加入 %M2_HOME%\\bin    \r\n\r\n4. 测试maven的安装，再命令行执行 mvn  -v\r\n\r\n   ```xml\r\n   C:\\Users\\NING MEI>mvn -v\r\n   Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\r\n   Maven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\r\n   Java version: 1.8.0_101, vendor: Oracle Corporation\r\n   Java home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\r\n   Default locale: zh_CN, platform encoding: GBK\r\n   OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\r\n   ```\r\n\r\n   \r\n\r\n# 第二章Maven的核心概念\r\n\r\n## 2.1 约定的目录结构\r\n\r\nmaven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。\r\n\r\n一个maven项目是一个文件夹。 比如项目叫做Hello\r\n\r\n```java\r\nHello 项目文件夹\r\n    \\src\r\n    	\\main				叫做主程序目录（完成项目功能的代码和配置文件）\r\n             \\java          源代码（包和相关的类定义）\r\n    		 \\resources	    配置文件\r\n    	\\test               放置测试程序代码的（开发人员自己写的测试代码）\r\n    		 \\java          测试代码的（junit）\r\n    		 \\resources     测试程序需要的配置文件\r\n    \\pom.xml                maven的配置文件， 核心文件\r\n```\r\n\r\n\r\n\r\nmaven的使用方式：\r\n\r\n1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等\r\n\r\n2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等\r\n\r\n\r\n\r\n## 2.2 POM \r\n\r\nPOM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。\r\n\r\nmaven通过pom.xml文件实现 项目的构建和依赖的管理。\r\n\r\n```xml\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<!-- project是根标签， 后面的是约束文件 -->\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    \r\n    \r\n  <!-- pom模型的版本， 就是4.0.0 -->  \r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <!-- 坐标 -->  \r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  \r\n  <properties>\r\n     <java.version>1.8</java.version>\r\n     <maven.compiler.source>1.8</maven.compiler.source>\r\n     <maven.compiler.target>1.8</maven.compiler.target>\r\n  </properties>\r\n  \r\n</project>\r\n```\r\n\r\n\r\n\r\n## 2.3 坐标\r\n\r\n坐标组成是 groupid, artifiactId, version。  坐标概念来自数学。·\r\n\r\n坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n\r\ngroupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。\r\n         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode\r\n\r\n         如果项目规模比较大， 也可以是 域名倒写+大项目名称。\r\n	     例如： www.baidu.com ,  无人车： com.baidu.appollo\r\nartifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。\r\nversion：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。\r\n         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      \r\n   \r\npackaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar\r\n```\r\n\r\n项目使用gav：\r\n\r\n1.每个maven项目，都需要有一个自己的gav\r\n\r\n2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。\r\n\r\n\r\n\r\n搜索坐标的地址： https://mvnrepository.com/\r\n\r\n\r\n\r\n## 2.4 依赖 dependency\r\n\r\n依赖：项目中要使用的其他资源（jar）。  \r\n\r\n需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用\r\n\r\n需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。\r\n\r\n格式：\r\n\r\n```xml\r\n\r\n<dependencies>\r\n  \r\n    <!-- 日志 -->\r\n    <dependency>\r\n        <groupId>log4j</groupId>\r\n        <artifactId>log4j</artifactId>\r\n        <version>1.2.17</version>\r\n    </dependency>\r\n    \r\n    <!-- mysql驱动 -->\r\n     <dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n        <version>5.1.16</version>\r\n    </dependency>\r\n\r\n</dependencies> \r\n\r\nmaven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar\r\n```\r\n\r\n## 2.5 仓库\r\n\r\n仓库是存东西的，maven的仓库存放的是：\r\n\r\n1. maven工具自己的jar包。\r\n\r\n2. 第三方的其他jar， 比如项目中要使用mysql驱动。\r\n\r\n3. 自己写的程序，可以打包为jar 。 存放到仓库。\r\n\r\n   \r\n\r\n仓库的分类：\r\n\r\n1. 本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。\r\n\r\n   本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository\r\n\r\n   ```xml\r\n        C:\\Users\\NING MEI\\.m2\\repository\r\n   ```\r\n\r\n   \r\n\r\n   修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\\conf\\setting.xml）\r\n\r\n   ​	步骤：\r\n\r\n   ​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。\r\n\r\n   ​		   例如： D:\\openrepository\r\n\r\n   ​     2）修改setting.xml文件，指定 D:\\openrepository这个目录\r\n\r\n   ```xml\r\n       <localRepository>D:/openrepository</localRepository>\r\n   ```\r\n\r\n   ​    3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository\r\n\r\n     \r\n\r\n   \r\n\r\n2. 远程仓库： 需要通过联网访问的\r\n\r\n   1）中央仓库： 一个ftp服务器， 存放了所有的资源。 \r\n\r\n   2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。\r\n\r\n   3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。\r\n\r\n\r\n\r\nmaven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。\r\n\r\n\r\n\r\n![image-20201016114322189](images/image-20201016114322189.png)	\r\n\r\n## 2.6 maven的生命周期，插件和命令\r\n\r\nmaven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署\r\n\r\n插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。\r\n\r\n命令： 执行maven功能是 由命令发出的。 比如 mvn compile\r\n\r\n\r\n\r\n单元测试（junit）：\r\n\r\njunit是一个单元测试的工具， 在java中经常使用。\r\n\r\n单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。\r\n\r\n作用：使用junit去测试方法是否完成了要求。 开发人员自测。\r\n\r\n\r\n\r\n使用单元测试：\r\n\r\n1）加入junit的依赖（一些类和方法）\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>junit</groupId>\r\n    <artifactId>junit</artifactId>\r\n    <version>4.12</version>\r\n    <scope>test</scope>\r\n</dependency>\r\n\r\n```\r\n\r\n\r\n\r\n2)在src/test/java 目录中创建测试类文件。 写测试代码\r\n\r\n   单元测试使用的建议：\r\n\r\n​    1.测试类的定义， 名称一般是Test+要测试的类名称\r\n\r\n​    2.测试类它的包名和要测试的类包名一样。\r\n\r\n​    3.在类中定义方法，要测试代码。\r\n\r\n​       方法的定义：public方法， \r\n\r\n​                               没有返回值\r\n\r\n​                               方法名称自定义（建议 Test+测试的方法名称）\r\n\r\n​                               方法没有参数\r\n\r\n   4.在测试类中的方法，可以单独执行。 测试类也可以单独执行\r\n\r\n   5.在方法的上面加入@Test\r\n\r\n\r\n\r\n命令：\r\n\r\n1） mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。\r\n\r\n​      插件： maven-clean-plugin   ， 版本是 2.5\r\n\r\n2）mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。\r\n\r\n​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）\r\n\r\n\r\n\r\n​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件\r\n\r\n​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的                \r\n\r\n​                                                             文件拷贝target/classes目录中。\r\n\r\n3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录\r\n\r\n​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件\r\n\r\n​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的\r\n\r\n\r\n\r\n4）mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。\r\n\r\n​     插件： maven-surefire-plugin 版本 2.12.4\r\n\r\n\r\n\r\n5）mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。\r\n\r\n​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.\r\n\r\n​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。\r\n\r\n\r\n\r\n​    生成的是 ch01-maven-1.0-SNAPSHOT.jar\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n打包的文件名： artifactId-version.packaging\r\n```\r\n\r\n\r\n\r\n6）mvn install : 把生成的打包的文件 ，安装到maven仓库。\r\n\r\n​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。 \r\n\r\n​    查看查看中的jar文件：\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n\r\ngroupId中的值， 如果有 \".\" 前和后都是独立的文件夹。 com\\bjpowernode\r\nartifactId, 独立的文件夹\r\nversion，独立的文件夹\r\n```\r\n\r\n\r\n\r\n   ## 2.7 自定义配置插件\r\n\r\n在pom.xml文件中， build标签中。设置插件\r\n\r\n  \r\n\r\n```xml\r\n<!-- 设置构建项目相关的内容 -->\r\n<build>\r\n  <plugins>\r\n    <!-- 设置插件 -->\r\n	<plugin>\r\n		<groupId>org.apache.maven.plugins</groupId>\r\n		<artifactId>maven-compiler-plugin</artifactId>\r\n		<version>3.8.1</version>\r\n		<configuration>\r\n			<source>1.8</source> <!-- 指定编译代码的jdk版本 -->\r\n			<target>1.8</target> <!-- 运行java程序使用的jdk版本-->\r\n		</configuration>\r\n	</plugin>\r\n  </plugins>\r\n</build> \r\n```\r\n\r\n\r\n# 第三章 Maven和idea的集成\r\n\r\n## 3.1 idea中集成maven\r\n\r\nidea中有一个自带的maven。  我们要让idea使用自己安装的maven。\r\n\r\n1) 选择File- Settings \r\n\r\n![image-20201016151034872](images/image-20201016151034872.png)	\r\n\r\n![image-20201016151528678](images/image-20201016151528678.png)	\r\n\r\n设置项： -DarchetypeCatalog=internal\r\n\r\n\r\n\r\n2） File - Other Settings\r\n\r\n![image-20201016151823967](images/image-20201016151823967.png)\r\n\r\n同上的设置\r\n\r\n\r\n\r\n## 3.2 创建基于maven的普通java项目\r\n\r\n![image-20201016161028977](images/image-20201016161028977.png)	\r\n\r\n\r\n\r\n## 3.3 创建web项目\r\n\r\n![image-20201016170153694](images/image-20201016170153694.png)	\r\n\r\n## 3.4 导入module到idea\r\n\r\n\r\n\r\n![image-20201017085816226](images/image-20201017085816226.png)	\r\n\r\n\r\n\r\n# 4. 第四章 依赖管理\r\n\r\n依赖范围：使用scope表示依赖的范围。 \r\n\r\n依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。\r\n\r\n依赖范围scope ：\r\n\r\n​     compile:默认， 参与构建项目的所有阶段\r\n\r\n​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。\r\n\r\n​    provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包\r\n\r\n​					  明显的是servlet 和jsp 依赖\r\n\r\n\r\n\r\n# 5. 第五章 常用设置\r\n\r\n1)讲的是properties它里面的配置\r\n\r\n```xml\r\n<properties>\r\n<maven.compiler.source>1.8</maven.compiler.source> 源码编译 jdk 版本\r\n<maven.compiler.target>1.8</maven.compiler.target> 运行代码的 jdk 版本\r\n<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> 项目\r\n构建使用的编码，避免中文乱码\r\n<project.reporting.outputEncoding>UTF-8\r\n</project.reporting.outputEncoding> 生成报告的编码\r\n</properties>\r\n```\r\n\r\n\r\n\r\n2) 全局变量\r\n\r\n在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。 \r\n\r\n使用全局变量表示 多个依赖使用的版本号。\r\n\r\n\r\n\r\n使用步骤：\r\n\r\n1.在properties标签中，定义一个标签，指定版本的值\r\n\r\n```xml\r\n<properties>\r\n  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n  <maven.compiler.source>1.8</maven.compiler.source>\r\n  <maven.compiler.target>1.8</maven.compiler.target>\r\n  <!--自定义变量-->\r\n  <spring.version>5.2.5.RELEASE</spring.version>\r\n  <junit.version>4.11</junit.version>\r\n</properties>\r\n```\r\n\r\n\r\n\r\n2. 使用全局变量， 语法 ${变量名}\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>org.springframework</groupId>\r\n  <artifactId>spring-core</artifactId>\r\n  <version>${spring.version}</version>\r\n</dependency>\r\n\r\n<dependency>\r\n  <groupId>org.springframework</groupId>\r\n  <artifactId>spring-web</artifactId>\r\n  <version>${spring.version}</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n3）使用资源插件\r\n\r\n处理的配置文件的信息， maven默认处理配置文件\r\n\r\n①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下\r\n\r\n②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。\r\n\r\n\r\n\r\n```xml\r\n<build>\r\n  <!--资源插件\r\n      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。\r\n  -->\r\n  <resources>\r\n    <resource>\r\n      <directory>src/main/java</directory><!--所在的目录-->\r\n      <includes>\r\n      <!--包括目录下的.properties,.xml 文件都会扫描到-->\r\n        <include>**/*.properties</include>\r\n        <include>**/*.xml</include>\r\n      </includes>\r\n        <!--  filtering 选项 false 不启用过滤器， *.property 已经起到过\r\n        滤的作用了 -->\r\n      <filtering>false</filtering>\r\n    </resource>\r\n  </resources>\r\n</build>\r\n```\r\n\r\n', 'Maven', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 14:09:51', 1, '2023-02-21 14:09:51', 0);
INSERT INTO `lzh_article` VALUES (1627913603273314305, 'Maven', '<h1>Maven 自动化的构建工具</h1>\n<h1>第一章 Maven简介</h1>\n<h2>1.1 软件开发中的阶段</h2>\n<p>需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。</p>\n<p>设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。</p>\n<p>开发阶段：编码实现功能。 编译代码。自我测试</p>\n<p>测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。</p>\n<p>项目的打包，发布阶段： 给用户安装项目</p>\n<h2>1.2 Maven能做什么</h2>\n<p>1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。</p>\n<p>2）管理依赖（管理项目中使用的各种jar包）。</p>\n<p>​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。</p>\n<h2>1.3 没有使用maven怎么管理依赖</h2>\n<p>管理jar ，需要从网络中单独下载某个jar</p>\n<p>需要选择正确版本</p>\n<p>手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。</p>\n<h2>1.4 什么是maven</h2>\n<p>maven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[\'meɪv(ə)n]  或  [\'mevn]。</p>\n<p>maven是项目的自动化构建工具。 管理项目的依赖。</p>\n<h2>1.5 maven中的概念</h2>\n<p>①POM\n②约定的目录结构\n③坐标\n④依赖管理\n⑤仓库管理\n⑥生命周期\n⑦插件和目标\n⑧继承\n⑨聚合</p>\n<h2>1.6 maven工具的获取和安装</h2>\n<p>地址： http://maven.apache.org/  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip</p>\n<p>安装：</p>\n<ol>\n<li>\n<p>确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录</p>\n</li>\n<li>\n<p>解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。</p>\n<p>目录的路径不要有中文， 不要有空格。</p>\n</li>\n<li>\n<p>把maven安装目录中下的bin的路径添加到path中</p>\n</li>\n<li>\n<p>测试maven的安装。 在命令行执行 mvn     -v</p>\n<pre><code class=\"language-xml\">C:\\Users\\NING MEI&gt;mvn -v\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\nMaven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\nJava version: 1.8.0_101, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;\n</code></pre>\n</li>\n</ol>\n<p>maven解压后的目录结构</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010151623012611676959532668.png\" alt=\"image-20201015162301261\" /></p>\n<p>maven的其他安装方式：</p>\n<ol>\n<li>\n<p>确定JAVA_HOME是否有效</p>\n</li>\n<li>\n<p>在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录</p>\n<p>M2_HOME=D:\\tools\\apache-maven-3.3.9</p>\n</li>\n<li>\n<p>在path环境变量中，加入 %M2_HOME%\\bin</p>\n</li>\n<li>\n<p>测试maven的安装，再命令行执行 mvn  -v</p>\n<pre><code class=\"language-xml\">C:\\Users\\NING MEI&gt;mvn -v\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\nMaven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\nJava version: 1.8.0_101, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;\n</code></pre>\n</li>\n</ol>\n<h1>第二章Maven的核心概念</h1>\n<h2>2.1 约定的目录结构</h2>\n<p>maven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。</p>\n<p>一个maven项目是一个文件夹。 比如项目叫做Hello</p>\n<pre><code class=\"language-java\">Hello 项目文件夹\n    \\src\n    	\\main				叫做主程序目录（完成项目功能的代码和配置文件）\n             \\java          源代码（包和相关的类定义）\n    		 \\resources	    配置文件\n    	\\test               放置测试程序代码的（开发人员自己写的测试代码）\n    		 \\java          测试代码的（junit）\n    		 \\resources     测试程序需要的配置文件\n    \\pom.xml                maven的配置文件， 核心文件\n</code></pre>\n<p>maven的使用方式：</p>\n<p>1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等</p>\n<p>2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等</p>\n<h2>2.2 POM</h2>\n<p>POM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。</p>\n<p>maven通过pom.xml文件实现 项目的构建和依赖的管理。</p>\n<pre><code class=\"language-xml\">\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;!-- project是根标签， 后面的是约束文件 --&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    \n    \n  &lt;!-- pom模型的版本， 就是4.0.0 --&gt;  \n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;!-- 坐标 --&gt;  \n  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  \n  &lt;properties&gt;\n     &lt;java.version&gt;1.8&lt;/java.version&gt;\n     &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n     &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n  &lt;/properties&gt;\n  \n&lt;/project&gt;\n</code></pre>\n<h2>2.3 坐标</h2>\n<p>坐标组成是 groupid, artifiactId, version。  坐标概念来自数学。·</p>\n<p>坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav</p>\n<pre><code class=\"language-xml\">  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n\ngroupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。\n         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode\n\n         如果项目规模比较大， 也可以是 域名倒写+大项目名称。\n	     例如： www.baidu.com ,  无人车： com.baidu.appollo\nartifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。\nversion：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。\n         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      \n   \npackaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar\n</code></pre>\n<p>项目使用gav：</p>\n<p>1.每个maven项目，都需要有一个自己的gav</p>\n<p>2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。</p>\n<p>搜索坐标的地址： https://mvnrepository.com/</p>\n<h2>2.4 依赖 dependency</h2>\n<p>依赖：项目中要使用的其他资源（jar）。</p>\n<p>需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用</p>\n<p>需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。</p>\n<p>格式：</p>\n<pre><code class=\"language-xml\">\n&lt;dependencies&gt;\n  \n    &lt;!-- 日志 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n        &lt;version&gt;1.2.17&lt;/version&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!-- mysql驱动 --&gt;\n     &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;version&gt;5.1.16&lt;/version&gt;\n    &lt;/dependency&gt;\n\n&lt;/dependencies&gt; \n\nmaven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar\n</code></pre>\n<h2>2.5 仓库</h2>\n<p>仓库是存东西的，maven的仓库存放的是：</p>\n<ol>\n<li>\n<p>maven工具自己的jar包。</p>\n</li>\n<li>\n<p>第三方的其他jar， 比如项目中要使用mysql驱动。</p>\n</li>\n<li>\n<p>自己写的程序，可以打包为jar 。 存放到仓库。</p>\n</li>\n</ol>\n<p>仓库的分类：</p>\n<ol>\n<li>\n<p>本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。</p>\n<p>本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository</p>\n<pre><code class=\"language-xml\">     C:\\Users\\NING MEI\\.m2\\repository\n</code></pre>\n<p>修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\\conf\\setting.xml）</p>\n<p>​	步骤：</p>\n<p>​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。</p>\n<p>​		   例如： D:\\openrepository</p>\n<p>​     2）修改setting.xml文件，指定 D:\\openrepository这个目录</p>\n<pre><code class=\"language-xml\">    &lt;localRepository&gt;D:/openrepository&lt;/localRepository&gt;\n</code></pre>\n<p>​    3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository</p>\n</li>\n<li>\n<p>远程仓库： 需要通过联网访问的</p>\n<p>1）中央仓库： 一个ftp服务器， 存放了所有的资源。</p>\n<p>2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。</p>\n<p>3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。</p>\n</li>\n</ol>\n<p>maven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161143221891676959532668.png\" alt=\"image-20201016114322189\" /></p>\n<h2>2.6 maven的生命周期，插件和命令</h2>\n<p>maven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署</p>\n<p>插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。</p>\n<p>命令： 执行maven功能是 由命令发出的。 比如 mvn compile</p>\n<p>单元测试（junit）：</p>\n<p>junit是一个单元测试的工具， 在java中经常使用。</p>\n<p>单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。</p>\n<p>作用：使用junit去测试方法是否完成了要求。 开发人员自测。</p>\n<p>使用单元测试：</p>\n<p>1）加入junit的依赖（一些类和方法）</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<p>2)在src/test/java 目录中创建测试类文件。 写测试代码</p>\n<p>单元测试使用的建议：</p>\n<p>​    1.测试类的定义， 名称一般是Test+要测试的类名称</p>\n<p>​    2.测试类它的包名和要测试的类包名一样。</p>\n<p>​    3.在类中定义方法，要测试代码。</p>\n<p>​       方法的定义：public方法，</p>\n<p>​                               没有返回值</p>\n<p>​                               方法名称自定义（建议 Test+测试的方法名称）</p>\n<p>​                               方法没有参数</p>\n<p>4.在测试类中的方法，可以单独执行。 测试类也可以单独执行</p>\n<p>5.在方法的上面加入@Test</p>\n<p>命令：</p>\n<p>1） mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。</p>\n<p>​      插件： maven-clean-plugin   ， 版本是 2.5</p>\n<p>2）mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。</p>\n<p>​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）</p>\n<p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p>\n<p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的</p>\n<p>​                                                             文件拷贝target/classes目录中。</p>\n<p>3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录</p>\n<p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p>\n<p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的</p>\n<p>4）mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。</p>\n<p>​     插件： maven-surefire-plugin 版本 2.12.4</p>\n<p>5）mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。</p>\n<p>​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.</p>\n<p>​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。</p>\n<p>​    生成的是 ch01-maven-1.0-SNAPSHOT.jar</p>\n<pre><code class=\"language-xml\">  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n打包的文件名： artifactId-version.packaging\n</code></pre>\n<p>6）mvn install : 把生成的打包的文件 ，安装到maven仓库。</p>\n<p>​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。</p>\n<p>​    查看查看中的jar文件：</p>\n<pre><code class=\"language-xml\">  &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;\n  &lt;artifactId&gt;ch01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n\ngroupId中的值， 如果有 &quot;.&quot; 前和后都是独立的文件夹。 com\\bjpowernode\nartifactId, 独立的文件夹\nversion，独立的文件夹\n</code></pre>\n<h2>2.7 自定义配置插件</h2>\n<p>在pom.xml文件中， build标签中。设置插件</p>\n<pre><code class=\"language-xml\">&lt;!-- 设置构建项目相关的内容 --&gt;\n&lt;build&gt;\n  &lt;plugins&gt;\n    &lt;!-- 设置插件 --&gt;\n	&lt;plugin&gt;\n		&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n		&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n		&lt;version&gt;3.8.1&lt;/version&gt;\n		&lt;configuration&gt;\n			&lt;source&gt;1.8&lt;/source&gt; &lt;!-- 指定编译代码的jdk版本 --&gt;\n			&lt;target&gt;1.8&lt;/target&gt; &lt;!-- 运行java程序使用的jdk版本--&gt;\n		&lt;/configuration&gt;\n	&lt;/plugin&gt;\n  &lt;/plugins&gt;\n&lt;/build&gt; \n</code></pre>\n<h1>第三章 Maven和idea的集成</h1>\n<h2>3.1 idea中集成maven</h2>\n<p>idea中有一个自带的maven。  我们要让idea使用自己安装的maven。</p>\n<ol>\n<li>选择File- Settings</li>\n</ol>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161510348721676959532668.png\" alt=\"image-20201016151034872\" /></p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161515286781676959532668.png\" alt=\"image-20201016151528678\" /></p>\n<p>设置项： -DarchetypeCatalog=internal</p>\n<p>2） File - Other Settings</p>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161518239671676959532669.png\" alt=\"image-20201016151823967\" /></p>\n<p>同上的设置</p>\n<h2>3.2 创建基于maven的普通java项目</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161610289771676959532668.png\" alt=\"image-20201016161028977\" /></p>\n<h2>3.3 创建web项目</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010161701536941676959532668.png\" alt=\"image-20201016170153694\" /></p>\n<h2>3.4 导入module到idea</h2>\n<p><img src=\"http://1.117.218.230:9000/test/img_image-202010170858162261676959532668.png\" alt=\"image-20201017085816226\" /></p>\n<h1>4. 第四章 依赖管理</h1>\n<p>依赖范围：使用scope表示依赖的范围。</p>\n<p>依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。</p>\n<p>依赖范围scope ：</p>\n<p>​     compile:默认， 参与构建项目的所有阶段</p>\n<p>​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。</p>\n<p>​    provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包</p>\n<p>​					  明显的是servlet 和jsp 依赖</p>\n<h1>5. 第五章 常用设置</h1>\n<p>1)讲的是properties它里面的配置</p>\n<pre><code class=\"language-xml\">&lt;properties&gt;\n&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; 源码编译 jdk 版本\n&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; 运行代码的 jdk 版本\n&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; 项目\n构建使用的编码，避免中文乱码\n&lt;project.reporting.outputEncoding&gt;UTF-8\n&lt;/project.reporting.outputEncoding&gt; 生成报告的编码\n&lt;/properties&gt;\n</code></pre>\n<ol start=\"2\">\n<li>全局变量</li>\n</ol>\n<p>在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。</p>\n<p>使用全局变量表示 多个依赖使用的版本号。</p>\n<p>使用步骤：</p>\n<p>1.在properties标签中，定义一个标签，指定版本的值</p>\n<pre><code class=\"language-xml\">&lt;properties&gt;\n  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n  &lt;!--自定义变量--&gt;\n  &lt;spring.version&gt;5.2.5.RELEASE&lt;/spring.version&gt;\n  &lt;junit.version&gt;4.11&lt;/junit.version&gt;\n&lt;/properties&gt;\n</code></pre>\n<ol start=\"2\">\n<li>使用全局变量， 语法 ${变量名}</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n  &lt;version&gt;${spring.version}&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n  &lt;version&gt;${spring.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>3）使用资源插件</p>\n<p>处理的配置文件的信息， maven默认处理配置文件</p>\n<p>①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下</p>\n<p>②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。</p>\n<pre><code class=\"language-xml\">&lt;build&gt;\n  &lt;!--资源插件\n      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。\n  --&gt;\n  &lt;resources&gt;\n    &lt;resource&gt;\n      &lt;directory&gt;src/main/java&lt;/directory&gt;&lt;!--所在的目录--&gt;\n      &lt;includes&gt;\n      &lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;\n        &lt;include&gt;**/*.properties&lt;/include&gt;\n        &lt;include&gt;**/*.xml&lt;/include&gt;\n      &lt;/includes&gt;\n        &lt;!--  filtering 选项 false 不启用过滤器， *.property 已经起到过\n        滤的作用了 --&gt;\n      &lt;filtering&gt;false&lt;/filtering&gt;\n    &lt;/resource&gt;\n  &lt;/resources&gt;\n&lt;/build&gt;\n</code></pre>\n', '# Maven 自动化的构建工具\r\n\r\n#  第一章 Maven简介\r\n\r\n## 1.1 软件开发中的阶段\r\n\r\n需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。\r\n\r\n设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。\r\n\r\n开发阶段：编码实现功能。 编译代码。自我测试\r\n\r\n测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。\r\n\r\n项目的打包，发布阶段： 给用户安装项目\r\n\r\n\r\n\r\n## 1.2 Maven能做什么\r\n\r\n1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。\r\n\r\n2）管理依赖（管理项目中使用的各种jar包）。\r\n\r\n​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。\r\n\r\n\r\n\r\n## 1.3 没有使用maven怎么管理依赖\r\n\r\n管理jar ，需要从网络中单独下载某个jar \r\n\r\n需要选择正确版本\r\n\r\n手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。\r\n\r\n\r\n\r\n## 1.4 什么是maven\r\n\r\nmaven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[\'meɪv(ə)n]  或  [\'mevn]。\r\n\r\nmaven是项目的自动化构建工具。 管理项目的依赖。\r\n\r\n\r\n\r\n## 1.5 maven中的概念\r\n\r\n①POM\r\n②约定的目录结构\r\n③坐标\r\n④依赖管理\r\n⑤仓库管理\r\n⑥生命周期\r\n⑦插件和目标\r\n⑧继承\r\n⑨聚合\r\n\r\n\r\n\r\n## 1.6 maven工具的获取和安装\r\n\r\n地址： http://maven.apache.org/  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip\r\n\r\n\r\n\r\n安装：\r\n\r\n1. 确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录\r\n\r\n2. 解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。 \r\n\r\n   目录的路径不要有中文， 不要有空格。\r\n\r\n3. 把maven安装目录中下的bin的路径添加到path中\r\n\r\n4. 测试maven的安装。 在命令行执行 mvn     -v\r\n\r\n   ```xml\r\n   C:\\Users\\NING MEI>mvn -v\r\n   Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\r\n   Maven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\r\n   Java version: 1.8.0_101, vendor: Oracle Corporation\r\n   Java home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\r\n   Default locale: zh_CN, platform encoding: GBK\r\n   OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\r\n   ```\r\n\r\n   \r\n\r\nmaven解压后的目录结构\r\n\r\n![image-20201015162301261](http://1.117.218.230:9000/test/img_image-202010151623012611676959532668.png)	\r\n\r\n\r\n\r\nmaven的其他安装方式：\r\n\r\n1. 确定JAVA_HOME是否有效\r\n\r\n2. 在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录\r\n\r\n   M2_HOME=D:\\tools\\apache-maven-3.3.9\r\n\r\n3. 在path环境变量中，加入 %M2_HOME%\\bin    \r\n\r\n4. 测试maven的安装，再命令行执行 mvn  -v\r\n\r\n   ```xml\r\n   C:\\Users\\NING MEI>mvn -v\r\n   Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\r\n   Maven home: D:\\tools\\apache-maven-3.3.9\\bin\\..\r\n   Java version: 1.8.0_101, vendor: Oracle Corporation\r\n   Java home: C:\\Program Files\\Java\\jdk1.8.0_101\\jre\r\n   Default locale: zh_CN, platform encoding: GBK\r\n   OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\r\n   ```\r\n\r\n   \r\n\r\n# 第二章Maven的核心概念\r\n\r\n## 2.1 约定的目录结构\r\n\r\nmaven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。\r\n\r\n一个maven项目是一个文件夹。 比如项目叫做Hello\r\n\r\n```java\r\nHello 项目文件夹\r\n    \\src\r\n    	\\main				叫做主程序目录（完成项目功能的代码和配置文件）\r\n             \\java          源代码（包和相关的类定义）\r\n    		 \\resources	    配置文件\r\n    	\\test               放置测试程序代码的（开发人员自己写的测试代码）\r\n    		 \\java          测试代码的（junit）\r\n    		 \\resources     测试程序需要的配置文件\r\n    \\pom.xml                maven的配置文件， 核心文件\r\n```\r\n\r\n\r\n\r\nmaven的使用方式：\r\n\r\n1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等\r\n\r\n2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等\r\n\r\n\r\n\r\n## 2.2 POM \r\n\r\nPOM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。\r\n\r\nmaven通过pom.xml文件实现 项目的构建和依赖的管理。\r\n\r\n```xml\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<!-- project是根标签， 后面的是约束文件 -->\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    \r\n    \r\n  <!-- pom模型的版本， 就是4.0.0 -->  \r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <!-- 坐标 -->  \r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  \r\n  <properties>\r\n     <java.version>1.8</java.version>\r\n     <maven.compiler.source>1.8</maven.compiler.source>\r\n     <maven.compiler.target>1.8</maven.compiler.target>\r\n  </properties>\r\n  \r\n</project>\r\n```\r\n\r\n\r\n\r\n## 2.3 坐标\r\n\r\n坐标组成是 groupid, artifiactId, version。  坐标概念来自数学。·\r\n\r\n坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n\r\ngroupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。\r\n         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode\r\n\r\n         如果项目规模比较大， 也可以是 域名倒写+大项目名称。\r\n	     例如： www.baidu.com ,  无人车： com.baidu.appollo\r\nartifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。\r\nversion：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。\r\n         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      \r\n   \r\npackaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar\r\n```\r\n\r\n项目使用gav：\r\n\r\n1.每个maven项目，都需要有一个自己的gav\r\n\r\n2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。\r\n\r\n\r\n\r\n搜索坐标的地址： https://mvnrepository.com/\r\n\r\n\r\n\r\n## 2.4 依赖 dependency\r\n\r\n依赖：项目中要使用的其他资源（jar）。  \r\n\r\n需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用\r\n\r\n需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。\r\n\r\n格式：\r\n\r\n```xml\r\n\r\n<dependencies>\r\n  \r\n    <!-- 日志 -->\r\n    <dependency>\r\n        <groupId>log4j</groupId>\r\n        <artifactId>log4j</artifactId>\r\n        <version>1.2.17</version>\r\n    </dependency>\r\n    \r\n    <!-- mysql驱动 -->\r\n     <dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n        <version>5.1.16</version>\r\n    </dependency>\r\n\r\n</dependencies> \r\n\r\nmaven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar\r\n```\r\n\r\n## 2.5 仓库\r\n\r\n仓库是存东西的，maven的仓库存放的是：\r\n\r\n1. maven工具自己的jar包。\r\n\r\n2. 第三方的其他jar， 比如项目中要使用mysql驱动。\r\n\r\n3. 自己写的程序，可以打包为jar 。 存放到仓库。\r\n\r\n   \r\n\r\n仓库的分类：\r\n\r\n1. 本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。\r\n\r\n   本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository\r\n\r\n   ```xml\r\n        C:\\Users\\NING MEI\\.m2\\repository\r\n   ```\r\n\r\n   \r\n\r\n   修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\\conf\\setting.xml）\r\n\r\n   ​	步骤：\r\n\r\n   ​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。\r\n\r\n   ​		   例如： D:\\openrepository\r\n\r\n   ​     2）修改setting.xml文件，指定 D:\\openrepository这个目录\r\n\r\n   ```xml\r\n       <localRepository>D:/openrepository</localRepository>\r\n   ```\r\n\r\n   ​    3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository\r\n\r\n     \r\n\r\n   \r\n\r\n2. 远程仓库： 需要通过联网访问的\r\n\r\n   1）中央仓库： 一个ftp服务器， 存放了所有的资源。 \r\n\r\n   2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。\r\n\r\n   3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。\r\n\r\n\r\n\r\nmaven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。\r\n\r\n\r\n\r\n![image-20201016114322189](http://1.117.218.230:9000/test/img_image-202010161143221891676959532668.png)	\r\n\r\n## 2.6 maven的生命周期，插件和命令\r\n\r\nmaven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署\r\n\r\n插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。\r\n\r\n命令： 执行maven功能是 由命令发出的。 比如 mvn compile\r\n\r\n\r\n\r\n单元测试（junit）：\r\n\r\njunit是一个单元测试的工具， 在java中经常使用。\r\n\r\n单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。\r\n\r\n作用：使用junit去测试方法是否完成了要求。 开发人员自测。\r\n\r\n\r\n\r\n使用单元测试：\r\n\r\n1）加入junit的依赖（一些类和方法）\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>junit</groupId>\r\n    <artifactId>junit</artifactId>\r\n    <version>4.12</version>\r\n    <scope>test</scope>\r\n</dependency>\r\n\r\n```\r\n\r\n\r\n\r\n2)在src/test/java 目录中创建测试类文件。 写测试代码\r\n\r\n   单元测试使用的建议：\r\n\r\n​    1.测试类的定义， 名称一般是Test+要测试的类名称\r\n\r\n​    2.测试类它的包名和要测试的类包名一样。\r\n\r\n​    3.在类中定义方法，要测试代码。\r\n\r\n​       方法的定义：public方法， \r\n\r\n​                               没有返回值\r\n\r\n​                               方法名称自定义（建议 Test+测试的方法名称）\r\n\r\n​                               方法没有参数\r\n\r\n   4.在测试类中的方法，可以单独执行。 测试类也可以单独执行\r\n\r\n   5.在方法的上面加入@Test\r\n\r\n\r\n\r\n命令：\r\n\r\n1） mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。\r\n\r\n​      插件： maven-clean-plugin   ， 版本是 2.5\r\n\r\n2）mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。\r\n\r\n​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）\r\n\r\n\r\n\r\n​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件\r\n\r\n​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的                \r\n\r\n​                                                             文件拷贝target/classes目录中。\r\n\r\n3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录\r\n\r\n​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件\r\n\r\n​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的\r\n\r\n\r\n\r\n4）mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。\r\n\r\n​     插件： maven-surefire-plugin 版本 2.12.4\r\n\r\n\r\n\r\n5）mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。\r\n\r\n​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.\r\n\r\n​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。\r\n\r\n\r\n\r\n​    生成的是 ch01-maven-1.0-SNAPSHOT.jar\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n打包的文件名： artifactId-version.packaging\r\n```\r\n\r\n\r\n\r\n6）mvn install : 把生成的打包的文件 ，安装到maven仓库。\r\n\r\n​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。 \r\n\r\n​    查看查看中的jar文件：\r\n\r\n```xml\r\n  <groupId>com.bjpowernode</groupId>\r\n  <artifactId>ch01-maven</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>jar</packaging>\r\n\r\ngroupId中的值， 如果有 \".\" 前和后都是独立的文件夹。 com\\bjpowernode\r\nartifactId, 独立的文件夹\r\nversion，独立的文件夹\r\n```\r\n\r\n\r\n\r\n   ## 2.7 自定义配置插件\r\n\r\n在pom.xml文件中， build标签中。设置插件\r\n\r\n  \r\n\r\n```xml\r\n<!-- 设置构建项目相关的内容 -->\r\n<build>\r\n  <plugins>\r\n    <!-- 设置插件 -->\r\n	<plugin>\r\n		<groupId>org.apache.maven.plugins</groupId>\r\n		<artifactId>maven-compiler-plugin</artifactId>\r\n		<version>3.8.1</version>\r\n		<configuration>\r\n			<source>1.8</source> <!-- 指定编译代码的jdk版本 -->\r\n			<target>1.8</target> <!-- 运行java程序使用的jdk版本-->\r\n		</configuration>\r\n	</plugin>\r\n  </plugins>\r\n</build> \r\n```\r\n\r\n\r\n# 第三章 Maven和idea的集成\r\n\r\n## 3.1 idea中集成maven\r\n\r\nidea中有一个自带的maven。  我们要让idea使用自己安装的maven。\r\n\r\n1) 选择File- Settings \r\n\r\n![image-20201016151034872](http://1.117.218.230:9000/test/img_image-202010161510348721676959532668.png)	\r\n\r\n![image-20201016151528678](http://1.117.218.230:9000/test/img_image-202010161515286781676959532668.png)	\r\n\r\n设置项： -DarchetypeCatalog=internal\r\n\r\n\r\n\r\n2） File - Other Settings\r\n\r\n![image-20201016151823967](http://1.117.218.230:9000/test/img_image-202010161518239671676959532669.png)\r\n\r\n同上的设置\r\n\r\n\r\n\r\n## 3.2 创建基于maven的普通java项目\r\n\r\n![image-20201016161028977](http://1.117.218.230:9000/test/img_image-202010161610289771676959532668.png)	\r\n\r\n\r\n\r\n## 3.3 创建web项目\r\n\r\n![image-20201016170153694](http://1.117.218.230:9000/test/img_image-202010161701536941676959532668.png)	\r\n\r\n## 3.4 导入module到idea\r\n\r\n\r\n\r\n![image-20201017085816226](http://1.117.218.230:9000/test/img_image-202010170858162261676959532668.png)	\r\n\r\n\r\n\r\n# 4. 第四章 依赖管理\r\n\r\n依赖范围：使用scope表示依赖的范围。 \r\n\r\n依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。\r\n\r\n依赖范围scope ：\r\n\r\n​     compile:默认， 参与构建项目的所有阶段\r\n\r\n​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。\r\n\r\n​    provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包\r\n\r\n​					  明显的是servlet 和jsp 依赖\r\n\r\n\r\n\r\n# 5. 第五章 常用设置\r\n\r\n1)讲的是properties它里面的配置\r\n\r\n```xml\r\n<properties>\r\n<maven.compiler.source>1.8</maven.compiler.source> 源码编译 jdk 版本\r\n<maven.compiler.target>1.8</maven.compiler.target> 运行代码的 jdk 版本\r\n<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> 项目\r\n构建使用的编码，避免中文乱码\r\n<project.reporting.outputEncoding>UTF-8\r\n</project.reporting.outputEncoding> 生成报告的编码\r\n</properties>\r\n```\r\n\r\n\r\n\r\n2) 全局变量\r\n\r\n在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。 \r\n\r\n使用全局变量表示 多个依赖使用的版本号。\r\n\r\n\r\n\r\n使用步骤：\r\n\r\n1.在properties标签中，定义一个标签，指定版本的值\r\n\r\n```xml\r\n<properties>\r\n  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n  <maven.compiler.source>1.8</maven.compiler.source>\r\n  <maven.compiler.target>1.8</maven.compiler.target>\r\n  <!--自定义变量-->\r\n  <spring.version>5.2.5.RELEASE</spring.version>\r\n  <junit.version>4.11</junit.version>\r\n</properties>\r\n```\r\n\r\n\r\n\r\n2. 使用全局变量， 语法 ${变量名}\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>org.springframework</groupId>\r\n  <artifactId>spring-core</artifactId>\r\n  <version>${spring.version}</version>\r\n</dependency>\r\n\r\n<dependency>\r\n  <groupId>org.springframework</groupId>\r\n  <artifactId>spring-web</artifactId>\r\n  <version>${spring.version}</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n3）使用资源插件\r\n\r\n处理的配置文件的信息， maven默认处理配置文件\r\n\r\n①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下\r\n\r\n②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。\r\n\r\n\r\n\r\n```xml\r\n<build>\r\n  <!--资源插件\r\n      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。\r\n  -->\r\n  <resources>\r\n    <resource>\r\n      <directory>src/main/java</directory><!--所在的目录-->\r\n      <includes>\r\n      <!--包括目录下的.properties,.xml 文件都会扫描到-->\r\n        <include>**/*.properties</include>\r\n        <include>**/*.xml</include>\r\n      </includes>\r\n        <!--  filtering 选项 false 不启用过滤器， *.property 已经起到过\r\n        滤的作用了 -->\r\n      <filtering>false</filtering>\r\n    </resource>\r\n  </resources>\r\n</build>\r\n```\r\n\r\n', 'Maven', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-21 14:10:23', 1, '2023-02-21 14:10:23', 1);
INSERT INTO `lzh_article` VALUES (1628269760064036865, 'AJAX', '<h1>AJAX（Asynchronous Javascript And Xml）</h1>\n<h2>传统请求及缺点</h2>\n<ul>\n<li>传统的请求都有哪些？\n<ul>\n<li>直接在浏览器地址栏上输入URL。</li>\n<li>点击超链接</li>\n<li>提交form表单</li>\n<li>使用JS代码发送请求\n<ul>\n<li>window.open(url)</li>\n<li>document.location.href = url</li>\n<li>window.location.href = url</li>\n<li>....</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>传统请求存在的问题\n<ul>\n<li>页面全部刷新导致了用户的体验较差。</li>\n<li>传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）</li>\n<li><img src=\"C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX同步请求.png\" alt=\"AJAX同步请求\" /></li>\n</ul>\n</li>\n</ul>\n<h2>AJAX概述</h2>\n<ul>\n<li>AJAX不能称为一种技术，它是多种技术的综合产物。</li>\n<li>AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。</li>\n<li>什么是异步，什么是同步？\n<ul>\n<li>假设有t1和t2线程，t1和t2线程并发，就是异步。</li>\n<li>假设有t1和t2线程，t2在执行的时候，必须等待t1线程执行到某个位置之后t2才能执行，那么t2在等t1，显然他们是排队的，排队的就是同步。</li>\n<li>AJAX是可以发送异步请求的。也就是说，在同一个浏览器页面当中，可以发送多个ajax请求，这些ajax请求之间不需要等待，是并发的。</li>\n</ul>\n</li>\n<li>AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。</li>\n<li>AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。</li>\n<li>AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）</li>\n<li>AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。</li>\n<li><img src=\"C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX异步请求.png\" alt=\"\" /></li>\n<li><img src=\"C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\对AJAX异步请求的理解.png\" alt=\"\" /></li>\n</ul>\n<h2>XMLHttpRequest对象</h2>\n<ul>\n<li>\n<p>XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。</p>\n</li>\n<li>\n<p>XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。</p>\n</li>\n<li>\n<p>创建XMLHttpRequest对象</p>\n<ul>\n<li>\n<pre><code class=\"language-javascript\">var xhr = new XMLHttpRequest();\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>XMLHttpRequest对象的方法</p>\n</li>\n</ul>\n<p>| 方法                                          | 描述                                                         |\n| :-------------------------------------------- | :----------------------------------------------------------- |\n| abort()                                       | 取消当前请求                                                 |\n| getAllResponseHeaders()                       | 返回头部信息                                                 |\n| getResponseHeader()                           | 返回特定的头部信息                                           |\n| open(<em>method</em>, <em>url</em>, <em>async</em>, <em>user</em>, <em>psw</em>) | 规定请求method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 |\n| send()                                        | 将请求发送到服务器，用于 GET 请求                            |\n| send(<em>string</em>)                                | 将请求发送到服务器，用于 POST 请求                           |\n| setRequestHeader()                            | 向要发送的报头添加标签/值对                                  |</p>\n<ul>\n<li>XMLHttpRequest对象的属性</li>\n</ul>\n<p>| 属性               | 描述                                                         |\n| :----------------- | :----------------------------------------------------------- |\n| onreadystatechange | 定义当 readyState 属性发生变化时被调用的函数                 |\n| readyState         | 保存 XMLHttpRequest 的状态。0：请求未初始化     1：服务器连接已建立     2：请求已收到    3：正在处理请求    4：请求已完成且响应已就绪 |\n| responseText       | 以字符串返回响应数据                                         |\n| responseXML        | 以 XML 数据返回响应数据                                      |\n| status             | 返回请求的状态号200: &quot;OK&quot;403: &quot;Forbidden&quot;404: &quot;Not Found&quot;    |\n| statusText         | 返回状态文本（比如 &quot;OK&quot; 或 &quot;Not Found&quot;）                     |</p>\n<h2>AJAX GET请求</h2>\n<ul>\n<li>\n<p>发送AJAX get请求，前端代码：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;发送ajax get请求&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () {\n        document.getElementById(&quot;btn&quot;).onclick = function () {\n            //1. 创建AJAX核心对象\n            var xhr = new XMLHttpRequest();\n            //2. 注册回调函数\n            xhr.onreadystatechange = function(){\n                if (this.readyState == 4) {\n                    if (this.status == 200) {\n                        // 通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容。\n                        // 并且不管服务器响应回来的是什么，都以普通文本的形势获取。（服务器可能响应回来：普通文本、XML、JSON、HTML...）\n                        // innerHTML属性是javascript中的语法，和ajax的XMLHttpRequest对象无关。\n                        // innerHTML可以设置元素内部的HTML代码。（innerHTML可以将后面的内容当做一段HTML代码解释并执行）\n                        //document.getElementById(&quot;myspan&quot;).innerHTML = this.responseText\n                        document.getElementById(&quot;mydiv&quot;).innerHTML = this.responseText\n                        // innerText也不是AJAX中的，是javascript中的元素属性，和XMLHttpRequest无关。\n                        // innerText也是设置元素中的内容，但是即使后面是一段HTML代码，也是将其看做一个普通字符串设置进去。\n                        //document.getElementById(&quot;myspan&quot;).innerText = this.responseText\n                    }else{\n                        alert(this.status)\n                    }\n                }\n            }\n            //3. 开启通道\n            xhr.open(&quot;GET&quot;, &quot;/ajax/ajaxrequest2&quot;, true)\n            //4. 发送请求\n            xhr.send()\n        }\n    }\n&lt;/script&gt;\n&lt;button id=&quot;btn&quot;&gt;发送ajax get请求&lt;/button&gt;\n&lt;span id=&quot;myspan&quot;&gt;&lt;/span&gt;\n&lt;div id=&quot;mydiv&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n<li>\n<p>发送AJAX get请求，后端代码：</p>\n<pre><code class=\"language-java\">package com.bjpowernode.ajax.servlet;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * @program: 代码\n * @ClassName: AjaxRequest2Servlet\n * @version: 1.0\n * @description:\n * @author: bjpowernode\n * @create: 2022-05-13 10:46\n **/\n\n@WebServlet(&quot;/ajaxrequest2&quot;)\npublic class AjaxRequest2Servlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // 设置响应的内容类型以及字符集\n        response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n        // 获取响应流\n        PrintWriter out = response.getWriter();\n        // 响应\n        out.print(&quot;&lt;font color=\'red\'&gt;用户名已存在！！！&lt;/font&gt;&quot;);\n    }\n}\n\n</code></pre>\n</li>\n<li>\n<p>AJAX get请求如何提交数据呢？</p>\n<ul>\n<li>get请求提交数据是在“请求行”上提交，格式是：url?name=value&amp;name=value&amp;name=value....</li>\n<li>其实这个get请求提交数据的格式是HTTP协议中规定的，遵循协议即可。</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX GET请求的缓存问题</h2>\n<ul>\n<li>对于低版本的IE浏览器来说，AJAX的get请求可能会走缓存。存在缓存问题。对于现代的浏览器来说，大部分浏览器都已经不存在AJAX get缓存问题了。</li>\n<li>什么是AJAX GET请求缓存问题呢？\n<ul>\n<li>在HTTP协议中是这样规定get请求的：get请求会被缓存起来。</li>\n<li>发送AJAX GET请求时，在同一个浏览器上，前后发送的AJAX请求路径一样的话，对于低版本的IE来说，第二次的AJAX GET请求会走缓存，不走服务器。</li>\n</ul>\n</li>\n<li>POST请求在HTTP协议中规定的是：POST请求不会被浏览器缓存。</li>\n<li>GET请求缓存的优缺点：\n<ul>\n<li>优点：直接从浏览器缓存中获取资源，不需要从服务器上重新加载资源，速度较快，用户体验好。</li>\n<li>缺点：无法实时获取最新的服务器资源。</li>\n</ul>\n</li>\n<li>浏览器什么时候会走缓存？\n<ul>\n<li>第一：是一个GET请求</li>\n<li>第二：请求路径已经被浏览器缓存过了。第二次发送请求的时候，这个路径没有变化，会走浏览器缓存。</li>\n</ul>\n</li>\n<li>如果是低版本的IE浏览器，怎么解决AJAX GET请求的缓存问题呢？\n<ul>\n<li>可以在请求路径url后面添加一个时间戳，这个时间戳是随时变化的。所以每一次发送的请求路径都是不一样的，这样就不会走浏览器的缓存问题了。</li>\n<li>可以采用时间戳：&quot;url?t=&quot; + new Date().getTime()</li>\n<li>或者可以通过随机数：&quot;url?t=&quot; + Math.random()</li>\n<li>也可以随机数+时间戳....</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX POST请求</h2>\n<ul>\n<li>\n<p>AJAX POST请求和GET请求的代码区别在哪里？就是前端代码有区别。后端代码没有区别。</p>\n<pre><code class=\"language-javascript\">// 4. 发送AJAX POST请求\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) // 设置请求头的内容类型。模拟form表单提交数据。\n// 获取表单中的数据\nvar username = document.getElementById(&quot;username&quot;).value;\nvar password = document.getElementById(&quot;password&quot;).value;\n// send函数中的参数就是发送的数据，这个数据在“请求体”当中发送。\nxhr.send(&quot;username=&quot;+username+&quot;&amp;password=&quot;+password)\n</code></pre>\n</li>\n<li>\n<p>实现一个案例：使用AJAX POST请求实现用户注册的时候，用户名是否可用。（验证用户名是否可以注册）实现步骤如下：</p>\n<ul>\n<li>在前端，用户输入用户名之后，失去焦点事件blur发生，然后发送AJAX POST请求，提交用户名</li>\n<li>在后端，接收到用户名，连接数据库，根据用户名去表中搜索</li>\n<li>如果用户名已存在\n<ul>\n<li>后端响应消息：对不起，用户名已存在（在前端页面以红色字体展示）</li>\n</ul>\n</li>\n<li>如果用户名不存在\n<ul>\n<li>后端响应消息：用户名可以使用（在前端页面以绿色字体展示）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>实现一个案例：用户点击按钮之后，发送AJAX请求，显示学生列表。</p>\n<ul>\n<li>在后端java程序中拼接HTML代码，然后将HTML代码直接响应到浏览器客户端。这种方式不好，不应该在java代码中编写HTML代码，能否在java程序中直接向前端响应数据？可以，可以在后端拼接JSON格式的字符串，或者XML格式的字符串，将这个字符串发送给前端，前端解析即可。</li>\n</ul>\n</li>\n</ul>\n<h2>基于JSON的数据交换</h2>\n<ul>\n<li>\n<p>在WEB前端中，如何将一个json格式的字符串转换成json对象</p>\n<pre><code class=\"language-javascript\">var jsonStr = &quot;{\\&quot;username\\&quot; : \\&quot;zhangsan\\&quot;, \\&quot;password\\&quot; : \\&quot;1233344\\&quot;}&quot;\nvar jsonObj = JSON.parse(jsonStr)\nconsole.log(jsonObj.username)\nconsole.log(jsonObj.password)\n</code></pre>\n</li>\n<li>\n<p>在后端拼接JSON格式的字符串，响应给前端的浏览器</p>\n<pre><code class=\"language-java\">json.append(&quot;[&quot;);\nwhile (rs.next()) {\n    // 获取每个学生的信息\n    String name = rs.getString(&quot;name&quot;);\n    String age = rs.getString(&quot;age&quot;);\n    String addr = rs.getString(&quot;addr&quot;);\n    // 拼接json格式的字符串\n    // {&quot;name&quot;:&quot;   王五    &quot;,&quot;age&quot;:    20      ,&quot;addr&quot;:&quot;      北京大兴区     &quot;},\n    json.append(&quot;{\\&quot;name\\&quot;:\\&quot;&quot;);\n    json.append(name);\n    json.append(&quot;\\&quot;,\\&quot;age\\&quot;:&quot;);\n    json.append(age);\n    json.append(&quot;,\\&quot;addr\\&quot;:\\&quot;&quot;);\n    json.append(addr);\n    json.append(&quot;\\&quot;},&quot;);\n}\njsonStr = json.substring(0, json.length() - 1) + &quot;]&quot;;\n</code></pre>\n</li>\n<li>\n<p>拼接JSON格式的字符串太痛苦，可以使用阿里巴巴的fastjson组件，它可以将java对象转换成json格式的字符串</p>\n<pre><code class=\"language-java\">List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();\nwhile (rs.next()) {\n    // 取出数据\n    String name = rs.getString(&quot;name&quot;);\n    int age = rs.getInt(&quot;age&quot;);\n    String addr = rs.getString(&quot;addr&quot;);\n    // 将以上数据封装成Student对象\n    Student s = new Student(name, age, addr);\n    // 将Student对象放到List集合\n    studentList.add(s);\n}\n// 将List集合转换成json字符串\njsonStr = JSON.toJSONString(studentList);\n</code></pre>\n<p>注意：使用fastjson需要引入fastjson-1.2.2.jar</p>\n</li>\n</ul>\n<h2>基于XML的数据交换</h2>\n<ul>\n<li>\n<p>注意：如果服务器端响应XML的话，响应的内容类型需要写成：</p>\n<pre><code class=\"language-java\">response.setContentType(&quot;text/xml;charset=UTF-8&quot;);\n</code></pre>\n</li>\n<li>\n<p>xml和JSON都是常用的数据交换格式</p>\n<ul>\n<li>XML体积大，解析麻烦。较少用。</li>\n<li>JSON体积小，解析简单，较常用。</li>\n</ul>\n</li>\n<li>\n<p>基于XML的数据交换，前端代码</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;使用XML完成数据交换&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function(){\n        document.getElementById(&quot;btn&quot;).onclick = function(){\n            // 1.创建XMLHTTPRequest对象\n            var xhr = new XMLHttpRequest();\n            // 2.注册回调函数\n            xhr.onreadystatechange = function () {\n                if (this.readyState == 4) {\n                    if (this.status == 200) {\n                        // 服务器端响应了一个XML字符串，这里怎么接收呢？\n                        // 使用XMLHTTPRequest对象的responseXML属性，接收返回之后，可以自动封装成document对象（文档对象）\n                        var xmlDoc = this.responseXML\n                        //console.log(xmlDoc)\n                        // 获取所有的&lt;student&gt;元素，返回了多个对象，应该是数组。\n                        var students = xmlDoc.getElementsByTagName(&quot;student&quot;)\n                        //console.log(students[0].nodeName)\n                        var html = &quot;&quot;;\n                        for (var i = 0; i &lt; students.length; i++) {\n                            var student = students[i]\n                            // 获取&lt;student&gt;元素下的所有子元素\n                            html += &quot;&lt;tr&gt;&quot;\n                            html += &quot;&lt;td&gt;&quot;+(i+1)+&quot;&lt;/td&gt;&quot;\n                            var nameOrAge = student.childNodes\n                            for (var j = 0; j &lt; nameOrAge.length; j++) {\n                                var node = nameOrAge[j]\n                                if (node.nodeName == &quot;name&quot;) {\n                                    //console.log(&quot;name = &quot; + node.textContent)\n                                    html += &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;/td&gt;&quot;\n                                }\n                                if (node.nodeName == &quot;age&quot;) {\n                                    //console.log(&quot;age = &quot; + node.textContent)\n                                    html += &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;/td&gt;&quot;\n                                }\n                            }\n                            html += &quot;&lt;/tr&gt;&quot;\n                        }\n                        document.getElementById(&quot;stutbody&quot;).innerHTML = html\n                    }else{\n                        alert(this.status)\n                    }\n                }\n            }\n            // 3.开启通道\n            xhr.open(&quot;GET&quot;, &quot;/ajax/ajaxrequest6?t=&quot; + new Date().getTime(), true)\n            // 4.发送请求\n            xhr.send()\n        }\n    }\n&lt;/script&gt;\n&lt;button id=&quot;btn&quot;&gt;显示学生列表&lt;/button&gt;\n&lt;table width=&quot;500px&quot; border=&quot;1px&quot;&gt;\n    &lt;thead&gt;\n    &lt;tr&gt;\n        &lt;th&gt;序号&lt;/th&gt;\n        &lt;th&gt;姓名&lt;/th&gt;\n        &lt;th&gt;年龄&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody id=&quot;stutbody&quot;&gt;\n    &lt;!--&lt;tr&gt;\n        &lt;td&gt;1&lt;/td&gt;\n        &lt;td&gt;zhangsan&lt;/td&gt;\n        &lt;td&gt;20&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;2&lt;/td&gt;\n        &lt;td&gt;lisi&lt;/td&gt;\n        &lt;td&gt;22&lt;/td&gt;\n    &lt;/tr&gt;--&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n<li>\n<p>基于XML的数据交换，后端java程序：</p>\n<pre><code class=\"language-java\">package com.bjpowernode.ajax.servlet;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * @program: 代码\n * @ClassName: AjaxRequest6Servlet\n * @version: 1.0\n * @description: 服务器端返回XML字符串\n * @author: bjpowernode\n * @create: 2022-05-15 11:48\n **/\n@WebServlet(&quot;/ajaxrequest6&quot;)\npublic class AjaxRequest6Servlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // 注意：响应的内容类型是XML。\n        response.setContentType(&quot;text/xml;charset=UTF-8&quot;);\n        PrintWriter out = response.getWriter();\n\n        /*\n        &lt;students&gt;\n            &lt;student&gt;\n                &lt;name&gt;zhangsan&lt;/name&gt;\n                &lt;age&gt;20&lt;/age&gt;\n            &lt;/student&gt;\n            &lt;student&gt;\n                &lt;name&gt;lisi&lt;/name&gt;\n                &lt;age&gt;22&lt;/age&gt;\n            &lt;/student&gt;\n        &lt;/students&gt;\n         */\n\n        StringBuilder xml = new StringBuilder();\n        xml.append(&quot;&lt;students&gt;&quot;);\n        xml.append(&quot;&lt;student&gt;&quot;);\n        xml.append(&quot;&lt;name&gt;zhangsan&lt;/name&gt;&quot;);\n        xml.append(&quot;&lt;age&gt;20&lt;/age&gt;&quot;);\n        xml.append(&quot;&lt;/student&gt;&quot;);\n        xml.append(&quot;&lt;student&gt;&quot;);\n        xml.append(&quot;&lt;name&gt;lisi&lt;/name&gt;&quot;);\n        xml.append(&quot;&lt;age&gt;22&lt;/age&gt;&quot;);\n        xml.append(&quot;&lt;/student&gt;&quot;);\n        xml.append(&quot;&lt;/students&gt;&quot;);\n\n        out.print(xml);\n    }\n}\n\n</code></pre>\n</li>\n</ul>\n<h2>AJAX乱码问题</h2>\n<ul>\n<li>\n<p>测试内容：</p>\n<ul>\n<li>发送ajax get请求\n<ul>\n<li>发送数据到服务器，服务器获取的数据是否乱码？</li>\n<li>服务器响应给前端的中文，会不会乱码？</li>\n</ul>\n</li>\n<li>发送ajax post请求\n<ul>\n<li>发送数据到服务器，服务器获取的数据是否乱码？</li>\n<li>服务器响应给前端的中文，会不会乱码？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>包括还要测试tomcat服务器的版本：</p>\n<ul>\n<li>tomcat10和tomcat9都要进行测试。</li>\n</ul>\n</li>\n<li>\n<p>测试结果：</p>\n<ul>\n<li>\n<p>对于tomcat10来说，关于字符集，我们程序员不需要干涉，不会出现乱码。</p>\n</li>\n<li>\n<p>对于tomcat9来说呢？</p>\n<ul>\n<li>\n<p>响应中文的时候，会出现乱码，怎么解决？</p>\n<pre><code class=\"language-java\">response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n</code></pre>\n</li>\n<li>\n<p>发送ajax post请求的时候，发送给服务器的数据，服务器接收之后乱码，怎么解决？</p>\n<pre><code class=\"language-java\">request.setCharacterEncoding(&quot;UTF-8&quot;);\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX的异步与同步</h2>\n<ul>\n<li>\n<p>什么是异步？什么是同步？</p>\n<ul>\n<li>ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）</li>\n<li>如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。）</li>\n</ul>\n</li>\n<li>\n<p>异步和同步在代码上如何实现？</p>\n<pre><code class=\"language-javascript\">// 假设这个是ajax请求1\n// 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。\n// false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。\nxhr1.open(&quot;请求方式&quot;, &quot;URL&quot;, false)\nxhr1.send()\n\n// 假设这个是ajax请求2\n// 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。\nxhr2.open(&quot;请求方式&quot;, &quot;URL&quot;, true) \nxhr2.send()\n</code></pre>\n</li>\n<li>\n<p>什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）</p>\n<ul>\n<li>举一个例子\n<ul>\n<li>用户注册\n<ul>\n<li>用户名需要发送ajax请求进行校验</li>\n<li>邮箱地址也需要发送ajax请求校验</li>\n<li>其他的也可能需要发送ajax请求。。。</li>\n<li>并且最终注册按钮的时候，也是发送ajax请求进行注册。</li>\n<li>那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX代码封装</h2>\n<ul>\n<li>\n<p>AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。</p>\n</li>\n<li>\n<p>接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）</p>\n</li>\n<li>\n<p>手动开发jQuery，源代码</p>\n<pre><code class=\"language-javascript\">function jQuery(selector){\n    if (typeof selector == &quot;string&quot;) {\n        if (selector.charAt(0) == &quot;#&quot;) {\n            domObj = document.getElementById(selector.substring(1))\n            return new jQuery()\n        }\n    }\n    if (typeof selector == &quot;function&quot;) {\n        window.onload = selector\n    }\n    this.html = function(htmlStr){\n        domObj.innerHTML = htmlStr\n    }\n    this.click = function(fun){\n        domObj.onclick = fun\n    }\n    this.focus = function (fun){\n        domObj.onfocus = fun\n    }\n    this.blur = function(fun) {\n        domObj.onblur = fun\n    }\n    this.change = function (fun){\n        domObj.onchange = fun\n    }\n    this.val = function(v){\n        if (v == undefined) {\n            return domObj.value\n        }else{\n            domObj.value = v\n        }\n    }\n\n    // 静态的方法，发送ajax请求\n    /**\n     * 分析：使用ajax函数发送ajax请求的时候，需要程序员给我们传过来什么？\n     *      请求的方式(type)：GET/POST\n     *      请求的URL(url)：url\n     *      请求时提交的数据(data)：data\n     *      请求时发送异步请求还是同步请求(async)：true表示异步，false表示同步。\n     */\n    jQuery.ajax = function(jsonArgs){\n        // 1.\n        var xhr = new XMLHttpRequest();\n        // 2.\n        xhr.onreadystatechange = function(){\n            if (this.readyState == 4) {\n                if (this.status == 200) {\n                    // 我们这个工具类在封装的时候，先不考虑那么多，假设服务器返回的都是json格式的字符串。\n                    var jsonObj = JSON.parse(this.responseText)\n                    // 调用函数\n                    jsonArgs.success(jsonObj)\n                }\n            }\n        }\n\n        if (jsonArgs.type.toUpperCase() == &quot;POST&quot;) {\n            // 3.\n            xhr.open(&quot;POST&quot;, jsonArgs.url, jsonArgs.async)\n            // 4.\n            xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)\n            xhr.send(jsonArgs.data)\n        }\n\n        if (jsonArgs.type.toUpperCase() == &quot;GET&quot;) {\n            xhr.open(&quot;GET&quot;, jsonArgs.url + &quot;?&quot; + jsonArgs.data, jsonArgs.async)\n            xhr.send()\n        }\n\n    }\n}\n$ = jQuery\n\n// 这里有个细节，执行这个目的是为了让静态方法ajax生效。\nnew jQuery()\n\n\n</code></pre>\n</li>\n<li>\n<p>使用以上库，怎么用？</p>\n<pre><code class=\"language-html\">&lt;script type=&quot;text/javascript&quot; src=&quot;/ajax/js/jQuery-1.0.0.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $(function(){\n        $(&quot;#btn1&quot;).click(function(){\n            $.ajax({\n                type : &quot;POST&quot;,\n                url : &quot;/ajax/ajaxrequest11&quot;,\n                data : &quot;username=&quot; + $(&quot;#username&quot;).val(),\n                async : true,\n                success : function(json){\n                    $(&quot;#div1&quot;).html(json.uname)\n                }\n            })\n        })\n    })\n&lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n<h2>AJAX实现省市联动</h2>\n<ul>\n<li>\n<p>什么是省市联动？</p>\n<ul>\n<li>在网页上，选择对应的省份之后，动态的关联出该省份对应的市。选择对应的市之后，动态的关联出该市对应的区。（首先要清楚需求）</li>\n</ul>\n</li>\n<li>\n<p>进行数据库表的设计</p>\n<ul>\n<li>\n<pre><code>t_area （区域表）\nid(PK-自增)	  code		name		pcode\n---------------------------------------------\n1				001		 河北省		null\n2				002		 河南省		null\n3				003		 石家庄	    001\n4				004		 邯郸			 001\n5				005		 郑州			 002\n6				006		 洛阳			 002\n7				007		 丛台区	    004  \n\n将全国所有的省、市、区、县等信息都存储到一张表当中。\n采用的存储方式实际上是code pcode形势。\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>建表t_area，模拟好数据。</p>\n</li>\n<li>\n<p>首先实现第一个功能：</p>\n<ul>\n<li>页面加载完毕之后，先把省份全部展现出来。</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX跨域问题</h2>\n<h2>AJAX实现搜索联想 自动补全</h2>\n<h2>附录：HTTP状态信息</h2>\n<h3>1xx: 信息</h3>\n<p>| 消息:                   | 描述:                                                        |\n| :---------------------- | :----------------------------------------------------------- |\n| 100 Continue            | 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 |\n| 101 Switching Protocols | 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。   |</p>\n<h3>2xx: 成功</h3>\n<p>| 消息:                             | 描述:                                                        |\n| :-------------------------------- | :----------------------------------------------------------- |\n| 200 OK                            | 请求成功（其后是对GET和POST请求的应答文档。）                |\n| 201 Created                       | 请求被创建完成，同时新的资源被创建。                         |\n| 202 Accepted                      | 供处理的请求已被接受，但是处理未完成。                       |\n| 203 Non-authoritative Information | 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 |\n| 204 No Content                    | 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 |\n| 205 Reset Content                 | 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 |\n| 206 Partial Content               | 客户发送了一个带有Range头的GET请求，服务器完成了它。         |</p>\n<h3>3xx: 重定向</h3>\n<p>| 消息:                  | 描述:                                                        |\n| :--------------------- | :----------------------------------------------------------- |\n| 300 Multiple Choices   | 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 |\n| 301 Moved Permanently  | 所请求的页面已经转移至新的url。                              |\n| 302 Found              | 所请求的页面已经临时转移至新的url。                          |\n| 303 See Other          | 所请求的页面可在别的url下被找到。                            |\n| 304 Not Modified       | 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 |\n| 305 Use Proxy          | 客户请求的文档应该通过Location头所指明的代理服务器提取。     |\n| 306 <em>Unused</em>           | 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。   |\n| 307 Temporary Redirect | 被请求的页面已经临时移至新的url。                            |</p>\n<h3>4xx: 客户端错误</h3>\n<p>| 消息:                             | 描述:                                                        |\n| :-------------------------------- | :----------------------------------------------------------- |\n| 400 Bad Request                   | 服务器未能理解请求。                                         |\n| 401 Unauthorized                  | 被请求的页面需要用户名和密码。                               |\n| 402 Payment Required              | 此代码尚无法使用。                                           |\n| 403 Forbidden                     | 对被请求页面的访问被禁止。                                   |\n| 404 Not Found                     | 服务器无法找到被请求的页面。                                 |\n| 405 Method Not Allowed            | 请求中指定的方法不被允许。                                   |\n| 406 Not Acceptable                | 服务器生成的响应无法被客户端所接受。                         |\n| 407 Proxy Authentication Required | 用户必须首先使用代理服务器进行验证，这样请求才会被处理。     |\n| 408 Request Timeout               | 请求超出了服务器的等待时间。                                 |\n| 409 Conflict                      | 由于冲突，请求无法被完成。                                   |\n| 410 Gone                          | 被请求的页面不可用。                                         |\n| 411 Length Required               | &quot;Content-Length&quot; 未被定义。如果无此内容，服务器不会接受请求。 |\n| 412 Precondition Failed           | 请求中的前提条件被服务器评估为失败。                         |\n| 413 Request Entity Too Large      | 由于所请求的实体的太大，服务器不会接受请求。                 |\n| 414 Request-url Too Long          | 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 |\n| 415 Unsupported Media Type        | 由于媒介类型不被支持，服务器不会接受请求。                   |\n| 416                               | 服务器不能满足客户在请求中指定的Range头。                    |\n| 417 Expectation Failed            |                                                              |</p>\n<h3>5xx: 服务器错误</h3>\n<p>| 消息:                          | 描述:                                              |\n| :----------------------------- | :------------------------------------------------- |\n| 500 Internal Server Error      | 请求未完成。服务器遇到不可预知的情况。             |\n| 501 Not Implemented            | 请求未完成。服务器不支持所请求的功能。             |\n| 502 Bad Gateway                | 请求未完成。服务器从上游服务器收到一个无效的响应。 |\n| 503 Service Unavailable        | 请求未完成。服务器临时过载或当机。                 |\n| 504 Gateway Timeout            | 网关超时。                                         |\n| 505 HTTP Version Not Supported | 服务器不支持请求中指明的HTTP协议版本。             |</p>\n', '# AJAX（Asynchronous Javascript And Xml）\r\n\r\n## 传统请求及缺点\r\n\r\n- 传统的请求都有哪些？\r\n  - 直接在浏览器地址栏上输入URL。\r\n  - 点击超链接\r\n  - 提交form表单\r\n  - 使用JS代码发送请求\r\n    - window.open(url)\r\n    - document.location.href = url\r\n    - window.location.href = url\r\n    - ....\r\n- 传统请求存在的问题\r\n  - 页面全部刷新导致了用户的体验较差。\r\n  - 传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）\r\n  - ![AJAX同步请求](C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX同步请求.png)\r\n\r\n## AJAX概述\r\n\r\n- AJAX不能称为一种技术，它是多种技术的综合产物。\r\n- AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。\r\n- 什么是异步，什么是同步？\r\n  - 假设有t1和t2线程，t1和t2线程并发，就是异步。\r\n  - 假设有t1和t2线程，t2在执行的时候，必须等待t1线程执行到某个位置之后t2才能执行，那么t2在等t1，显然他们是排队的，排队的就是同步。\r\n  - AJAX是可以发送异步请求的。也就是说，在同一个浏览器页面当中，可以发送多个ajax请求，这些ajax请求之间不需要等待，是并发的。\r\n- AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。\r\n- AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。\r\n- AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）\r\n- AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。\r\n- ![](C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX异步请求.png)\r\n- ![](C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\对AJAX异步请求的理解.png)\r\n\r\n## XMLHttpRequest对象\r\n\r\n- XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。\r\n\r\n- XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。\r\n\r\n- 创建XMLHttpRequest对象\r\n\r\n  - ```javascript\r\n    var xhr = new XMLHttpRequest();\r\n    ```\r\n\r\n- XMLHttpRequest对象的方法\r\n\r\n| 方法                                          | 描述                                                         |\r\n| :-------------------------------------------- | :----------------------------------------------------------- |\r\n| abort()                                       | 取消当前请求                                                 |\r\n| getAllResponseHeaders()                       | 返回头部信息                                                 |\r\n| getResponseHeader()                           | 返回特定的头部信息                                           |\r\n| open(*method*, *url*, *async*, *user*, *psw*) | 规定请求method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 |\r\n| send()                                        | 将请求发送到服务器，用于 GET 请求                            |\r\n| send(*string*)                                | 将请求发送到服务器，用于 POST 请求                           |\r\n| setRequestHeader()                            | 向要发送的报头添加标签/值对                                  |\r\n\r\n- XMLHttpRequest对象的属性\r\n\r\n| 属性               | 描述                                                         |\r\n| :----------------- | :----------------------------------------------------------- |\r\n| onreadystatechange | 定义当 readyState 属性发生变化时被调用的函数                 |\r\n| readyState         | 保存 XMLHttpRequest 的状态。0：请求未初始化     1：服务器连接已建立     2：请求已收到    3：正在处理请求    4：请求已完成且响应已就绪 |\r\n| responseText       | 以字符串返回响应数据                                         |\r\n| responseXML        | 以 XML 数据返回响应数据                                      |\r\n| status             | 返回请求的状态号200: \"OK\"403: \"Forbidden\"404: \"Not Found\"    |\r\n| statusText         | 返回状态文本（比如 \"OK\" 或 \"Not Found\"）                     |\r\n\r\n## AJAX GET请求\r\n\r\n- 发送AJAX get请求，前端代码：\r\n\r\n  ```html\r\n  <!DOCTYPE html>\r\n  <html lang=\"en\">\r\n  <head>\r\n      <meta charset=\"UTF-8\">\r\n      <title>发送ajax get请求</title>\r\n  </head>\r\n  <body>\r\n  <script type=\"text/javascript\">\r\n      window.onload = function () {\r\n          document.getElementById(\"btn\").onclick = function () {\r\n              //1. 创建AJAX核心对象\r\n              var xhr = new XMLHttpRequest();\r\n              //2. 注册回调函数\r\n              xhr.onreadystatechange = function(){\r\n                  if (this.readyState == 4) {\r\n                      if (this.status == 200) {\r\n                          // 通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容。\r\n                          // 并且不管服务器响应回来的是什么，都以普通文本的形势获取。（服务器可能响应回来：普通文本、XML、JSON、HTML...）\r\n                          // innerHTML属性是javascript中的语法，和ajax的XMLHttpRequest对象无关。\r\n                          // innerHTML可以设置元素内部的HTML代码。（innerHTML可以将后面的内容当做一段HTML代码解释并执行）\r\n                          //document.getElementById(\"myspan\").innerHTML = this.responseText\r\n                          document.getElementById(\"mydiv\").innerHTML = this.responseText\r\n                          // innerText也不是AJAX中的，是javascript中的元素属性，和XMLHttpRequest无关。\r\n                          // innerText也是设置元素中的内容，但是即使后面是一段HTML代码，也是将其看做一个普通字符串设置进去。\r\n                          //document.getElementById(\"myspan\").innerText = this.responseText\r\n                      }else{\r\n                          alert(this.status)\r\n                      }\r\n                  }\r\n              }\r\n              //3. 开启通道\r\n              xhr.open(\"GET\", \"/ajax/ajaxrequest2\", true)\r\n              //4. 发送请求\r\n              xhr.send()\r\n          }\r\n      }\r\n  </script>\r\n  <button id=\"btn\">发送ajax get请求</button>\r\n  <span id=\"myspan\"></span>\r\n  <div id=\"mydiv\"></div>\r\n  </body>\r\n  </html>\r\n  ```\r\n\r\n- 发送AJAX get请求，后端代码：\r\n\r\n  ```java\r\n  package com.bjpowernode.ajax.servlet;\r\n  \r\n  import jakarta.servlet.ServletException;\r\n  import jakarta.servlet.annotation.WebServlet;\r\n  import jakarta.servlet.http.HttpServlet;\r\n  import jakarta.servlet.http.HttpServletRequest;\r\n  import jakarta.servlet.http.HttpServletResponse;\r\n  \r\n  import java.io.IOException;\r\n  import java.io.PrintWriter;\r\n  \r\n  /**\r\n   * @program: 代码\r\n   * @ClassName: AjaxRequest2Servlet\r\n   * @version: 1.0\r\n   * @description:\r\n   * @author: bjpowernode\r\n   * @create: 2022-05-13 10:46\r\n   **/\r\n  \r\n  @WebServlet(\"/ajaxrequest2\")\r\n  public class AjaxRequest2Servlet extends HttpServlet {\r\n      @Override\r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\n              throws ServletException, IOException {\r\n          // 设置响应的内容类型以及字符集\r\n          response.setContentType(\"text/html;charset=UTF-8\");\r\n          // 获取响应流\r\n          PrintWriter out = response.getWriter();\r\n          // 响应\r\n          out.print(\"<font color=\'red\'>用户名已存在！！！</font>\");\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- AJAX get请求如何提交数据呢？\r\n\r\n  - get请求提交数据是在“请求行”上提交，格式是：url?name=value&name=value&name=value....\r\n  - 其实这个get请求提交数据的格式是HTTP协议中规定的，遵循协议即可。\r\n\r\n## AJAX GET请求的缓存问题\r\n\r\n- 对于低版本的IE浏览器来说，AJAX的get请求可能会走缓存。存在缓存问题。对于现代的浏览器来说，大部分浏览器都已经不存在AJAX get缓存问题了。\r\n- 什么是AJAX GET请求缓存问题呢？\r\n  - 在HTTP协议中是这样规定get请求的：get请求会被缓存起来。\r\n  - 发送AJAX GET请求时，在同一个浏览器上，前后发送的AJAX请求路径一样的话，对于低版本的IE来说，第二次的AJAX GET请求会走缓存，不走服务器。\r\n- POST请求在HTTP协议中规定的是：POST请求不会被浏览器缓存。\r\n- GET请求缓存的优缺点：\r\n  - 优点：直接从浏览器缓存中获取资源，不需要从服务器上重新加载资源，速度较快，用户体验好。\r\n  - 缺点：无法实时获取最新的服务器资源。\r\n- 浏览器什么时候会走缓存？\r\n  - 第一：是一个GET请求\r\n  - 第二：请求路径已经被浏览器缓存过了。第二次发送请求的时候，这个路径没有变化，会走浏览器缓存。\r\n- 如果是低版本的IE浏览器，怎么解决AJAX GET请求的缓存问题呢？\r\n  - 可以在请求路径url后面添加一个时间戳，这个时间戳是随时变化的。所以每一次发送的请求路径都是不一样的，这样就不会走浏览器的缓存问题了。\r\n  - 可以采用时间戳：\"url?t=\" + new Date().getTime()\r\n  - 或者可以通过随机数：\"url?t=\" + Math.random()\r\n  - 也可以随机数+时间戳....\r\n\r\n## AJAX POST请求\r\n\r\n- AJAX POST请求和GET请求的代码区别在哪里？就是前端代码有区别。后端代码没有区别。\r\n\r\n  ```javascript\r\n  // 4. 发送AJAX POST请求\r\n  xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\") // 设置请求头的内容类型。模拟form表单提交数据。\r\n  // 获取表单中的数据\r\n  var username = document.getElementById(\"username\").value;\r\n  var password = document.getElementById(\"password\").value;\r\n  // send函数中的参数就是发送的数据，这个数据在“请求体”当中发送。\r\n  xhr.send(\"username=\"+username+\"&password=\"+password)\r\n  ```\r\n\r\n- 实现一个案例：使用AJAX POST请求实现用户注册的时候，用户名是否可用。（验证用户名是否可以注册）实现步骤如下：\r\n\r\n  - 在前端，用户输入用户名之后，失去焦点事件blur发生，然后发送AJAX POST请求，提交用户名\r\n  - 在后端，接收到用户名，连接数据库，根据用户名去表中搜索\r\n  - 如果用户名已存在\r\n    - 后端响应消息：对不起，用户名已存在（在前端页面以红色字体展示）\r\n  - 如果用户名不存在\r\n    - 后端响应消息：用户名可以使用（在前端页面以绿色字体展示）\r\n\r\n- 实现一个案例：用户点击按钮之后，发送AJAX请求，显示学生列表。\r\n\r\n  - 在后端java程序中拼接HTML代码，然后将HTML代码直接响应到浏览器客户端。这种方式不好，不应该在java代码中编写HTML代码，能否在java程序中直接向前端响应数据？可以，可以在后端拼接JSON格式的字符串，或者XML格式的字符串，将这个字符串发送给前端，前端解析即可。\r\n\r\n\r\n## 基于JSON的数据交换\r\n\r\n- 在WEB前端中，如何将一个json格式的字符串转换成json对象\r\n\r\n  ```javascript\r\n  var jsonStr = \"{\\\"username\\\" : \\\"zhangsan\\\", \\\"password\\\" : \\\"1233344\\\"}\"\r\n  var jsonObj = JSON.parse(jsonStr)\r\n  console.log(jsonObj.username)\r\n  console.log(jsonObj.password)\r\n  ```\r\n\r\n- 在后端拼接JSON格式的字符串，响应给前端的浏览器\r\n\r\n  ```java\r\n  json.append(\"[\");\r\n  while (rs.next()) {\r\n      // 获取每个学生的信息\r\n      String name = rs.getString(\"name\");\r\n      String age = rs.getString(\"age\");\r\n      String addr = rs.getString(\"addr\");\r\n      // 拼接json格式的字符串\r\n      // {\"name\":\"   王五    \",\"age\":    20      ,\"addr\":\"      北京大兴区     \"},\r\n      json.append(\"{\\\"name\\\":\\\"\");\r\n      json.append(name);\r\n      json.append(\"\\\",\\\"age\\\":\");\r\n      json.append(age);\r\n      json.append(\",\\\"addr\\\":\\\"\");\r\n      json.append(addr);\r\n      json.append(\"\\\"},\");\r\n  }\r\n  jsonStr = json.substring(0, json.length() - 1) + \"]\";\r\n  ```\r\n\r\n- 拼接JSON格式的字符串太痛苦，可以使用阿里巴巴的fastjson组件，它可以将java对象转换成json格式的字符串\r\n\r\n  ```java\r\n  List<Student> studentList = new ArrayList<>();\r\n  while (rs.next()) {\r\n      // 取出数据\r\n      String name = rs.getString(\"name\");\r\n      int age = rs.getInt(\"age\");\r\n      String addr = rs.getString(\"addr\");\r\n      // 将以上数据封装成Student对象\r\n      Student s = new Student(name, age, addr);\r\n      // 将Student对象放到List集合\r\n      studentList.add(s);\r\n  }\r\n  // 将List集合转换成json字符串\r\n  jsonStr = JSON.toJSONString(studentList);\r\n  ```\r\n\r\n  注意：使用fastjson需要引入fastjson-1.2.2.jar\r\n\r\n## 基于XML的数据交换\r\n\r\n- 注意：如果服务器端响应XML的话，响应的内容类型需要写成：\r\n\r\n  ```java\r\n  response.setContentType(\"text/xml;charset=UTF-8\");\r\n  ```\r\n\r\n- xml和JSON都是常用的数据交换格式\r\n\r\n  - XML体积大，解析麻烦。较少用。\r\n  - JSON体积小，解析简单，较常用。\r\n\r\n- 基于XML的数据交换，前端代码\r\n\r\n  ```html\r\n  <!DOCTYPE html>\r\n  <html lang=\"en\">\r\n  <head>\r\n      <meta charset=\"UTF-8\">\r\n      <title>使用XML完成数据交换</title>\r\n  </head>\r\n  <body>\r\n  <script type=\"text/javascript\">\r\n      window.onload = function(){\r\n          document.getElementById(\"btn\").onclick = function(){\r\n              // 1.创建XMLHTTPRequest对象\r\n              var xhr = new XMLHttpRequest();\r\n              // 2.注册回调函数\r\n              xhr.onreadystatechange = function () {\r\n                  if (this.readyState == 4) {\r\n                      if (this.status == 200) {\r\n                          // 服务器端响应了一个XML字符串，这里怎么接收呢？\r\n                          // 使用XMLHTTPRequest对象的responseXML属性，接收返回之后，可以自动封装成document对象（文档对象）\r\n                          var xmlDoc = this.responseXML\r\n                          //console.log(xmlDoc)\r\n                          // 获取所有的<student>元素，返回了多个对象，应该是数组。\r\n                          var students = xmlDoc.getElementsByTagName(\"student\")\r\n                          //console.log(students[0].nodeName)\r\n                          var html = \"\";\r\n                          for (var i = 0; i < students.length; i++) {\r\n                              var student = students[i]\r\n                              // 获取<student>元素下的所有子元素\r\n                              html += \"<tr>\"\r\n                              html += \"<td>\"+(i+1)+\"</td>\"\r\n                              var nameOrAge = student.childNodes\r\n                              for (var j = 0; j < nameOrAge.length; j++) {\r\n                                  var node = nameOrAge[j]\r\n                                  if (node.nodeName == \"name\") {\r\n                                      //console.log(\"name = \" + node.textContent)\r\n                                      html += \"<td>\"+node.textContent+\"</td>\"\r\n                                  }\r\n                                  if (node.nodeName == \"age\") {\r\n                                      //console.log(\"age = \" + node.textContent)\r\n                                      html += \"<td>\"+node.textContent+\"</td>\"\r\n                                  }\r\n                              }\r\n                              html += \"</tr>\"\r\n                          }\r\n                          document.getElementById(\"stutbody\").innerHTML = html\r\n                      }else{\r\n                          alert(this.status)\r\n                      }\r\n                  }\r\n              }\r\n              // 3.开启通道\r\n              xhr.open(\"GET\", \"/ajax/ajaxrequest6?t=\" + new Date().getTime(), true)\r\n              // 4.发送请求\r\n              xhr.send()\r\n          }\r\n      }\r\n  </script>\r\n  <button id=\"btn\">显示学生列表</button>\r\n  <table width=\"500px\" border=\"1px\">\r\n      <thead>\r\n      <tr>\r\n          <th>序号</th>\r\n          <th>姓名</th>\r\n          <th>年龄</th>\r\n      </tr>\r\n      </thead>\r\n      <tbody id=\"stutbody\">\r\n      <!--<tr>\r\n          <td>1</td>\r\n          <td>zhangsan</td>\r\n          <td>20</td>\r\n      </tr>\r\n      <tr>\r\n          <td>2</td>\r\n          <td>lisi</td>\r\n          <td>22</td>\r\n      </tr>-->\r\n      </tbody>\r\n  </table>\r\n  </body>\r\n  </html>\r\n  ```\r\n\r\n- 基于XML的数据交换，后端java程序：\r\n\r\n  ```java\r\n  package com.bjpowernode.ajax.servlet;\r\n  \r\n  import jakarta.servlet.ServletException;\r\n  import jakarta.servlet.annotation.WebServlet;\r\n  import jakarta.servlet.http.HttpServlet;\r\n  import jakarta.servlet.http.HttpServletRequest;\r\n  import jakarta.servlet.http.HttpServletResponse;\r\n  \r\n  import java.io.IOException;\r\n  import java.io.PrintWriter;\r\n  \r\n  /**\r\n   * @program: 代码\r\n   * @ClassName: AjaxRequest6Servlet\r\n   * @version: 1.0\r\n   * @description: 服务器端返回XML字符串\r\n   * @author: bjpowernode\r\n   * @create: 2022-05-15 11:48\r\n   **/\r\n  @WebServlet(\"/ajaxrequest6\")\r\n  public class AjaxRequest6Servlet extends HttpServlet {\r\n      @Override\r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\n              throws ServletException, IOException {\r\n          // 注意：响应的内容类型是XML。\r\n          response.setContentType(\"text/xml;charset=UTF-8\");\r\n          PrintWriter out = response.getWriter();\r\n  \r\n          /*\r\n          <students>\r\n              <student>\r\n                  <name>zhangsan</name>\r\n                  <age>20</age>\r\n              </student>\r\n              <student>\r\n                  <name>lisi</name>\r\n                  <age>22</age>\r\n              </student>\r\n          </students>\r\n           */\r\n  \r\n          StringBuilder xml = new StringBuilder();\r\n          xml.append(\"<students>\");\r\n          xml.append(\"<student>\");\r\n          xml.append(\"<name>zhangsan</name>\");\r\n          xml.append(\"<age>20</age>\");\r\n          xml.append(\"</student>\");\r\n          xml.append(\"<student>\");\r\n          xml.append(\"<name>lisi</name>\");\r\n          xml.append(\"<age>22</age>\");\r\n          xml.append(\"</student>\");\r\n          xml.append(\"</students>\");\r\n  \r\n          out.print(xml);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  \r\n\r\n## AJAX乱码问题\r\n\r\n- 测试内容：\r\n\r\n  - 发送ajax get请求\r\n    - 发送数据到服务器，服务器获取的数据是否乱码？\r\n    - 服务器响应给前端的中文，会不会乱码？\r\n  - 发送ajax post请求\r\n    - 发送数据到服务器，服务器获取的数据是否乱码？\r\n    - 服务器响应给前端的中文，会不会乱码？\r\n\r\n- 包括还要测试tomcat服务器的版本：\r\n\r\n  - tomcat10和tomcat9都要进行测试。\r\n\r\n- 测试结果：\r\n\r\n  - 对于tomcat10来说，关于字符集，我们程序员不需要干涉，不会出现乱码。\r\n\r\n  - 对于tomcat9来说呢？\r\n\r\n    - 响应中文的时候，会出现乱码，怎么解决？\r\n\r\n      ```java\r\n      response.setContentType(\"text/html;charset=UTF-8\");\r\n      ```\r\n\r\n    - 发送ajax post请求的时候，发送给服务器的数据，服务器接收之后乱码，怎么解决？\r\n\r\n      ```java\r\n      request.setCharacterEncoding(\"UTF-8\");\r\n      ```\r\n\r\n      \r\n\r\n## AJAX的异步与同步\r\n\r\n- 什么是异步？什么是同步？\r\n\r\n  - ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）\r\n  - 如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。）\r\n\r\n- 异步和同步在代码上如何实现？\r\n\r\n  ```javascript\r\n  // 假设这个是ajax请求1\r\n  // 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。\r\n  // false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。\r\n  xhr1.open(\"请求方式\", \"URL\", false)\r\n  xhr1.send()\r\n  \r\n  // 假设这个是ajax请求2\r\n  // 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。\r\n  xhr2.open(\"请求方式\", \"URL\", true) \r\n  xhr2.send()\r\n  ```\r\n\r\n- 什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）\r\n\r\n  - 举一个例子\r\n    - 用户注册\r\n      - 用户名需要发送ajax请求进行校验\r\n      - 邮箱地址也需要发送ajax请求校验\r\n      - 其他的也可能需要发送ajax请求。。。\r\n      - 并且最终注册按钮的时候，也是发送ajax请求进行注册。\r\n      - 那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。\r\n\r\n## AJAX代码封装\r\n\r\n- AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。\r\n\r\n- 接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）\r\n\r\n- 手动开发jQuery，源代码\r\n\r\n  ```javascript\r\n  function jQuery(selector){\r\n      if (typeof selector == \"string\") {\r\n          if (selector.charAt(0) == \"#\") {\r\n              domObj = document.getElementById(selector.substring(1))\r\n              return new jQuery()\r\n          }\r\n      }\r\n      if (typeof selector == \"function\") {\r\n          window.onload = selector\r\n      }\r\n      this.html = function(htmlStr){\r\n          domObj.innerHTML = htmlStr\r\n      }\r\n      this.click = function(fun){\r\n          domObj.onclick = fun\r\n      }\r\n      this.focus = function (fun){\r\n          domObj.onfocus = fun\r\n      }\r\n      this.blur = function(fun) {\r\n          domObj.onblur = fun\r\n      }\r\n      this.change = function (fun){\r\n          domObj.onchange = fun\r\n      }\r\n      this.val = function(v){\r\n          if (v == undefined) {\r\n              return domObj.value\r\n          }else{\r\n              domObj.value = v\r\n          }\r\n      }\r\n  \r\n      // 静态的方法，发送ajax请求\r\n      /**\r\n       * 分析：使用ajax函数发送ajax请求的时候，需要程序员给我们传过来什么？\r\n       *      请求的方式(type)：GET/POST\r\n       *      请求的URL(url)：url\r\n       *      请求时提交的数据(data)：data\r\n       *      请求时发送异步请求还是同步请求(async)：true表示异步，false表示同步。\r\n       */\r\n      jQuery.ajax = function(jsonArgs){\r\n          // 1.\r\n          var xhr = new XMLHttpRequest();\r\n          // 2.\r\n          xhr.onreadystatechange = function(){\r\n              if (this.readyState == 4) {\r\n                  if (this.status == 200) {\r\n                      // 我们这个工具类在封装的时候，先不考虑那么多，假设服务器返回的都是json格式的字符串。\r\n                      var jsonObj = JSON.parse(this.responseText)\r\n                      // 调用函数\r\n                      jsonArgs.success(jsonObj)\r\n                  }\r\n              }\r\n          }\r\n  \r\n          if (jsonArgs.type.toUpperCase() == \"POST\") {\r\n              // 3.\r\n              xhr.open(\"POST\", jsonArgs.url, jsonArgs.async)\r\n              // 4.\r\n              xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\r\n              xhr.send(jsonArgs.data)\r\n          }\r\n  \r\n          if (jsonArgs.type.toUpperCase() == \"GET\") {\r\n              xhr.open(\"GET\", jsonArgs.url + \"?\" + jsonArgs.data, jsonArgs.async)\r\n              xhr.send()\r\n          }\r\n  \r\n      }\r\n  }\r\n  $ = jQuery\r\n  \r\n  // 这里有个细节，执行这个目的是为了让静态方法ajax生效。\r\n  new jQuery()\r\n  \r\n  \r\n  ```\r\n\r\n- 使用以上库，怎么用？\r\n\r\n  ```html\r\n  <script type=\"text/javascript\" src=\"/ajax/js/jQuery-1.0.0.js\"></script>\r\n  <script type=\"text/javascript\">\r\n      $(function(){\r\n          $(\"#btn1\").click(function(){\r\n              $.ajax({\r\n                  type : \"POST\",\r\n                  url : \"/ajax/ajaxrequest11\",\r\n                  data : \"username=\" + $(\"#username\").val(),\r\n                  async : true,\r\n                  success : function(json){\r\n                      $(\"#div1\").html(json.uname)\r\n                  }\r\n              })\r\n          })\r\n      })\r\n  </script>\r\n  ```\r\n\r\n  \r\n\r\n## AJAX实现省市联动\r\n\r\n- 什么是省市联动？\r\n\r\n  - 在网页上，选择对应的省份之后，动态的关联出该省份对应的市。选择对应的市之后，动态的关联出该市对应的区。（首先要清楚需求）\r\n\r\n- 进行数据库表的设计\r\n\r\n  - ```\r\n    t_area （区域表）\r\n    id(PK-自增)	  code		name		pcode\r\n    ---------------------------------------------\r\n    1				001		 河北省		null\r\n    2				002		 河南省		null\r\n    3				003		 石家庄	    001\r\n    4				004		 邯郸			 001\r\n    5				005		 郑州			 002\r\n    6				006		 洛阳			 002\r\n    7				007		 丛台区	    004  \r\n    \r\n    将全国所有的省、市、区、县等信息都存储到一张表当中。\r\n    采用的存储方式实际上是code pcode形势。\r\n    ```\r\n\r\n- 建表t_area，模拟好数据。\r\n\r\n- 首先实现第一个功能：\r\n\r\n  - 页面加载完毕之后，先把省份全部展现出来。\r\n\r\n## AJAX跨域问题\r\n\r\n\r\n\r\n## AJAX实现搜索联想 自动补全\r\n\r\n\r\n\r\n## 附录：HTTP状态信息\r\n\r\n### 1xx: 信息\r\n\r\n| 消息:                   | 描述:                                                        |\r\n| :---------------------- | :----------------------------------------------------------- |\r\n| 100 Continue            | 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 |\r\n| 101 Switching Protocols | 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。   |\r\n\r\n### 2xx: 成功\r\n\r\n| 消息:                             | 描述:                                                        |\r\n| :-------------------------------- | :----------------------------------------------------------- |\r\n| 200 OK                            | 请求成功（其后是对GET和POST请求的应答文档。）                |\r\n| 201 Created                       | 请求被创建完成，同时新的资源被创建。                         |\r\n| 202 Accepted                      | 供处理的请求已被接受，但是处理未完成。                       |\r\n| 203 Non-authoritative Information | 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 |\r\n| 204 No Content                    | 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 |\r\n| 205 Reset Content                 | 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 |\r\n| 206 Partial Content               | 客户发送了一个带有Range头的GET请求，服务器完成了它。         |\r\n\r\n### 3xx: 重定向\r\n\r\n| 消息:                  | 描述:                                                        |\r\n| :--------------------- | :----------------------------------------------------------- |\r\n| 300 Multiple Choices   | 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 |\r\n| 301 Moved Permanently  | 所请求的页面已经转移至新的url。                              |\r\n| 302 Found              | 所请求的页面已经临时转移至新的url。                          |\r\n| 303 See Other          | 所请求的页面可在别的url下被找到。                            |\r\n| 304 Not Modified       | 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 |\r\n| 305 Use Proxy          | 客户请求的文档应该通过Location头所指明的代理服务器提取。     |\r\n| 306 *Unused*           | 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。   |\r\n| 307 Temporary Redirect | 被请求的页面已经临时移至新的url。                            |\r\n\r\n### 4xx: 客户端错误\r\n\r\n| 消息:                             | 描述:                                                        |\r\n| :-------------------------------- | :----------------------------------------------------------- |\r\n| 400 Bad Request                   | 服务器未能理解请求。                                         |\r\n| 401 Unauthorized                  | 被请求的页面需要用户名和密码。                               |\r\n| 402 Payment Required              | 此代码尚无法使用。                                           |\r\n| 403 Forbidden                     | 对被请求页面的访问被禁止。                                   |\r\n| 404 Not Found                     | 服务器无法找到被请求的页面。                                 |\r\n| 405 Method Not Allowed            | 请求中指定的方法不被允许。                                   |\r\n| 406 Not Acceptable                | 服务器生成的响应无法被客户端所接受。                         |\r\n| 407 Proxy Authentication Required | 用户必须首先使用代理服务器进行验证，这样请求才会被处理。     |\r\n| 408 Request Timeout               | 请求超出了服务器的等待时间。                                 |\r\n| 409 Conflict                      | 由于冲突，请求无法被完成。                                   |\r\n| 410 Gone                          | 被请求的页面不可用。                                         |\r\n| 411 Length Required               | \"Content-Length\" 未被定义。如果无此内容，服务器不会接受请求。 |\r\n| 412 Precondition Failed           | 请求中的前提条件被服务器评估为失败。                         |\r\n| 413 Request Entity Too Large      | 由于所请求的实体的太大，服务器不会接受请求。                 |\r\n| 414 Request-url Too Long          | 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 |\r\n| 415 Unsupported Media Type        | 由于媒介类型不被支持，服务器不会接受请求。                   |\r\n| 416                               | 服务器不能满足客户在请求中指定的Range头。                    |\r\n| 417 Expectation Failed            |                                                              |\r\n\r\n### 5xx: 服务器错误\r\n\r\n| 消息:                          | 描述:                                              |\r\n| :----------------------------- | :------------------------------------------------- |\r\n| 500 Internal Server Error      | 请求未完成。服务器遇到不可预知的情况。             |\r\n| 501 Not Implemented            | 请求未完成。服务器不支持所请求的功能。             |\r\n| 502 Bad Gateway                | 请求未完成。服务器从上游服务器收到一个无效的响应。 |\r\n| 503 Service Unavailable        | 请求未完成。服务器临时过载或当机。                 |\r\n| 504 Gateway Timeout            | 网关超时。                                         |\r\n| 505 HTTP Version Not Supported | 服务器不支持请求中指明的HTTP协议版本。             |\r\n', 'AJAX', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-22 13:45:37', 1, '2023-02-22 13:45:37', 0);
INSERT INTO `lzh_article` VALUES (1628270261736349698, 'AJAX', '<h1>AJAX（Asynchronous Javascript And Xml）</h1>\n<h2>传统请求及缺点</h2>\n<ul>\n<li>传统的请求都有哪些？\n<ul>\n<li>直接在浏览器地址栏上输入URL。</li>\n<li>点击超链接</li>\n<li>提交form表单</li>\n<li>使用JS代码发送请求\n<ul>\n<li>window.open(url)</li>\n<li>document.location.href = url</li>\n<li>window.location.href = url</li>\n<li>....</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>传统请求存在的问题\n<ul>\n<li>页面全部刷新导致了用户的体验较差。</li>\n<li>传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）</li>\n<li><img src=\"C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX同步请求.png\" alt=\"AJAX同步请求\" /></li>\n</ul>\n</li>\n</ul>\n<h2>AJAX概述</h2>\n<ul>\n<li>AJAX不能称为一种技术，它是多种技术的综合产物。</li>\n<li>AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。</li>\n<li>什么是异步，什么是同步？\n<ul>\n<li>假设有t1和t2线程，t1和t2线程并发，就是异步。</li>\n<li>假设有t1和t2线程，t2在执行的时候，必须等待t1线程执行到某个位置之后t2才能执行，那么t2在等t1，显然他们是排队的，排队的就是同步。</li>\n<li>AJAX是可以发送异步请求的。也就是说，在同一个浏览器页面当中，可以发送多个ajax请求，这些ajax请求之间不需要等待，是并发的。</li>\n</ul>\n</li>\n<li>AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。</li>\n<li>AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。</li>\n<li>AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）</li>\n<li>AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。</li>\n<li><img src=\"C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX异步请求.png\" alt=\"\" /></li>\n<li><img src=\"C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\对AJAX异步请求的理解.png\" alt=\"\" /></li>\n</ul>\n<h2>XMLHttpRequest对象</h2>\n<ul>\n<li>\n<p>XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。</p>\n</li>\n<li>\n<p>XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。</p>\n</li>\n<li>\n<p>创建XMLHttpRequest对象</p>\n<ul>\n<li>\n<pre><code class=\"language-javascript\">var xhr = new XMLHttpRequest();\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>XMLHttpRequest对象的方法</p>\n</li>\n</ul>\n<p>| 方法                                          | 描述                                                         |\n| :-------------------------------------------- | :----------------------------------------------------------- |\n| abort()                                       | 取消当前请求                                                 |\n| getAllResponseHeaders()                       | 返回头部信息                                                 |\n| getResponseHeader()                           | 返回特定的头部信息                                           |\n| open(<em>method</em>, <em>url</em>, <em>async</em>, <em>user</em>, <em>psw</em>) | 规定请求method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 |\n| send()                                        | 将请求发送到服务器，用于 GET 请求                            |\n| send(<em>string</em>)                                | 将请求发送到服务器，用于 POST 请求                           |\n| setRequestHeader()                            | 向要发送的报头添加标签/值对                                  |</p>\n<ul>\n<li>XMLHttpRequest对象的属性</li>\n</ul>\n<p>| 属性               | 描述                                                         |\n| :----------------- | :----------------------------------------------------------- |\n| onreadystatechange | 定义当 readyState 属性发生变化时被调用的函数                 |\n| readyState         | 保存 XMLHttpRequest 的状态。0：请求未初始化     1：服务器连接已建立     2：请求已收到    3：正在处理请求    4：请求已完成且响应已就绪 |\n| responseText       | 以字符串返回响应数据                                         |\n| responseXML        | 以 XML 数据返回响应数据                                      |\n| status             | 返回请求的状态号200: &quot;OK&quot;403: &quot;Forbidden&quot;404: &quot;Not Found&quot;    |\n| statusText         | 返回状态文本（比如 &quot;OK&quot; 或 &quot;Not Found&quot;）                     |</p>\n<h2>AJAX GET请求</h2>\n<ul>\n<li>\n<p>发送AJAX get请求，前端代码：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;发送ajax get请求&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () {\n        document.getElementById(&quot;btn&quot;).onclick = function () {\n            //1. 创建AJAX核心对象\n            var xhr = new XMLHttpRequest();\n            //2. 注册回调函数\n            xhr.onreadystatechange = function(){\n                if (this.readyState == 4) {\n                    if (this.status == 200) {\n                        // 通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容。\n                        // 并且不管服务器响应回来的是什么，都以普通文本的形势获取。（服务器可能响应回来：普通文本、XML、JSON、HTML...）\n                        // innerHTML属性是javascript中的语法，和ajax的XMLHttpRequest对象无关。\n                        // innerHTML可以设置元素内部的HTML代码。（innerHTML可以将后面的内容当做一段HTML代码解释并执行）\n                        //document.getElementById(&quot;myspan&quot;).innerHTML = this.responseText\n                        document.getElementById(&quot;mydiv&quot;).innerHTML = this.responseText\n                        // innerText也不是AJAX中的，是javascript中的元素属性，和XMLHttpRequest无关。\n                        // innerText也是设置元素中的内容，但是即使后面是一段HTML代码，也是将其看做一个普通字符串设置进去。\n                        //document.getElementById(&quot;myspan&quot;).innerText = this.responseText\n                    }else{\n                        alert(this.status)\n                    }\n                }\n            }\n            //3. 开启通道\n            xhr.open(&quot;GET&quot;, &quot;/ajax/ajaxrequest2&quot;, true)\n            //4. 发送请求\n            xhr.send()\n        }\n    }\n&lt;/script&gt;\n&lt;button id=&quot;btn&quot;&gt;发送ajax get请求&lt;/button&gt;\n&lt;span id=&quot;myspan&quot;&gt;&lt;/span&gt;\n&lt;div id=&quot;mydiv&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n<li>\n<p>发送AJAX get请求，后端代码：</p>\n<pre><code class=\"language-java\">package com.bjpowernode.ajax.servlet;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * @program: 代码\n * @ClassName: AjaxRequest2Servlet\n * @version: 1.0\n * @description:\n * @author: bjpowernode\n * @create: 2022-05-13 10:46\n **/\n\n@WebServlet(&quot;/ajaxrequest2&quot;)\npublic class AjaxRequest2Servlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // 设置响应的内容类型以及字符集\n        response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n        // 获取响应流\n        PrintWriter out = response.getWriter();\n        // 响应\n        out.print(&quot;&lt;font color=\'red\'&gt;用户名已存在！！！&lt;/font&gt;&quot;);\n    }\n}\n\n</code></pre>\n</li>\n<li>\n<p>AJAX get请求如何提交数据呢？</p>\n<ul>\n<li>get请求提交数据是在“请求行”上提交，格式是：url?name=value&amp;name=value&amp;name=value....</li>\n<li>其实这个get请求提交数据的格式是HTTP协议中规定的，遵循协议即可。</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX GET请求的缓存问题</h2>\n<ul>\n<li>对于低版本的IE浏览器来说，AJAX的get请求可能会走缓存。存在缓存问题。对于现代的浏览器来说，大部分浏览器都已经不存在AJAX get缓存问题了。</li>\n<li>什么是AJAX GET请求缓存问题呢？\n<ul>\n<li>在HTTP协议中是这样规定get请求的：get请求会被缓存起来。</li>\n<li>发送AJAX GET请求时，在同一个浏览器上，前后发送的AJAX请求路径一样的话，对于低版本的IE来说，第二次的AJAX GET请求会走缓存，不走服务器。</li>\n</ul>\n</li>\n<li>POST请求在HTTP协议中规定的是：POST请求不会被浏览器缓存。</li>\n<li>GET请求缓存的优缺点：\n<ul>\n<li>优点：直接从浏览器缓存中获取资源，不需要从服务器上重新加载资源，速度较快，用户体验好。</li>\n<li>缺点：无法实时获取最新的服务器资源。</li>\n</ul>\n</li>\n<li>浏览器什么时候会走缓存？\n<ul>\n<li>第一：是一个GET请求</li>\n<li>第二：请求路径已经被浏览器缓存过了。第二次发送请求的时候，这个路径没有变化，会走浏览器缓存。</li>\n</ul>\n</li>\n<li>如果是低版本的IE浏览器，怎么解决AJAX GET请求的缓存问题呢？\n<ul>\n<li>可以在请求路径url后面添加一个时间戳，这个时间戳是随时变化的。所以每一次发送的请求路径都是不一样的，这样就不会走浏览器的缓存问题了。</li>\n<li>可以采用时间戳：&quot;url?t=&quot; + new Date().getTime()</li>\n<li>或者可以通过随机数：&quot;url?t=&quot; + Math.random()</li>\n<li>也可以随机数+时间戳....</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX POST请求</h2>\n<ul>\n<li>\n<p>AJAX POST请求和GET请求的代码区别在哪里？就是前端代码有区别。后端代码没有区别。</p>\n<pre><code class=\"language-javascript\">// 4. 发送AJAX POST请求\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) // 设置请求头的内容类型。模拟form表单提交数据。\n// 获取表单中的数据\nvar username = document.getElementById(&quot;username&quot;).value;\nvar password = document.getElementById(&quot;password&quot;).value;\n// send函数中的参数就是发送的数据，这个数据在“请求体”当中发送。\nxhr.send(&quot;username=&quot;+username+&quot;&amp;password=&quot;+password)\n</code></pre>\n</li>\n<li>\n<p>实现一个案例：使用AJAX POST请求实现用户注册的时候，用户名是否可用。（验证用户名是否可以注册）实现步骤如下：</p>\n<ul>\n<li>在前端，用户输入用户名之后，失去焦点事件blur发生，然后发送AJAX POST请求，提交用户名</li>\n<li>在后端，接收到用户名，连接数据库，根据用户名去表中搜索</li>\n<li>如果用户名已存在\n<ul>\n<li>后端响应消息：对不起，用户名已存在（在前端页面以红色字体展示）</li>\n</ul>\n</li>\n<li>如果用户名不存在\n<ul>\n<li>后端响应消息：用户名可以使用（在前端页面以绿色字体展示）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>实现一个案例：用户点击按钮之后，发送AJAX请求，显示学生列表。</p>\n<ul>\n<li>在后端java程序中拼接HTML代码，然后将HTML代码直接响应到浏览器客户端。这种方式不好，不应该在java代码中编写HTML代码，能否在java程序中直接向前端响应数据？可以，可以在后端拼接JSON格式的字符串，或者XML格式的字符串，将这个字符串发送给前端，前端解析即可。</li>\n</ul>\n</li>\n</ul>\n<h2>基于JSON的数据交换</h2>\n<ul>\n<li>\n<p>在WEB前端中，如何将一个json格式的字符串转换成json对象</p>\n<pre><code class=\"language-javascript\">var jsonStr = &quot;{\\&quot;username\\&quot; : \\&quot;zhangsan\\&quot;, \\&quot;password\\&quot; : \\&quot;1233344\\&quot;}&quot;\nvar jsonObj = JSON.parse(jsonStr)\nconsole.log(jsonObj.username)\nconsole.log(jsonObj.password)\n</code></pre>\n</li>\n<li>\n<p>在后端拼接JSON格式的字符串，响应给前端的浏览器</p>\n<pre><code class=\"language-java\">json.append(&quot;[&quot;);\nwhile (rs.next()) {\n    // 获取每个学生的信息\n    String name = rs.getString(&quot;name&quot;);\n    String age = rs.getString(&quot;age&quot;);\n    String addr = rs.getString(&quot;addr&quot;);\n    // 拼接json格式的字符串\n    // {&quot;name&quot;:&quot;   王五    &quot;,&quot;age&quot;:    20      ,&quot;addr&quot;:&quot;      北京大兴区     &quot;},\n    json.append(&quot;{\\&quot;name\\&quot;:\\&quot;&quot;);\n    json.append(name);\n    json.append(&quot;\\&quot;,\\&quot;age\\&quot;:&quot;);\n    json.append(age);\n    json.append(&quot;,\\&quot;addr\\&quot;:\\&quot;&quot;);\n    json.append(addr);\n    json.append(&quot;\\&quot;},&quot;);\n}\njsonStr = json.substring(0, json.length() - 1) + &quot;]&quot;;\n</code></pre>\n</li>\n<li>\n<p>拼接JSON格式的字符串太痛苦，可以使用阿里巴巴的fastjson组件，它可以将java对象转换成json格式的字符串</p>\n<pre><code class=\"language-java\">List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();\nwhile (rs.next()) {\n    // 取出数据\n    String name = rs.getString(&quot;name&quot;);\n    int age = rs.getInt(&quot;age&quot;);\n    String addr = rs.getString(&quot;addr&quot;);\n    // 将以上数据封装成Student对象\n    Student s = new Student(name, age, addr);\n    // 将Student对象放到List集合\n    studentList.add(s);\n}\n// 将List集合转换成json字符串\njsonStr = JSON.toJSONString(studentList);\n</code></pre>\n<p>注意：使用fastjson需要引入fastjson-1.2.2.jar</p>\n</li>\n</ul>\n<h2>基于XML的数据交换</h2>\n<ul>\n<li>\n<p>注意：如果服务器端响应XML的话，响应的内容类型需要写成：</p>\n<pre><code class=\"language-java\">response.setContentType(&quot;text/xml;charset=UTF-8&quot;);\n</code></pre>\n</li>\n<li>\n<p>xml和JSON都是常用的数据交换格式</p>\n<ul>\n<li>XML体积大，解析麻烦。较少用。</li>\n<li>JSON体积小，解析简单，较常用。</li>\n</ul>\n</li>\n<li>\n<p>基于XML的数据交换，前端代码</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;使用XML完成数据交换&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function(){\n        document.getElementById(&quot;btn&quot;).onclick = function(){\n            // 1.创建XMLHTTPRequest对象\n            var xhr = new XMLHttpRequest();\n            // 2.注册回调函数\n            xhr.onreadystatechange = function () {\n                if (this.readyState == 4) {\n                    if (this.status == 200) {\n                        // 服务器端响应了一个XML字符串，这里怎么接收呢？\n                        // 使用XMLHTTPRequest对象的responseXML属性，接收返回之后，可以自动封装成document对象（文档对象）\n                        var xmlDoc = this.responseXML\n                        //console.log(xmlDoc)\n                        // 获取所有的&lt;student&gt;元素，返回了多个对象，应该是数组。\n                        var students = xmlDoc.getElementsByTagName(&quot;student&quot;)\n                        //console.log(students[0].nodeName)\n                        var html = &quot;&quot;;\n                        for (var i = 0; i &lt; students.length; i++) {\n                            var student = students[i]\n                            // 获取&lt;student&gt;元素下的所有子元素\n                            html += &quot;&lt;tr&gt;&quot;\n                            html += &quot;&lt;td&gt;&quot;+(i+1)+&quot;&lt;/td&gt;&quot;\n                            var nameOrAge = student.childNodes\n                            for (var j = 0; j &lt; nameOrAge.length; j++) {\n                                var node = nameOrAge[j]\n                                if (node.nodeName == &quot;name&quot;) {\n                                    //console.log(&quot;name = &quot; + node.textContent)\n                                    html += &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;/td&gt;&quot;\n                                }\n                                if (node.nodeName == &quot;age&quot;) {\n                                    //console.log(&quot;age = &quot; + node.textContent)\n                                    html += &quot;&lt;td&gt;&quot;+node.textContent+&quot;&lt;/td&gt;&quot;\n                                }\n                            }\n                            html += &quot;&lt;/tr&gt;&quot;\n                        }\n                        document.getElementById(&quot;stutbody&quot;).innerHTML = html\n                    }else{\n                        alert(this.status)\n                    }\n                }\n            }\n            // 3.开启通道\n            xhr.open(&quot;GET&quot;, &quot;/ajax/ajaxrequest6?t=&quot; + new Date().getTime(), true)\n            // 4.发送请求\n            xhr.send()\n        }\n    }\n&lt;/script&gt;\n&lt;button id=&quot;btn&quot;&gt;显示学生列表&lt;/button&gt;\n&lt;table width=&quot;500px&quot; border=&quot;1px&quot;&gt;\n    &lt;thead&gt;\n    &lt;tr&gt;\n        &lt;th&gt;序号&lt;/th&gt;\n        &lt;th&gt;姓名&lt;/th&gt;\n        &lt;th&gt;年龄&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody id=&quot;stutbody&quot;&gt;\n    &lt;!--&lt;tr&gt;\n        &lt;td&gt;1&lt;/td&gt;\n        &lt;td&gt;zhangsan&lt;/td&gt;\n        &lt;td&gt;20&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;2&lt;/td&gt;\n        &lt;td&gt;lisi&lt;/td&gt;\n        &lt;td&gt;22&lt;/td&gt;\n    &lt;/tr&gt;--&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n<li>\n<p>基于XML的数据交换，后端java程序：</p>\n<pre><code class=\"language-java\">package com.bjpowernode.ajax.servlet;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * @program: 代码\n * @ClassName: AjaxRequest6Servlet\n * @version: 1.0\n * @description: 服务器端返回XML字符串\n * @author: bjpowernode\n * @create: 2022-05-15 11:48\n **/\n@WebServlet(&quot;/ajaxrequest6&quot;)\npublic class AjaxRequest6Servlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        // 注意：响应的内容类型是XML。\n        response.setContentType(&quot;text/xml;charset=UTF-8&quot;);\n        PrintWriter out = response.getWriter();\n\n        /*\n        &lt;students&gt;\n            &lt;student&gt;\n                &lt;name&gt;zhangsan&lt;/name&gt;\n                &lt;age&gt;20&lt;/age&gt;\n            &lt;/student&gt;\n            &lt;student&gt;\n                &lt;name&gt;lisi&lt;/name&gt;\n                &lt;age&gt;22&lt;/age&gt;\n            &lt;/student&gt;\n        &lt;/students&gt;\n         */\n\n        StringBuilder xml = new StringBuilder();\n        xml.append(&quot;&lt;students&gt;&quot;);\n        xml.append(&quot;&lt;student&gt;&quot;);\n        xml.append(&quot;&lt;name&gt;zhangsan&lt;/name&gt;&quot;);\n        xml.append(&quot;&lt;age&gt;20&lt;/age&gt;&quot;);\n        xml.append(&quot;&lt;/student&gt;&quot;);\n        xml.append(&quot;&lt;student&gt;&quot;);\n        xml.append(&quot;&lt;name&gt;lisi&lt;/name&gt;&quot;);\n        xml.append(&quot;&lt;age&gt;22&lt;/age&gt;&quot;);\n        xml.append(&quot;&lt;/student&gt;&quot;);\n        xml.append(&quot;&lt;/students&gt;&quot;);\n\n        out.print(xml);\n    }\n}\n\n</code></pre>\n</li>\n</ul>\n<h2>AJAX乱码问题</h2>\n<ul>\n<li>\n<p>测试内容：</p>\n<ul>\n<li>发送ajax get请求\n<ul>\n<li>发送数据到服务器，服务器获取的数据是否乱码？</li>\n<li>服务器响应给前端的中文，会不会乱码？</li>\n</ul>\n</li>\n<li>发送ajax post请求\n<ul>\n<li>发送数据到服务器，服务器获取的数据是否乱码？</li>\n<li>服务器响应给前端的中文，会不会乱码？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>包括还要测试tomcat服务器的版本：</p>\n<ul>\n<li>tomcat10和tomcat9都要进行测试。</li>\n</ul>\n</li>\n<li>\n<p>测试结果：</p>\n<ul>\n<li>\n<p>对于tomcat10来说，关于字符集，我们程序员不需要干涉，不会出现乱码。</p>\n</li>\n<li>\n<p>对于tomcat9来说呢？</p>\n<ul>\n<li>\n<p>响应中文的时候，会出现乱码，怎么解决？</p>\n<pre><code class=\"language-java\">response.setContentType(&quot;text/html;charset=UTF-8&quot;);\n</code></pre>\n</li>\n<li>\n<p>发送ajax post请求的时候，发送给服务器的数据，服务器接收之后乱码，怎么解决？</p>\n<pre><code class=\"language-java\">request.setCharacterEncoding(&quot;UTF-8&quot;);\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX的异步与同步</h2>\n<ul>\n<li>\n<p>什么是异步？什么是同步？</p>\n<ul>\n<li>ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）</li>\n<li>如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。）</li>\n</ul>\n</li>\n<li>\n<p>异步和同步在代码上如何实现？</p>\n<pre><code class=\"language-javascript\">// 假设这个是ajax请求1\n// 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。\n// false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。\nxhr1.open(&quot;请求方式&quot;, &quot;URL&quot;, false)\nxhr1.send()\n\n// 假设这个是ajax请求2\n// 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。\nxhr2.open(&quot;请求方式&quot;, &quot;URL&quot;, true) \nxhr2.send()\n</code></pre>\n</li>\n<li>\n<p>什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）</p>\n<ul>\n<li>举一个例子\n<ul>\n<li>用户注册\n<ul>\n<li>用户名需要发送ajax请求进行校验</li>\n<li>邮箱地址也需要发送ajax请求校验</li>\n<li>其他的也可能需要发送ajax请求。。。</li>\n<li>并且最终注册按钮的时候，也是发送ajax请求进行注册。</li>\n<li>那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX代码封装</h2>\n<ul>\n<li>\n<p>AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。</p>\n</li>\n<li>\n<p>接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）</p>\n</li>\n<li>\n<p>手动开发jQuery，源代码</p>\n<pre><code class=\"language-javascript\">function jQuery(selector){\n    if (typeof selector == &quot;string&quot;) {\n        if (selector.charAt(0) == &quot;#&quot;) {\n            domObj = document.getElementById(selector.substring(1))\n            return new jQuery()\n        }\n    }\n    if (typeof selector == &quot;function&quot;) {\n        window.onload = selector\n    }\n    this.html = function(htmlStr){\n        domObj.innerHTML = htmlStr\n    }\n    this.click = function(fun){\n        domObj.onclick = fun\n    }\n    this.focus = function (fun){\n        domObj.onfocus = fun\n    }\n    this.blur = function(fun) {\n        domObj.onblur = fun\n    }\n    this.change = function (fun){\n        domObj.onchange = fun\n    }\n    this.val = function(v){\n        if (v == undefined) {\n            return domObj.value\n        }else{\n            domObj.value = v\n        }\n    }\n\n    // 静态的方法，发送ajax请求\n    /**\n     * 分析：使用ajax函数发送ajax请求的时候，需要程序员给我们传过来什么？\n     *      请求的方式(type)：GET/POST\n     *      请求的URL(url)：url\n     *      请求时提交的数据(data)：data\n     *      请求时发送异步请求还是同步请求(async)：true表示异步，false表示同步。\n     */\n    jQuery.ajax = function(jsonArgs){\n        // 1.\n        var xhr = new XMLHttpRequest();\n        // 2.\n        xhr.onreadystatechange = function(){\n            if (this.readyState == 4) {\n                if (this.status == 200) {\n                    // 我们这个工具类在封装的时候，先不考虑那么多，假设服务器返回的都是json格式的字符串。\n                    var jsonObj = JSON.parse(this.responseText)\n                    // 调用函数\n                    jsonArgs.success(jsonObj)\n                }\n            }\n        }\n\n        if (jsonArgs.type.toUpperCase() == &quot;POST&quot;) {\n            // 3.\n            xhr.open(&quot;POST&quot;, jsonArgs.url, jsonArgs.async)\n            // 4.\n            xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)\n            xhr.send(jsonArgs.data)\n        }\n\n        if (jsonArgs.type.toUpperCase() == &quot;GET&quot;) {\n            xhr.open(&quot;GET&quot;, jsonArgs.url + &quot;?&quot; + jsonArgs.data, jsonArgs.async)\n            xhr.send()\n        }\n\n    }\n}\n$ = jQuery\n\n// 这里有个细节，执行这个目的是为了让静态方法ajax生效。\nnew jQuery()\n\n\n</code></pre>\n</li>\n<li>\n<p>使用以上库，怎么用？</p>\n<pre><code class=\"language-html\">&lt;script type=&quot;text/javascript&quot; src=&quot;/ajax/js/jQuery-1.0.0.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $(function(){\n        $(&quot;#btn1&quot;).click(function(){\n            $.ajax({\n                type : &quot;POST&quot;,\n                url : &quot;/ajax/ajaxrequest11&quot;,\n                data : &quot;username=&quot; + $(&quot;#username&quot;).val(),\n                async : true,\n                success : function(json){\n                    $(&quot;#div1&quot;).html(json.uname)\n                }\n            })\n        })\n    })\n&lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n<h2>AJAX实现省市联动</h2>\n<ul>\n<li>\n<p>什么是省市联动？</p>\n<ul>\n<li>在网页上，选择对应的省份之后，动态的关联出该省份对应的市。选择对应的市之后，动态的关联出该市对应的区。（首先要清楚需求）</li>\n</ul>\n</li>\n<li>\n<p>进行数据库表的设计</p>\n<ul>\n<li>\n<pre><code>t_area （区域表）\nid(PK-自增)	  code		name		pcode\n---------------------------------------------\n1				001		 河北省		null\n2				002		 河南省		null\n3				003		 石家庄	    001\n4				004		 邯郸			 001\n5				005		 郑州			 002\n6				006		 洛阳			 002\n7				007		 丛台区	    004  \n\n将全国所有的省、市、区、县等信息都存储到一张表当中。\n采用的存储方式实际上是code pcode形势。\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>建表t_area，模拟好数据。</p>\n</li>\n<li>\n<p>首先实现第一个功能：</p>\n<ul>\n<li>页面加载完毕之后，先把省份全部展现出来。</li>\n</ul>\n</li>\n</ul>\n<h2>AJAX跨域问题</h2>\n<h2>AJAX实现搜索联想 自动补全</h2>\n<h2>附录：HTTP状态信息</h2>\n<h3>1xx: 信息</h3>\n<p>| 消息:                   | 描述:                                                        |\n| :---------------------- | :----------------------------------------------------------- |\n| 100 Continue            | 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 |\n| 101 Switching Protocols | 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。   |</p>\n<h3>2xx: 成功</h3>\n<p>| 消息:                             | 描述:                                                        |\n| :-------------------------------- | :----------------------------------------------------------- |\n| 200 OK                            | 请求成功（其后是对GET和POST请求的应答文档。）                |\n| 201 Created                       | 请求被创建完成，同时新的资源被创建。                         |\n| 202 Accepted                      | 供处理的请求已被接受，但是处理未完成。                       |\n| 203 Non-authoritative Information | 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 |\n| 204 No Content                    | 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 |\n| 205 Reset Content                 | 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 |\n| 206 Partial Content               | 客户发送了一个带有Range头的GET请求，服务器完成了它。         |</p>\n<h3>3xx: 重定向</h3>\n<p>| 消息:                  | 描述:                                                        |\n| :--------------------- | :----------------------------------------------------------- |\n| 300 Multiple Choices   | 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 |\n| 301 Moved Permanently  | 所请求的页面已经转移至新的url。                              |\n| 302 Found              | 所请求的页面已经临时转移至新的url。                          |\n| 303 See Other          | 所请求的页面可在别的url下被找到。                            |\n| 304 Not Modified       | 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 |\n| 305 Use Proxy          | 客户请求的文档应该通过Location头所指明的代理服务器提取。     |\n| 306 <em>Unused</em>           | 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。   |\n| 307 Temporary Redirect | 被请求的页面已经临时移至新的url。                            |</p>\n<h3>4xx: 客户端错误</h3>\n<p>| 消息:                             | 描述:                                                        |\n| :-------------------------------- | :----------------------------------------------------------- |\n| 400 Bad Request                   | 服务器未能理解请求。                                         |\n| 401 Unauthorized                  | 被请求的页面需要用户名和密码。                               |\n| 402 Payment Required              | 此代码尚无法使用。                                           |\n| 403 Forbidden                     | 对被请求页面的访问被禁止。                                   |\n| 404 Not Found                     | 服务器无法找到被请求的页面。                                 |\n| 405 Method Not Allowed            | 请求中指定的方法不被允许。                                   |\n| 406 Not Acceptable                | 服务器生成的响应无法被客户端所接受。                         |\n| 407 Proxy Authentication Required | 用户必须首先使用代理服务器进行验证，这样请求才会被处理。     |\n| 408 Request Timeout               | 请求超出了服务器的等待时间。                                 |\n| 409 Conflict                      | 由于冲突，请求无法被完成。                                   |\n| 410 Gone                          | 被请求的页面不可用。                                         |\n| 411 Length Required               | &quot;Content-Length&quot; 未被定义。如果无此内容，服务器不会接受请求。 |\n| 412 Precondition Failed           | 请求中的前提条件被服务器评估为失败。                         |\n| 413 Request Entity Too Large      | 由于所请求的实体的太大，服务器不会接受请求。                 |\n| 414 Request-url Too Long          | 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 |\n| 415 Unsupported Media Type        | 由于媒介类型不被支持，服务器不会接受请求。                   |\n| 416                               | 服务器不能满足客户在请求中指定的Range头。                    |\n| 417 Expectation Failed            |                                                              |</p>\n<h3>5xx: 服务器错误</h3>\n<p>| 消息:                          | 描述:                                              |\n| :----------------------------- | :------------------------------------------------- |\n| 500 Internal Server Error      | 请求未完成。服务器遇到不可预知的情况。             |\n| 501 Not Implemented            | 请求未完成。服务器不支持所请求的功能。             |\n| 502 Bad Gateway                | 请求未完成。服务器从上游服务器收到一个无效的响应。 |\n| 503 Service Unavailable        | 请求未完成。服务器临时过载或当机。                 |\n| 504 Gateway Timeout            | 网关超时。                                         |\n| 505 HTTP Version Not Supported | 服务器不支持请求中指明的HTTP协议版本。             |</p>\n', '# AJAX（Asynchronous Javascript And Xml）\r\n\r\n## 传统请求及缺点\r\n\r\n- 传统的请求都有哪些？\r\n  - 直接在浏览器地址栏上输入URL。\r\n  - 点击超链接\r\n  - 提交form表单\r\n  - 使用JS代码发送请求\r\n    - window.open(url)\r\n    - document.location.href = url\r\n    - window.location.href = url\r\n    - ....\r\n- 传统请求存在的问题\r\n  - 页面全部刷新导致了用户的体验较差。\r\n  - 传统的请求导致用户的体验有空白期。（用户的体验是不连贯的）\r\n  - ![AJAX同步请求](C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX同步请求.png)\r\n\r\n## AJAX概述\r\n\r\n- AJAX不能称为一种技术，它是多种技术的综合产物。\r\n- AJAX可以让浏览器发送一种特殊的请求，这种请求可以是：异步的。\r\n- 什么是异步，什么是同步？\r\n  - 假设有t1和t2线程，t1和t2线程并发，就是异步。\r\n  - 假设有t1和t2线程，t2在执行的时候，必须等待t1线程执行到某个位置之后t2才能执行，那么t2在等t1，显然他们是排队的，排队的就是同步。\r\n  - AJAX是可以发送异步请求的。也就是说，在同一个浏览器页面当中，可以发送多个ajax请求，这些ajax请求之间不需要等待，是并发的。\r\n- AJAX代码属于WEB前端的JS代码。和后端的java没有关系，后端也可以是php语言，也可以是C语言。\r\n- AJAX 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。\r\n- AJAX可以更新网页的部分，而不需要重新加载整个页面。（页面局部刷新）\r\n- AJAX可以做到在同一个网页中同时启动多个请求，类似于在同一个网页中启动“多线程”，一个“线程”一个“请求”。\r\n- ![](C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\AJAX异步请求.png)\r\n- ![](C:\\Users\\niannian\\Desktop\\AJAX\\笔记\\对AJAX异步请求的理解.png)\r\n\r\n## XMLHttpRequest对象\r\n\r\n- XMLHttpRequest对象是AJAX的核心对象，发送请求以及接收服务器数据的返回，全靠它了。\r\n\r\n- XMLHttpRequest对象，现代浏览器都是支持的，都内置了该对象。直接用即可。\r\n\r\n- 创建XMLHttpRequest对象\r\n\r\n  - ```javascript\r\n    var xhr = new XMLHttpRequest();\r\n    ```\r\n\r\n- XMLHttpRequest对象的方法\r\n\r\n| 方法                                          | 描述                                                         |\r\n| :-------------------------------------------- | :----------------------------------------------------------- |\r\n| abort()                                       | 取消当前请求                                                 |\r\n| getAllResponseHeaders()                       | 返回头部信息                                                 |\r\n| getResponseHeader()                           | 返回特定的头部信息                                           |\r\n| open(*method*, *url*, *async*, *user*, *psw*) | 规定请求method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名称psw：可选的密码 |\r\n| send()                                        | 将请求发送到服务器，用于 GET 请求                            |\r\n| send(*string*)                                | 将请求发送到服务器，用于 POST 请求                           |\r\n| setRequestHeader()                            | 向要发送的报头添加标签/值对                                  |\r\n\r\n- XMLHttpRequest对象的属性\r\n\r\n| 属性               | 描述                                                         |\r\n| :----------------- | :----------------------------------------------------------- |\r\n| onreadystatechange | 定义当 readyState 属性发生变化时被调用的函数                 |\r\n| readyState         | 保存 XMLHttpRequest 的状态。0：请求未初始化     1：服务器连接已建立     2：请求已收到    3：正在处理请求    4：请求已完成且响应已就绪 |\r\n| responseText       | 以字符串返回响应数据                                         |\r\n| responseXML        | 以 XML 数据返回响应数据                                      |\r\n| status             | 返回请求的状态号200: \"OK\"403: \"Forbidden\"404: \"Not Found\"    |\r\n| statusText         | 返回状态文本（比如 \"OK\" 或 \"Not Found\"）                     |\r\n\r\n## AJAX GET请求\r\n\r\n- 发送AJAX get请求，前端代码：\r\n\r\n  ```html\r\n  <!DOCTYPE html>\r\n  <html lang=\"en\">\r\n  <head>\r\n      <meta charset=\"UTF-8\">\r\n      <title>发送ajax get请求</title>\r\n  </head>\r\n  <body>\r\n  <script type=\"text/javascript\">\r\n      window.onload = function () {\r\n          document.getElementById(\"btn\").onclick = function () {\r\n              //1. 创建AJAX核心对象\r\n              var xhr = new XMLHttpRequest();\r\n              //2. 注册回调函数\r\n              xhr.onreadystatechange = function(){\r\n                  if (this.readyState == 4) {\r\n                      if (this.status == 200) {\r\n                          // 通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容。\r\n                          // 并且不管服务器响应回来的是什么，都以普通文本的形势获取。（服务器可能响应回来：普通文本、XML、JSON、HTML...）\r\n                          // innerHTML属性是javascript中的语法，和ajax的XMLHttpRequest对象无关。\r\n                          // innerHTML可以设置元素内部的HTML代码。（innerHTML可以将后面的内容当做一段HTML代码解释并执行）\r\n                          //document.getElementById(\"myspan\").innerHTML = this.responseText\r\n                          document.getElementById(\"mydiv\").innerHTML = this.responseText\r\n                          // innerText也不是AJAX中的，是javascript中的元素属性，和XMLHttpRequest无关。\r\n                          // innerText也是设置元素中的内容，但是即使后面是一段HTML代码，也是将其看做一个普通字符串设置进去。\r\n                          //document.getElementById(\"myspan\").innerText = this.responseText\r\n                      }else{\r\n                          alert(this.status)\r\n                      }\r\n                  }\r\n              }\r\n              //3. 开启通道\r\n              xhr.open(\"GET\", \"/ajax/ajaxrequest2\", true)\r\n              //4. 发送请求\r\n              xhr.send()\r\n          }\r\n      }\r\n  </script>\r\n  <button id=\"btn\">发送ajax get请求</button>\r\n  <span id=\"myspan\"></span>\r\n  <div id=\"mydiv\"></div>\r\n  </body>\r\n  </html>\r\n  ```\r\n\r\n- 发送AJAX get请求，后端代码：\r\n\r\n  ```java\r\n  package com.bjpowernode.ajax.servlet;\r\n  \r\n  import jakarta.servlet.ServletException;\r\n  import jakarta.servlet.annotation.WebServlet;\r\n  import jakarta.servlet.http.HttpServlet;\r\n  import jakarta.servlet.http.HttpServletRequest;\r\n  import jakarta.servlet.http.HttpServletResponse;\r\n  \r\n  import java.io.IOException;\r\n  import java.io.PrintWriter;\r\n  \r\n  /**\r\n   * @program: 代码\r\n   * @ClassName: AjaxRequest2Servlet\r\n   * @version: 1.0\r\n   * @description:\r\n   * @author: bjpowernode\r\n   * @create: 2022-05-13 10:46\r\n   **/\r\n  \r\n  @WebServlet(\"/ajaxrequest2\")\r\n  public class AjaxRequest2Servlet extends HttpServlet {\r\n      @Override\r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\n              throws ServletException, IOException {\r\n          // 设置响应的内容类型以及字符集\r\n          response.setContentType(\"text/html;charset=UTF-8\");\r\n          // 获取响应流\r\n          PrintWriter out = response.getWriter();\r\n          // 响应\r\n          out.print(\"<font color=\'red\'>用户名已存在！！！</font>\");\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- AJAX get请求如何提交数据呢？\r\n\r\n  - get请求提交数据是在“请求行”上提交，格式是：url?name=value&name=value&name=value....\r\n  - 其实这个get请求提交数据的格式是HTTP协议中规定的，遵循协议即可。\r\n\r\n## AJAX GET请求的缓存问题\r\n\r\n- 对于低版本的IE浏览器来说，AJAX的get请求可能会走缓存。存在缓存问题。对于现代的浏览器来说，大部分浏览器都已经不存在AJAX get缓存问题了。\r\n- 什么是AJAX GET请求缓存问题呢？\r\n  - 在HTTP协议中是这样规定get请求的：get请求会被缓存起来。\r\n  - 发送AJAX GET请求时，在同一个浏览器上，前后发送的AJAX请求路径一样的话，对于低版本的IE来说，第二次的AJAX GET请求会走缓存，不走服务器。\r\n- POST请求在HTTP协议中规定的是：POST请求不会被浏览器缓存。\r\n- GET请求缓存的优缺点：\r\n  - 优点：直接从浏览器缓存中获取资源，不需要从服务器上重新加载资源，速度较快，用户体验好。\r\n  - 缺点：无法实时获取最新的服务器资源。\r\n- 浏览器什么时候会走缓存？\r\n  - 第一：是一个GET请求\r\n  - 第二：请求路径已经被浏览器缓存过了。第二次发送请求的时候，这个路径没有变化，会走浏览器缓存。\r\n- 如果是低版本的IE浏览器，怎么解决AJAX GET请求的缓存问题呢？\r\n  - 可以在请求路径url后面添加一个时间戳，这个时间戳是随时变化的。所以每一次发送的请求路径都是不一样的，这样就不会走浏览器的缓存问题了。\r\n  - 可以采用时间戳：\"url?t=\" + new Date().getTime()\r\n  - 或者可以通过随机数：\"url?t=\" + Math.random()\r\n  - 也可以随机数+时间戳....\r\n\r\n## AJAX POST请求\r\n\r\n- AJAX POST请求和GET请求的代码区别在哪里？就是前端代码有区别。后端代码没有区别。\r\n\r\n  ```javascript\r\n  // 4. 发送AJAX POST请求\r\n  xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\") // 设置请求头的内容类型。模拟form表单提交数据。\r\n  // 获取表单中的数据\r\n  var username = document.getElementById(\"username\").value;\r\n  var password = document.getElementById(\"password\").value;\r\n  // send函数中的参数就是发送的数据，这个数据在“请求体”当中发送。\r\n  xhr.send(\"username=\"+username+\"&password=\"+password)\r\n  ```\r\n\r\n- 实现一个案例：使用AJAX POST请求实现用户注册的时候，用户名是否可用。（验证用户名是否可以注册）实现步骤如下：\r\n\r\n  - 在前端，用户输入用户名之后，失去焦点事件blur发生，然后发送AJAX POST请求，提交用户名\r\n  - 在后端，接收到用户名，连接数据库，根据用户名去表中搜索\r\n  - 如果用户名已存在\r\n    - 后端响应消息：对不起，用户名已存在（在前端页面以红色字体展示）\r\n  - 如果用户名不存在\r\n    - 后端响应消息：用户名可以使用（在前端页面以绿色字体展示）\r\n\r\n- 实现一个案例：用户点击按钮之后，发送AJAX请求，显示学生列表。\r\n\r\n  - 在后端java程序中拼接HTML代码，然后将HTML代码直接响应到浏览器客户端。这种方式不好，不应该在java代码中编写HTML代码，能否在java程序中直接向前端响应数据？可以，可以在后端拼接JSON格式的字符串，或者XML格式的字符串，将这个字符串发送给前端，前端解析即可。\r\n\r\n\r\n## 基于JSON的数据交换\r\n\r\n- 在WEB前端中，如何将一个json格式的字符串转换成json对象\r\n\r\n  ```javascript\r\n  var jsonStr = \"{\\\"username\\\" : \\\"zhangsan\\\", \\\"password\\\" : \\\"1233344\\\"}\"\r\n  var jsonObj = JSON.parse(jsonStr)\r\n  console.log(jsonObj.username)\r\n  console.log(jsonObj.password)\r\n  ```\r\n\r\n- 在后端拼接JSON格式的字符串，响应给前端的浏览器\r\n\r\n  ```java\r\n  json.append(\"[\");\r\n  while (rs.next()) {\r\n      // 获取每个学生的信息\r\n      String name = rs.getString(\"name\");\r\n      String age = rs.getString(\"age\");\r\n      String addr = rs.getString(\"addr\");\r\n      // 拼接json格式的字符串\r\n      // {\"name\":\"   王五    \",\"age\":    20      ,\"addr\":\"      北京大兴区     \"},\r\n      json.append(\"{\\\"name\\\":\\\"\");\r\n      json.append(name);\r\n      json.append(\"\\\",\\\"age\\\":\");\r\n      json.append(age);\r\n      json.append(\",\\\"addr\\\":\\\"\");\r\n      json.append(addr);\r\n      json.append(\"\\\"},\");\r\n  }\r\n  jsonStr = json.substring(0, json.length() - 1) + \"]\";\r\n  ```\r\n\r\n- 拼接JSON格式的字符串太痛苦，可以使用阿里巴巴的fastjson组件，它可以将java对象转换成json格式的字符串\r\n\r\n  ```java\r\n  List<Student> studentList = new ArrayList<>();\r\n  while (rs.next()) {\r\n      // 取出数据\r\n      String name = rs.getString(\"name\");\r\n      int age = rs.getInt(\"age\");\r\n      String addr = rs.getString(\"addr\");\r\n      // 将以上数据封装成Student对象\r\n      Student s = new Student(name, age, addr);\r\n      // 将Student对象放到List集合\r\n      studentList.add(s);\r\n  }\r\n  // 将List集合转换成json字符串\r\n  jsonStr = JSON.toJSONString(studentList);\r\n  ```\r\n\r\n  注意：使用fastjson需要引入fastjson-1.2.2.jar\r\n\r\n## 基于XML的数据交换\r\n\r\n- 注意：如果服务器端响应XML的话，响应的内容类型需要写成：\r\n\r\n  ```java\r\n  response.setContentType(\"text/xml;charset=UTF-8\");\r\n  ```\r\n\r\n- xml和JSON都是常用的数据交换格式\r\n\r\n  - XML体积大，解析麻烦。较少用。\r\n  - JSON体积小，解析简单，较常用。\r\n\r\n- 基于XML的数据交换，前端代码\r\n\r\n  ```html\r\n  <!DOCTYPE html>\r\n  <html lang=\"en\">\r\n  <head>\r\n      <meta charset=\"UTF-8\">\r\n      <title>使用XML完成数据交换</title>\r\n  </head>\r\n  <body>\r\n  <script type=\"text/javascript\">\r\n      window.onload = function(){\r\n          document.getElementById(\"btn\").onclick = function(){\r\n              // 1.创建XMLHTTPRequest对象\r\n              var xhr = new XMLHttpRequest();\r\n              // 2.注册回调函数\r\n              xhr.onreadystatechange = function () {\r\n                  if (this.readyState == 4) {\r\n                      if (this.status == 200) {\r\n                          // 服务器端响应了一个XML字符串，这里怎么接收呢？\r\n                          // 使用XMLHTTPRequest对象的responseXML属性，接收返回之后，可以自动封装成document对象（文档对象）\r\n                          var xmlDoc = this.responseXML\r\n                          //console.log(xmlDoc)\r\n                          // 获取所有的<student>元素，返回了多个对象，应该是数组。\r\n                          var students = xmlDoc.getElementsByTagName(\"student\")\r\n                          //console.log(students[0].nodeName)\r\n                          var html = \"\";\r\n                          for (var i = 0; i < students.length; i++) {\r\n                              var student = students[i]\r\n                              // 获取<student>元素下的所有子元素\r\n                              html += \"<tr>\"\r\n                              html += \"<td>\"+(i+1)+\"</td>\"\r\n                              var nameOrAge = student.childNodes\r\n                              for (var j = 0; j < nameOrAge.length; j++) {\r\n                                  var node = nameOrAge[j]\r\n                                  if (node.nodeName == \"name\") {\r\n                                      //console.log(\"name = \" + node.textContent)\r\n                                      html += \"<td>\"+node.textContent+\"</td>\"\r\n                                  }\r\n                                  if (node.nodeName == \"age\") {\r\n                                      //console.log(\"age = \" + node.textContent)\r\n                                      html += \"<td>\"+node.textContent+\"</td>\"\r\n                                  }\r\n                              }\r\n                              html += \"</tr>\"\r\n                          }\r\n                          document.getElementById(\"stutbody\").innerHTML = html\r\n                      }else{\r\n                          alert(this.status)\r\n                      }\r\n                  }\r\n              }\r\n              // 3.开启通道\r\n              xhr.open(\"GET\", \"/ajax/ajaxrequest6?t=\" + new Date().getTime(), true)\r\n              // 4.发送请求\r\n              xhr.send()\r\n          }\r\n      }\r\n  </script>\r\n  <button id=\"btn\">显示学生列表</button>\r\n  <table width=\"500px\" border=\"1px\">\r\n      <thead>\r\n      <tr>\r\n          <th>序号</th>\r\n          <th>姓名</th>\r\n          <th>年龄</th>\r\n      </tr>\r\n      </thead>\r\n      <tbody id=\"stutbody\">\r\n      <!--<tr>\r\n          <td>1</td>\r\n          <td>zhangsan</td>\r\n          <td>20</td>\r\n      </tr>\r\n      <tr>\r\n          <td>2</td>\r\n          <td>lisi</td>\r\n          <td>22</td>\r\n      </tr>-->\r\n      </tbody>\r\n  </table>\r\n  </body>\r\n  </html>\r\n  ```\r\n\r\n- 基于XML的数据交换，后端java程序：\r\n\r\n  ```java\r\n  package com.bjpowernode.ajax.servlet;\r\n  \r\n  import jakarta.servlet.ServletException;\r\n  import jakarta.servlet.annotation.WebServlet;\r\n  import jakarta.servlet.http.HttpServlet;\r\n  import jakarta.servlet.http.HttpServletRequest;\r\n  import jakarta.servlet.http.HttpServletResponse;\r\n  \r\n  import java.io.IOException;\r\n  import java.io.PrintWriter;\r\n  \r\n  /**\r\n   * @program: 代码\r\n   * @ClassName: AjaxRequest6Servlet\r\n   * @version: 1.0\r\n   * @description: 服务器端返回XML字符串\r\n   * @author: bjpowernode\r\n   * @create: 2022-05-15 11:48\r\n   **/\r\n  @WebServlet(\"/ajaxrequest6\")\r\n  public class AjaxRequest6Servlet extends HttpServlet {\r\n      @Override\r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\n              throws ServletException, IOException {\r\n          // 注意：响应的内容类型是XML。\r\n          response.setContentType(\"text/xml;charset=UTF-8\");\r\n          PrintWriter out = response.getWriter();\r\n  \r\n          /*\r\n          <students>\r\n              <student>\r\n                  <name>zhangsan</name>\r\n                  <age>20</age>\r\n              </student>\r\n              <student>\r\n                  <name>lisi</name>\r\n                  <age>22</age>\r\n              </student>\r\n          </students>\r\n           */\r\n  \r\n          StringBuilder xml = new StringBuilder();\r\n          xml.append(\"<students>\");\r\n          xml.append(\"<student>\");\r\n          xml.append(\"<name>zhangsan</name>\");\r\n          xml.append(\"<age>20</age>\");\r\n          xml.append(\"</student>\");\r\n          xml.append(\"<student>\");\r\n          xml.append(\"<name>lisi</name>\");\r\n          xml.append(\"<age>22</age>\");\r\n          xml.append(\"</student>\");\r\n          xml.append(\"</students>\");\r\n  \r\n          out.print(xml);\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  \r\n\r\n## AJAX乱码问题\r\n\r\n- 测试内容：\r\n\r\n  - 发送ajax get请求\r\n    - 发送数据到服务器，服务器获取的数据是否乱码？\r\n    - 服务器响应给前端的中文，会不会乱码？\r\n  - 发送ajax post请求\r\n    - 发送数据到服务器，服务器获取的数据是否乱码？\r\n    - 服务器响应给前端的中文，会不会乱码？\r\n\r\n- 包括还要测试tomcat服务器的版本：\r\n\r\n  - tomcat10和tomcat9都要进行测试。\r\n\r\n- 测试结果：\r\n\r\n  - 对于tomcat10来说，关于字符集，我们程序员不需要干涉，不会出现乱码。\r\n\r\n  - 对于tomcat9来说呢？\r\n\r\n    - 响应中文的时候，会出现乱码，怎么解决？\r\n\r\n      ```java\r\n      response.setContentType(\"text/html;charset=UTF-8\");\r\n      ```\r\n\r\n    - 发送ajax post请求的时候，发送给服务器的数据，服务器接收之后乱码，怎么解决？\r\n\r\n      ```java\r\n      request.setCharacterEncoding(\"UTF-8\");\r\n      ```\r\n\r\n      \r\n\r\n## AJAX的异步与同步\r\n\r\n- 什么是异步？什么是同步？\r\n\r\n  - ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）\r\n  - 如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。）\r\n\r\n- 异步和同步在代码上如何实现？\r\n\r\n  ```javascript\r\n  // 假设这个是ajax请求1\r\n  // 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。\r\n  // false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。\r\n  xhr1.open(\"请求方式\", \"URL\", false)\r\n  xhr1.send()\r\n  \r\n  // 假设这个是ajax请求2\r\n  // 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。\r\n  xhr2.open(\"请求方式\", \"URL\", true) \r\n  xhr2.send()\r\n  ```\r\n\r\n- 什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）\r\n\r\n  - 举一个例子\r\n    - 用户注册\r\n      - 用户名需要发送ajax请求进行校验\r\n      - 邮箱地址也需要发送ajax请求校验\r\n      - 其他的也可能需要发送ajax请求。。。\r\n      - 并且最终注册按钮的时候，也是发送ajax请求进行注册。\r\n      - 那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。\r\n\r\n## AJAX代码封装\r\n\r\n- AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。\r\n\r\n- 接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）\r\n\r\n- 手动开发jQuery，源代码\r\n\r\n  ```javascript\r\n  function jQuery(selector){\r\n      if (typeof selector == \"string\") {\r\n          if (selector.charAt(0) == \"#\") {\r\n              domObj = document.getElementById(selector.substring(1))\r\n              return new jQuery()\r\n          }\r\n      }\r\n      if (typeof selector == \"function\") {\r\n          window.onload = selector\r\n      }\r\n      this.html = function(htmlStr){\r\n          domObj.innerHTML = htmlStr\r\n      }\r\n      this.click = function(fun){\r\n          domObj.onclick = fun\r\n      }\r\n      this.focus = function (fun){\r\n          domObj.onfocus = fun\r\n      }\r\n      this.blur = function(fun) {\r\n          domObj.onblur = fun\r\n      }\r\n      this.change = function (fun){\r\n          domObj.onchange = fun\r\n      }\r\n      this.val = function(v){\r\n          if (v == undefined) {\r\n              return domObj.value\r\n          }else{\r\n              domObj.value = v\r\n          }\r\n      }\r\n  \r\n      // 静态的方法，发送ajax请求\r\n      /**\r\n       * 分析：使用ajax函数发送ajax请求的时候，需要程序员给我们传过来什么？\r\n       *      请求的方式(type)：GET/POST\r\n       *      请求的URL(url)：url\r\n       *      请求时提交的数据(data)：data\r\n       *      请求时发送异步请求还是同步请求(async)：true表示异步，false表示同步。\r\n       */\r\n      jQuery.ajax = function(jsonArgs){\r\n          // 1.\r\n          var xhr = new XMLHttpRequest();\r\n          // 2.\r\n          xhr.onreadystatechange = function(){\r\n              if (this.readyState == 4) {\r\n                  if (this.status == 200) {\r\n                      // 我们这个工具类在封装的时候，先不考虑那么多，假设服务器返回的都是json格式的字符串。\r\n                      var jsonObj = JSON.parse(this.responseText)\r\n                      // 调用函数\r\n                      jsonArgs.success(jsonObj)\r\n                  }\r\n              }\r\n          }\r\n  \r\n          if (jsonArgs.type.toUpperCase() == \"POST\") {\r\n              // 3.\r\n              xhr.open(\"POST\", jsonArgs.url, jsonArgs.async)\r\n              // 4.\r\n              xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\r\n              xhr.send(jsonArgs.data)\r\n          }\r\n  \r\n          if (jsonArgs.type.toUpperCase() == \"GET\") {\r\n              xhr.open(\"GET\", jsonArgs.url + \"?\" + jsonArgs.data, jsonArgs.async)\r\n              xhr.send()\r\n          }\r\n  \r\n      }\r\n  }\r\n  $ = jQuery\r\n  \r\n  // 这里有个细节，执行这个目的是为了让静态方法ajax生效。\r\n  new jQuery()\r\n  \r\n  \r\n  ```\r\n\r\n- 使用以上库，怎么用？\r\n\r\n  ```html\r\n  <script type=\"text/javascript\" src=\"/ajax/js/jQuery-1.0.0.js\"></script>\r\n  <script type=\"text/javascript\">\r\n      $(function(){\r\n          $(\"#btn1\").click(function(){\r\n              $.ajax({\r\n                  type : \"POST\",\r\n                  url : \"/ajax/ajaxrequest11\",\r\n                  data : \"username=\" + $(\"#username\").val(),\r\n                  async : true,\r\n                  success : function(json){\r\n                      $(\"#div1\").html(json.uname)\r\n                  }\r\n              })\r\n          })\r\n      })\r\n  </script>\r\n  ```\r\n\r\n  \r\n\r\n## AJAX实现省市联动\r\n\r\n- 什么是省市联动？\r\n\r\n  - 在网页上，选择对应的省份之后，动态的关联出该省份对应的市。选择对应的市之后，动态的关联出该市对应的区。（首先要清楚需求）\r\n\r\n- 进行数据库表的设计\r\n\r\n  - ```\r\n    t_area （区域表）\r\n    id(PK-自增)	  code		name		pcode\r\n    ---------------------------------------------\r\n    1				001		 河北省		null\r\n    2				002		 河南省		null\r\n    3				003		 石家庄	    001\r\n    4				004		 邯郸			 001\r\n    5				005		 郑州			 002\r\n    6				006		 洛阳			 002\r\n    7				007		 丛台区	    004  \r\n    \r\n    将全国所有的省、市、区、县等信息都存储到一张表当中。\r\n    采用的存储方式实际上是code pcode形势。\r\n    ```\r\n\r\n- 建表t_area，模拟好数据。\r\n\r\n- 首先实现第一个功能：\r\n\r\n  - 页面加载完毕之后，先把省份全部展现出来。\r\n\r\n## AJAX跨域问题\r\n\r\n\r\n\r\n## AJAX实现搜索联想 自动补全\r\n\r\n\r\n\r\n## 附录：HTTP状态信息\r\n\r\n### 1xx: 信息\r\n\r\n| 消息:                   | 描述:                                                        |\r\n| :---------------------- | :----------------------------------------------------------- |\r\n| 100 Continue            | 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 |\r\n| 101 Switching Protocols | 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。   |\r\n\r\n### 2xx: 成功\r\n\r\n| 消息:                             | 描述:                                                        |\r\n| :-------------------------------- | :----------------------------------------------------------- |\r\n| 200 OK                            | 请求成功（其后是对GET和POST请求的应答文档。）                |\r\n| 201 Created                       | 请求被创建完成，同时新的资源被创建。                         |\r\n| 202 Accepted                      | 供处理的请求已被接受，但是处理未完成。                       |\r\n| 203 Non-authoritative Information | 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 |\r\n| 204 No Content                    | 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 |\r\n| 205 Reset Content                 | 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 |\r\n| 206 Partial Content               | 客户发送了一个带有Range头的GET请求，服务器完成了它。         |\r\n\r\n### 3xx: 重定向\r\n\r\n| 消息:                  | 描述:                                                        |\r\n| :--------------------- | :----------------------------------------------------------- |\r\n| 300 Multiple Choices   | 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 |\r\n| 301 Moved Permanently  | 所请求的页面已经转移至新的url。                              |\r\n| 302 Found              | 所请求的页面已经临时转移至新的url。                          |\r\n| 303 See Other          | 所请求的页面可在别的url下被找到。                            |\r\n| 304 Not Modified       | 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 |\r\n| 305 Use Proxy          | 客户请求的文档应该通过Location头所指明的代理服务器提取。     |\r\n| 306 *Unused*           | 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。   |\r\n| 307 Temporary Redirect | 被请求的页面已经临时移至新的url。                            |\r\n\r\n### 4xx: 客户端错误\r\n\r\n| 消息:                             | 描述:                                                        |\r\n| :-------------------------------- | :----------------------------------------------------------- |\r\n| 400 Bad Request                   | 服务器未能理解请求。                                         |\r\n| 401 Unauthorized                  | 被请求的页面需要用户名和密码。                               |\r\n| 402 Payment Required              | 此代码尚无法使用。                                           |\r\n| 403 Forbidden                     | 对被请求页面的访问被禁止。                                   |\r\n| 404 Not Found                     | 服务器无法找到被请求的页面。                                 |\r\n| 405 Method Not Allowed            | 请求中指定的方法不被允许。                                   |\r\n| 406 Not Acceptable                | 服务器生成的响应无法被客户端所接受。                         |\r\n| 407 Proxy Authentication Required | 用户必须首先使用代理服务器进行验证，这样请求才会被处理。     |\r\n| 408 Request Timeout               | 请求超出了服务器的等待时间。                                 |\r\n| 409 Conflict                      | 由于冲突，请求无法被完成。                                   |\r\n| 410 Gone                          | 被请求的页面不可用。                                         |\r\n| 411 Length Required               | \"Content-Length\" 未被定义。如果无此内容，服务器不会接受请求。 |\r\n| 412 Precondition Failed           | 请求中的前提条件被服务器评估为失败。                         |\r\n| 413 Request Entity Too Large      | 由于所请求的实体的太大，服务器不会接受请求。                 |\r\n| 414 Request-url Too Long          | 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 |\r\n| 415 Unsupported Media Type        | 由于媒介类型不被支持，服务器不会接受请求。                   |\r\n| 416                               | 服务器不能满足客户在请求中指定的Range头。                    |\r\n| 417 Expectation Failed            |                                                              |\r\n\r\n### 5xx: 服务器错误\r\n\r\n| 消息:                          | 描述:                                              |\r\n| :----------------------------- | :------------------------------------------------- |\r\n| 500 Internal Server Error      | 请求未完成。服务器遇到不可预知的情况。             |\r\n| 501 Not Implemented            | 请求未完成。服务器不支持所请求的功能。             |\r\n| 502 Bad Gateway                | 请求未完成。服务器从上游服务器收到一个无效的响应。 |\r\n| 503 Service Unavailable        | 请求未完成。服务器临时过载或当机。                 |\r\n| 504 Gateway Timeout            | 网关超时。                                         |\r\n| 505 HTTP Version Not Supported | 服务器不支持请求中指明的HTTP协议版本。             |\r\n', 'AJAX', NULL, NULL, '0', '2', 0, 0, 0, 0, '1', 1, '2023-02-22 13:47:37', 1, '2023-02-22 13:47:37', 0);

-- ----------------------------
-- Table structure for lzh_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `lzh_article_tag`;
CREATE TABLE `lzh_article_tag`  (
  `article_id` bigint NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `tag_id` bigint NOT NULL DEFAULT 0 COMMENT '标签id',
  PRIMARY KEY (`article_id`, `tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1627911270841741314 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章标签关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_article_tag
-- ----------------------------
INSERT INTO `lzh_article_tag` VALUES (1, 2);
INSERT INTO `lzh_article_tag` VALUES (1, 3);
INSERT INTO `lzh_article_tag` VALUES (1, 4);
INSERT INTO `lzh_article_tag` VALUES (2, 4);
INSERT INTO `lzh_article_tag` VALUES (2, 9);
INSERT INTO `lzh_article_tag` VALUES (2, 10);
INSERT INTO `lzh_article_tag` VALUES (2, 11);
INSERT INTO `lzh_article_tag` VALUES (3, 4);
INSERT INTO `lzh_article_tag` VALUES (3, 5);
INSERT INTO `lzh_article_tag` VALUES (5, 1);
INSERT INTO `lzh_article_tag` VALUES (9, 1);
INSERT INTO `lzh_article_tag` VALUES (9, 2);
INSERT INTO `lzh_article_tag` VALUES (9, 4);
INSERT INTO `lzh_article_tag` VALUES (10, 1);
INSERT INTO `lzh_article_tag` VALUES (1576527547464937474, 5);
INSERT INTO `lzh_article_tag` VALUES (1576527547464937474, 6);
INSERT INTO `lzh_article_tag` VALUES (1576527547464937474, 7);
INSERT INTO `lzh_article_tag` VALUES (1576928390408253442, 9);
INSERT INTO `lzh_article_tag` VALUES (1576928390408253442, 16);
INSERT INTO `lzh_article_tag` VALUES (1579730661248593922, 1);
INSERT INTO `lzh_article_tag` VALUES (1579730661248593922, 12);
INSERT INTO `lzh_article_tag` VALUES (1579730661248593922, 13);
INSERT INTO `lzh_article_tag` VALUES (1579730661248593922, 14);
INSERT INTO `lzh_article_tag` VALUES (1580001549915234305, 5);
INSERT INTO `lzh_article_tag` VALUES (1580001549915234305, 6);
INSERT INTO `lzh_article_tag` VALUES (1580001549915234305, 7);
INSERT INTO `lzh_article_tag` VALUES (1580002217321168897, 1);
INSERT INTO `lzh_article_tag` VALUES (1580002217321168897, 4);
INSERT INTO `lzh_article_tag` VALUES (1580002217321168897, 9);
INSERT INTO `lzh_article_tag` VALUES (1580003318506323970, 1);
INSERT INTO `lzh_article_tag` VALUES (1580003318506323970, 5);
INSERT INTO `lzh_article_tag` VALUES (1580003318506323970, 6);
INSERT INTO `lzh_article_tag` VALUES (1580782348893626370, 1);
INSERT INTO `lzh_article_tag` VALUES (1580782348893626370, 5);
INSERT INTO `lzh_article_tag` VALUES (1580782348893626370, 9);
INSERT INTO `lzh_article_tag` VALUES (1580876557625585665, 1);
INSERT INTO `lzh_article_tag` VALUES (1580876557625585665, 2);
INSERT INTO `lzh_article_tag` VALUES (1580876557625585665, 4);
INSERT INTO `lzh_article_tag` VALUES (1580876557625585665, 9);
INSERT INTO `lzh_article_tag` VALUES (1581248764574834689, 11);
INSERT INTO `lzh_article_tag` VALUES (1581248764574834689, 12);
INSERT INTO `lzh_article_tag` VALUES (1581248764574834689, 13);
INSERT INTO `lzh_article_tag` VALUES (1581248764574834689, 14);
INSERT INTO `lzh_article_tag` VALUES (1581491547428610050, 4);
INSERT INTO `lzh_article_tag` VALUES (1581491547428610050, 11);
INSERT INTO `lzh_article_tag` VALUES (1581491547428610050, 12);
INSERT INTO `lzh_article_tag` VALUES (1581491547428610050, 13);
INSERT INTO `lzh_article_tag` VALUES (1581492165140537345, 1);
INSERT INTO `lzh_article_tag` VALUES (1581492165140537345, 10);
INSERT INTO `lzh_article_tag` VALUES (1581492165140537345, 12);
INSERT INTO `lzh_article_tag` VALUES (1581523482204844034, 2);
INSERT INTO `lzh_article_tag` VALUES (1581523482204844034, 6);
INSERT INTO `lzh_article_tag` VALUES (1581523482204844034, 7);
INSERT INTO `lzh_article_tag` VALUES (1581523482204844039, 7);
INSERT INTO `lzh_article_tag` VALUES (1581523482204844039, 9);
INSERT INTO `lzh_article_tag` VALUES (1581523482204844040, 6);
INSERT INTO `lzh_article_tag` VALUES (1581523482204844040, 7);
INSERT INTO `lzh_article_tag` VALUES (1581523482204844040, 9);
INSERT INTO `lzh_article_tag` VALUES (1584795396985831425, 12);
INSERT INTO `lzh_article_tag` VALUES (1584804994513879042, 6);
INSERT INTO `lzh_article_tag` VALUES (1584804994513879042, 7);
INSERT INTO `lzh_article_tag` VALUES (1589422745435770881, 4);
INSERT INTO `lzh_article_tag` VALUES (1589422745435770881, 6);
INSERT INTO `lzh_article_tag` VALUES (1589422745435770881, 7);
INSERT INTO `lzh_article_tag` VALUES (1589570183937167361, 2);
INSERT INTO `lzh_article_tag` VALUES (1589616657802788866, 11);
INSERT INTO `lzh_article_tag` VALUES (1589616657802788866, 12);
INSERT INTO `lzh_article_tag` VALUES (1589617423766585345, 2);
INSERT INTO `lzh_article_tag` VALUES (1589617423766585345, 4);
INSERT INTO `lzh_article_tag` VALUES (1589617612757729282, 11);
INSERT INTO `lzh_article_tag` VALUES (1589617612757729282, 12);
INSERT INTO `lzh_article_tag` VALUES (1589617612757729282, 13);
INSERT INTO `lzh_article_tag` VALUES (1589617612757729282, 14);
INSERT INTO `lzh_article_tag` VALUES (1589618311344226306, 6);
INSERT INTO `lzh_article_tag` VALUES (1589618311344226306, 9);
INSERT INTO `lzh_article_tag` VALUES (1589618311344226306, 13);
INSERT INTO `lzh_article_tag` VALUES (1589626579030384642, 4);
INSERT INTO `lzh_article_tag` VALUES (1627142236512735233, 6);
INSERT INTO `lzh_article_tag` VALUES (1627142236512735233, 7);
INSERT INTO `lzh_article_tag` VALUES (1627145535857119233, 6);
INSERT INTO `lzh_article_tag` VALUES (1627503573914947586, 10);
INSERT INTO `lzh_article_tag` VALUES (1627503573914947586, 11);
INSERT INTO `lzh_article_tag` VALUES (1627534326015000578, 11);
INSERT INTO `lzh_article_tag` VALUES (1627534326015000578, 14);
INSERT INTO `lzh_article_tag` VALUES (1627534326015000578, 16);
INSERT INTO `lzh_article_tag` VALUES (1627535444652646402, 6);
INSERT INTO `lzh_article_tag` VALUES (1627535444652646402, 9);
INSERT INTO `lzh_article_tag` VALUES (1627535444652646402, 12);
INSERT INTO `lzh_article_tag` VALUES (1627535444652646402, 14);
INSERT INTO `lzh_article_tag` VALUES (1627535444652646403, 6);
INSERT INTO `lzh_article_tag` VALUES (1627535444652646404, 7);
INSERT INTO `lzh_article_tag` VALUES (1627535444652646405, 6);
INSERT INTO `lzh_article_tag` VALUES (1627535444652646406, 7);
INSERT INTO `lzh_article_tag` VALUES (1627899980027076609, 5);
INSERT INTO `lzh_article_tag` VALUES (1627899980027076609, 6);
INSERT INTO `lzh_article_tag` VALUES (1627899980027076609, 9);

-- ----------------------------
-- Table structure for lzh_carousel_img
-- ----------------------------
DROP TABLE IF EXISTS `lzh_carousel_img`;
CREATE TABLE `lzh_carousel_img`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `create_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '创建者',
  `update_by` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '更新者',
  `remarks` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '描述',
  `del_flag` int NULL DEFAULT 0 COMMENT '逻辑删除标记（0：未删除；1：已删除）',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '标题',
  `url` varchar(10000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '链接地址',
  `img` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '图片地址',
  `sort` int NULL DEFAULT NULL COMMENT '排序',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文档管理-轮播图' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_carousel_img
-- ----------------------------
INSERT INTO `lzh_carousel_img` VALUES (1, NULL, NULL, 'WELCOME TO MY PERSEVERE BLOG', 0, '', 'http://1.117.218.230:9000/test/a.jpg', 'http://rkafz00mn.hd-bkt.clouddn.com/carousel/deer.jpg', 1);
INSERT INTO `lzh_carousel_img` VALUES (2, NULL, NULL, '边月随弓影,胡霜拂剑花', 0, '20大', 'http://1.117.218.230:9000/test/img_1675327007931.jpg', '\r\nhttp://rkafz00mn.hd-bkt.clouddn.com/carousel/wallhaven-4lx8mr.jpg', 2);
INSERT INTO `lzh_carousel_img` VALUES (3, NULL, NULL, 'NBUFE', 0, NULL, 'http://1.117.218.230:9000/test/nbufe_01.jpg', '\r\nhttp://rkafz00mn.hd-bkt.clouddn.com/carousel/oldpic.jpg', 3);
INSERT INTO `lzh_carousel_img` VALUES (4, NULL, NULL, '抬望眼,仰天长啸,壮怀激烈', 0, NULL, 'http://1.117.218.230:9000/test/nb_d_24.jpg', '\r\nhttp://rkafz00mn.hd-bkt.clouddn.com/carousel/wallhaven-dg6y63.jpg', 4);
INSERT INTO `lzh_carousel_img` VALUES (5, NULL, NULL, '奋进新征程，建功新时代', 0, NULL, 'http://1.117.218.230:9000/test/nb_d_71.jpg', 'http://rkafz00mn.hd-bkt.clouddn.com/carousel/street.jpg', 2);
INSERT INTO `lzh_carousel_img` VALUES (6, NULL, NULL, 'I LOVE NBUFE', 0, NULL, 'http://1.117.218.230:9000/test/nb_d_80.jpg', 'http://rkafz00mn.hd-bkt.clouddn.com/carousel/tree.png', 3);

-- ----------------------------
-- Table structure for lzh_category
-- ----------------------------
DROP TABLE IF EXISTS `lzh_category`;
CREATE TABLE `lzh_category`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '分类名',
  `pid` bigint NULL DEFAULT -1 COMMENT '父分类id，如果没有父分类为-1',
  `description` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '描述',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '状态0:正常,1禁用',
  `sort` bigint NULL DEFAULT 0 COMMENT '排序',
  `click_num` bigint NULL DEFAULT 0 COMMENT '点击数',
  `create_by` bigint NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `update_by` bigint NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `del_flag` int NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 37 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '分类表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_category
-- ----------------------------
INSERT INTO `lzh_category` VALUES (1, 'Java', -1, '高级编程语言', '0', 12, 1, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (2, 'PHP', -1, 'php语言', '0', 2, 2, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (15, 'SpringBoot', -1, 'Spring框架', '0', 3, 4, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (16, 'C++', -1, 'C Plus Plus', '0', 21, 2, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (17, 'C#', -1, NULL, '0', 63, 3, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (18, 'Python', -1, '解释型语言，语法简单', '0', 6, 34, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (19, '机器学习', -1, NULL, '0', 5, 65, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (20, 'Spring', -1, '简化Java开发', '0', 551, 23, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (21, '大数据', -1, NULL, '0', 7, 41, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (22, '人工智能', -1, NULL, '0', 32, 68, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (23, '队列', -1, NULL, '0', 12, 12, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (24, '中间件', -1, NULL, '0', 9, 76, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (25, '设计模式', -1, NULL, '0', 43, 0, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (26, 'JVM', -1, NULL, '0', 7, 65, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (27, '计算机组成原理', -1, NULL, '0', 9, 6, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (28, '计算机网络', -1, NULL, '0', 6, 75, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (29, '算法', -1, NULL, '0', 94, 45, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (30, '数据结构', -1, NULL, '0', 786, 3, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (31, '二叉树', -1, '一种树类型的数据结构', '0', 23, 334, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (32, 'VUE', -1, NULL, '0', 54, 55, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (33, 'Bootstrap', -1, NULL, '0', 64, 545, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (34, 'JavaScript', -1, NULL, '0', 53, 5, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (35, 'HTML', -1, NULL, '0', 23, 6, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (36, 'CSS', -1, NULL, '0', 6, 54, NULL, '2023-02-08 15:05:05', NULL, '2023-02-08 15:05:05', 0);
INSERT INTO `lzh_category` VALUES (1629050998127366145, '日常', -1, '记录日常生活，分享美好事物', '0', 123, 0, NULL, '2023-02-24 17:29:58', NULL, '2023-02-24 17:29:58', 0);
INSERT INTO `lzh_category` VALUES (1629051205330178049, '爱好', -1, '分享每个人的兴趣爱好', '0', 23, 0, NULL, '2023-02-24 17:30:48', NULL, '2023-02-24 17:30:48', 0);

-- ----------------------------
-- Table structure for lzh_chat_communication
-- ----------------------------
DROP TABLE IF EXISTS `lzh_chat_communication`;
CREATE TABLE `lzh_chat_communication`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `from_id` bigint NULL DEFAULT NULL COMMENT '发送人id',
  `from_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '发送人name',
  `to_id` int NULL DEFAULT NULL COMMENT '接收人id，不适用与群消息',
  `to_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '接收人name不适用于群消息',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '消息内容',
  `from_avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `time` datetime NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '时间',
  `group_id` int NULL DEFAULT NULL COMMENT '群id',
  `group_name` int NULL DEFAULT NULL COMMENT '群名称',
  `is_read` tinyint NULL DEFAULT 0 COMMENT '是否已读,不适用于群消息 0 已读 1 未读',
  `type` tinyint NULL DEFAULT 1 COMMENT '消息类型：1是普通文本，2是图片，3是语音',
  `is_user_group` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '消息类：1是用户聊天，2是群组聊天',
  `del_flag` tinyint NULL DEFAULT 0 COMMENT '逻辑删除 0 未删除 1 已删除',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1621054327342850049 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '聊天记录' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_chat_communication
-- ----------------------------
INSERT INTO `lzh_chat_communication` VALUES (1590348436469723138, NULL, 'lisi', NULL, 'lzh', '   \n          \n\n\n\n\n\n\n\n \n \n \n \n \n\nd\n', 'https://img1.baidu.com/it/u=1659441821,1293635445&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '2023-02-02 15:53:26', NULL, NULL, 0, 1, NULL, 0);
INSERT INTO `lzh_chat_communication` VALUES (1590348437182754817, NULL, 'lisi', NULL, 'lzh', 'd\n', 'https://img1.baidu.com/it/u=1659441821,1293635445&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '2023-02-02 15:53:26', NULL, NULL, 0, 1, NULL, 0);
INSERT INTO `lzh_chat_communication` VALUES (1590348437837066241, NULL, 'lisi', NULL, 'lzh', 'f\nd', 'https://img1.baidu.com/it/u=1659441821,1293635445&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '2023-02-02 15:53:26', NULL, NULL, 0, 1, NULL, 0);
INSERT INTO `lzh_chat_communication` VALUES (1621054225773584386, NULL, 'lzh', NULL, 'lisi', '你好啊[微笑]', 'http://1.117.218.230:9000/test/nbufe.jpg', '2023-02-02 15:53:50', NULL, NULL, 0, 1, NULL, 0);
INSERT INTO `lzh_chat_communication` VALUES (1621054253112057857, NULL, 'lisi', NULL, 'lzh', '哈哈哈\n', 'https://img1.baidu.com/it/u=1659441821,1293635445&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '2023-02-02 15:54:11', NULL, NULL, 0, 1, NULL, 0);
INSERT INTO `lzh_chat_communication` VALUES (1621054290432974850, NULL, 'lisi', NULL, 'lzh', '嗯嗯嗯\n', 'https://img1.baidu.com/it/u=1659441821,1293635445&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '2023-02-02 15:54:11', NULL, NULL, 0, 1, NULL, 0);
INSERT INTO `lzh_chat_communication` VALUES (1621054311836508161, NULL, 'lisi', NULL, 'lzh', '啊啊啊啊\n', 'https://img1.baidu.com/it/u=1659441821,1293635445&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '2023-02-02 15:54:11', NULL, NULL, 0, 1, NULL, 0);
INSERT INTO `lzh_chat_communication` VALUES (1621054327342850049, NULL, 'lisi', NULL, 'lzh', '6\n', 'https://img1.baidu.com/it/u=1659441821,1293635445&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '2023-02-02 15:54:11', NULL, NULL, 0, 1, NULL, 0);

-- ----------------------------
-- Table structure for lzh_collect
-- ----------------------------
DROP TABLE IF EXISTS `lzh_collect`;
CREATE TABLE `lzh_collect`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `user_id` bigint NULL DEFAULT NULL COMMENT '用户id',
  `article_id` bigint NULL DEFAULT NULL COMMENT '文章id',
  `collect_status` int NULL DEFAULT NULL COMMENT '收藏状态 0 未收藏 1 已收藏',
  `collect_time` datetime NULL DEFAULT NULL COMMENT '收藏时间',
  `del_flag` int NULL DEFAULT 0 COMMENT '是否逻辑删除',
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1589571261768437761 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_collect
-- ----------------------------
INSERT INTO `lzh_collect` VALUES (1, 1, 2, 0, '2022-10-19 18:54:27', 0, '2022-10-19 18:54:30', '2022-10-19 18:54:33');
INSERT INTO `lzh_collect` VALUES (1582699606096093185, 1, 3, 1, '2022-10-19 19:46:19', 0, '2022-10-19 19:46:31', '2022-10-19 19:46:34');
INSERT INTO `lzh_collect` VALUES (1582711386608480258, 2, 3, 1, NULL, 0, '2022-10-19 20:32:55', '2022-10-19 20:32:55');
INSERT INTO `lzh_collect` VALUES (1582711877283328002, 1, 1576527547464937474, 1, NULL, 0, '2022-10-19 20:34:52', '2022-10-19 20:34:52');
INSERT INTO `lzh_collect` VALUES (1582712249716547586, 1, 5, 0, NULL, 0, '2022-10-19 20:36:20', '2022-10-19 20:36:20');
INSERT INTO `lzh_collect` VALUES (1582712815846924290, 1, 10, 1, NULL, 0, '2022-10-19 20:38:35', '2022-10-19 20:38:35');
INSERT INTO `lzh_collect` VALUES (1582713970173911042, 1, 1579692483556806657, 1, NULL, 0, '2022-10-19 20:43:11', '2022-10-19 20:43:11');
INSERT INTO `lzh_collect` VALUES (1582714043662311426, 1, 1580876557625585665, 0, NULL, 0, '2022-10-19 20:43:28', '2022-10-19 20:43:28');
INSERT INTO `lzh_collect` VALUES (1582970659041067009, 1, 1579730661248593922, 1, NULL, 0, '2022-10-20 13:43:10', '2022-10-20 13:43:10');
INSERT INTO `lzh_collect` VALUES (1582970742327361538, 1, 1580782348893626370, 1, NULL, 0, '2022-10-20 13:43:30', '2022-10-20 13:43:30');
INSERT INTO `lzh_collect` VALUES (1583752766025871361, 1, 1581248764574834689, 0, NULL, 0, '2022-10-22 17:30:59', '2022-10-22 17:30:59');
INSERT INTO `lzh_collect` VALUES (1584137651676651522, 2, 2, 0, NULL, 0, '2022-10-23 19:00:23', '2022-10-23 19:00:23');
INSERT INTO `lzh_collect` VALUES (1584138887205363714, 2, 1576527547464937474, 0, NULL, 0, '2022-10-23 19:05:17', '2022-10-23 19:05:17');
INSERT INTO `lzh_collect` VALUES (1584138924589195265, 2, 1581248764574834689, 1, NULL, 0, '2022-10-23 19:05:26', '2022-10-23 19:05:26');
INSERT INTO `lzh_collect` VALUES (1584138965873729538, 2, 1579035117211553793, 1, NULL, 0, '2022-10-23 19:05:36', '2022-10-23 19:05:36');
INSERT INTO `lzh_collect` VALUES (1584138999017119745, 2, 1579692483556806657, 1, NULL, 0, '2022-10-23 19:05:44', '2022-10-23 19:05:44');
INSERT INTO `lzh_collect` VALUES (1584151040239054849, 1, 8, 1, NULL, 0, '2022-10-23 19:53:35', '2022-10-23 19:53:35');
INSERT INTO `lzh_collect` VALUES (1584776958020038657, 1, 1581491547428610050, 0, NULL, 0, '2022-10-25 13:20:45', '2022-10-25 13:20:45');
INSERT INTO `lzh_collect` VALUES (1584795471170486273, 1, 1584795396985831425, 0, NULL, 0, '2022-10-25 14:34:19', '2022-10-25 14:34:19');
INSERT INTO `lzh_collect` VALUES (1589422332175192065, 1, 1580001549915234305, 0, NULL, 0, '2022-11-07 08:59:49', '2022-11-07 08:59:49');
INSERT INTO `lzh_collect` VALUES (1589422803568824322, 1, 1589422745435770881, 0, NULL, 0, '2022-11-07 09:01:41', '2022-11-07 09:01:41');
INSERT INTO `lzh_collect` VALUES (1589570238702194689, 1, 1589570183937167361, 1, NULL, 0, '2022-11-07 18:47:32', '2022-11-07 18:47:32');
INSERT INTO `lzh_collect` VALUES (1589571261768437761, 1, 1589570781973614594, 0, NULL, 0, '2022-11-07 18:51:36', '2022-11-07 18:51:36');

-- ----------------------------
-- Table structure for lzh_comment
-- ----------------------------
DROP TABLE IF EXISTS `lzh_comment`;
CREATE TABLE `lzh_comment`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '评论类型（0代表文章评论，1代表友链评论，2代表问答评论）',
  `article_id` bigint NULL DEFAULT NULL COMMENT '文章id',
  `root_id` bigint NULL DEFAULT -1 COMMENT '根评论id',
  `content` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '评论内容',
  `to_comment_user_id` bigint NULL DEFAULT -1 COMMENT '所回复的目标评论的userid',
  `to_comment_id` bigint NULL DEFAULT -1 COMMENT '回复目标评论id',
  `create_by` bigint NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `update_by` bigint NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  `del_flag` int NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1621764964459184130 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '评论表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_comment
-- ----------------------------
INSERT INTO `lzh_comment` VALUES (1579712259972886529, '0', 2, -1, 'hello world', -1, 1579691106277396482, NULL, '2022-10-11 13:55:27', NULL, '2022-10-11 13:55:27', 0);
INSERT INTO `lzh_comment` VALUES (1579712319133544450, '0', 2, -1, '你好，世界', -1, 1579691106277396482, NULL, '2022-10-11 13:55:41', NULL, '2022-10-11 13:55:41', 0);
INSERT INTO `lzh_comment` VALUES (1579722752779350017, '0', 9, -1, '你好', -1, 1, NULL, '2022-10-11 14:37:09', NULL, '2022-10-11 14:37:09', 0);
INSERT INTO `lzh_comment` VALUES (1579730373557088258, '0', 8, -1, 'hello', -1, 1, NULL, '2022-10-11 15:07:26', NULL, '2022-10-11 15:07:26', 0);
INSERT INTO `lzh_comment` VALUES (1579784957553938433, '0', 2, -1, '未来好', -1, 1, NULL, '2022-10-11 18:44:20', NULL, '2022-10-11 18:44:20', 0);
INSERT INTO `lzh_comment` VALUES (1579785001883537409, '0', 2, 1579712319133544450, '你好啊', 1579691106277396482, 1, NULL, '2022-10-11 18:44:30', NULL, '2022-10-11 18:44:30', 0);
INSERT INTO `lzh_comment` VALUES (1580377260232531970, '0', 9, 1579722752779350017, '123', 1, 1, NULL, '2022-10-13 09:57:55', NULL, '2022-10-13 09:57:55', 0);
INSERT INTO `lzh_comment` VALUES (1580782707930243074, '0', 2, 1579784957553938433, '123123', 1, 1, NULL, '2022-10-14 12:49:02', NULL, '2022-10-14 12:49:02', 0);
INSERT INTO `lzh_comment` VALUES (1580790042799054850, '0', 1576527547464937474, -1, '12345', -1, 1, NULL, '2022-10-14 13:18:11', NULL, '2022-10-14 13:18:11', 0);
INSERT INTO `lzh_comment` VALUES (1580790544936935426, '0', 1576527547464937474, -1, 'hello world', -1, 1, NULL, '2022-10-14 13:20:10', NULL, '2022-10-14 13:20:10', 0);
INSERT INTO `lzh_comment` VALUES (1580790719172517889, '0', 1580782348893626370, -1, 'test评论', -1, 1, NULL, '2022-10-14 13:20:52', NULL, '2022-10-14 13:20:52', 0);
INSERT INTO `lzh_comment` VALUES (1580792274948923393, '0', 1576527547464937474, 1580790544936935426, '无聊的环面，全部都看见', 1, 1, NULL, '2022-10-14 13:27:03', NULL, '2022-10-14 13:27:03', 0);
INSERT INTO `lzh_comment` VALUES (1580792391521214465, '0', 1580782348893626370, -1, 'welcome to my persevere blog', -1, 1, NULL, '2022-10-14 13:27:31', NULL, '2022-10-14 13:27:31', 0);
INSERT INTO `lzh_comment` VALUES (1580874076078206978, '0', 1576527547464937474, 1580790042799054850, 'qwqwqw', 1, 1578603364453953538, NULL, '2022-10-14 18:52:06', NULL, '2022-10-14 18:52:06', 0);
INSERT INTO `lzh_comment` VALUES (1580875253905879042, '0', 1580782348893626370, 1580792391521214465, 'aaaaaaaaaaaa', 1, 1578603364453953538, NULL, '2022-10-14 18:56:46', NULL, '2022-10-14 18:56:46', 0);
INSERT INTO `lzh_comment` VALUES (1580876655025713153, '0', 1580876557625585665, -1, '评论一个', -1, 1578603364453953538, NULL, '2022-10-14 19:02:20', NULL, '2022-10-14 19:02:20', 0);
INSERT INTO `lzh_comment` VALUES (1581487571064840193, '0', 2, 1579784957553938433, '[钱][钱]', 1, 1, NULL, '2022-10-16 11:29:54', NULL, '2022-10-16 11:29:54', 0);
INSERT INTO `lzh_comment` VALUES (1581490034455076866, '0', 2, 1579784957553938433, '[哈哈][哈哈][哈哈]', 1, 1, NULL, '2022-10-16 11:39:42', NULL, '2022-10-16 11:39:42', 0);
INSERT INTO `lzh_comment` VALUES (1581490198842433538, '0', 2, 1579712259972886529, '你好，世界', 1579691106277396482, 1, NULL, '2022-10-16 11:40:21', NULL, '2022-10-16 11:40:21', 0);
INSERT INTO `lzh_comment` VALUES (1581524136138780674, '0', 1581523482204844033, -1, 'qqq', -1, 1, NULL, '2022-10-16 13:55:12', NULL, '2022-10-16 13:55:12', 0);
INSERT INTO `lzh_comment` VALUES (1581623658089218049, '0', 3, -1, '[微笑]', -1, 1, NULL, '2022-10-16 20:30:40', NULL, '2022-10-16 20:30:40', 0);
INSERT INTO `lzh_comment` VALUES (1581623915900502018, '0', 3, -1, '[微笑]', -1, 1, NULL, '2022-10-16 20:31:41', NULL, '2022-10-16 20:31:41', 0);
INSERT INTO `lzh_comment` VALUES (1581648460128649217, '0', 2, -1, '[伤心]', -1, 1, NULL, '2022-10-16 22:09:13', NULL, '2022-10-16 22:09:13', 0);
INSERT INTO `lzh_comment` VALUES (1581833992527835138, '0', 2, -1, '[不][不][不]', -1, 1, NULL, '2022-10-17 10:26:28', NULL, '2022-10-17 10:26:28', 0);
INSERT INTO `lzh_comment` VALUES (1581834051596218370, '0', 2, 1581648460128649217, '[馋嘴][馋嘴][哈哈][哈哈][哈哈]', 1, 1, NULL, '2022-10-17 10:26:42', NULL, '2022-10-17 10:26:42', 0);
INSERT INTO `lzh_comment` VALUES (1581835466930548737, '0', 2, 1579712319133544450, '[可怜][可怜][可怜][微笑][微笑][微笑]', 1579691106277396482, 1, NULL, '2022-10-17 10:32:19', NULL, '2022-10-17 10:32:19', 0);
INSERT INTO `lzh_comment` VALUES (1581860209633161217, '0', 2, -1, '[可怜][可怜][可怜][可怜]', -1, 1, NULL, '2022-10-17 12:10:38', NULL, '2022-10-17 12:10:38', 0);
INSERT INTO `lzh_comment` VALUES (1581860265631313922, '0', 2, 1581860209633161217, '[微笑][微笑][微笑][微笑][微笑][微笑]', 1, 1, NULL, '2022-10-17 12:10:52', NULL, '2022-10-17 12:10:52', 0);
INSERT INTO `lzh_comment` VALUES (1582259784743383042, '0', 2, 1579712259972886529, '[嘻嘻][嘻嘻][嘻嘻][衰][衰]hello!!!', 1, 2, NULL, '2022-10-18 14:38:24', NULL, '2022-10-18 14:38:24', 0);
INSERT INTO `lzh_comment` VALUES (1582259867929014273, '0', 2, 1579712259972886529, 'I\'m fine.Thank you!', 1579691106277396482, 2, NULL, '2022-10-18 14:38:44', NULL, '2022-10-18 14:38:44', 0);
INSERT INTO `lzh_comment` VALUES (1582259949101379585, '0', 2, 1579712319133544450, '[钱][钱][钱][酷][酷][酷]', 1, 2, NULL, '2022-10-18 14:39:03', NULL, '2022-10-18 14:39:03', 0);
INSERT INTO `lzh_comment` VALUES (1582264262175485953, '0', 2, -1, '测试表情包评论[互粉][书呆子][困][睡][钱][失望][左哼哼][嘘][酷][衰][色][哼][吐][哈欠][鼓掌][晕][抱抱][悲伤][抓狂]', -1, 1, NULL, '2022-10-18 14:56:12', NULL, '2022-10-18 14:56:12', 0);
INSERT INTO `lzh_comment` VALUES (1582566360909807618, '0', 1579031502224822274, -1, '[嘻嘻][嘻嘻][嘻嘻][嘻嘻][微笑][微笑][微笑][微笑][微笑]', -1, 1, NULL, '2022-10-19 10:56:38', NULL, '2022-10-19 10:56:38', 0);
INSERT INTO `lzh_comment` VALUES (1582601328478351362, '2', -1, -1, 'test chat', -1, 1, NULL, '2022-10-19 13:15:35', NULL, '2022-10-19 13:15:35', 0);
INSERT INTO `lzh_comment` VALUES (1582601765931675650, '2', -1, -1, 'aaa', -1, 1, NULL, '2022-10-19 13:17:19', NULL, '2022-10-19 13:17:19', 0);
INSERT INTO `lzh_comment` VALUES (1582602573016428545, '2', -1, -1, 'qqqqq', -1, 1, NULL, '2022-10-19 13:20:31', NULL, '2022-10-19 13:20:31', 0);
INSERT INTO `lzh_comment` VALUES (1582603341467398145, '2', -1, -1, 'aaaaaa', -1, 1, NULL, '2022-10-19 13:23:35', NULL, '2022-10-19 13:23:35', 0);
INSERT INTO `lzh_comment` VALUES (1582608986711175169, '2', -1, -1, '[微笑][微笑][微笑]', -1, 1, NULL, '2022-10-19 13:46:01', NULL, '2022-10-19 13:46:01', 0);
INSERT INTO `lzh_comment` VALUES (1582614074775265282, '2', -1, 1582601328478351362, '[哈哈][哈哈]', 1, 1, NULL, '2022-10-19 14:06:14', NULL, '2022-10-19 14:06:14', 0);
INSERT INTO `lzh_comment` VALUES (1582614197332828162, '2', -1, 1582601328478351362, '[微笑][微笑][微笑][微笑][嘻嘻][嘻嘻]', 1, 2, NULL, '2022-10-19 14:06:43', NULL, '2022-10-19 14:06:43', 0);
INSERT INTO `lzh_comment` VALUES (1582614233189933057, '2', -1, 1582601328478351362, '[可怜][可怜][可怜][黑线][衰]', 1, 2, NULL, '2022-10-19 14:06:51', NULL, '2022-10-19 14:06:51', 0);
INSERT INTO `lzh_comment` VALUES (1582615217869905921, '2', -1, -1, '[困][困][困][困][馋嘴]', -1, 2, NULL, '2022-10-19 14:10:46', NULL, '2022-10-19 14:10:46', 0);
INSERT INTO `lzh_comment` VALUES (1582645253939286018, '2', -1, -1, '[微笑][微笑][微笑][微笑]', -1, 1, NULL, '2022-10-19 16:10:07', NULL, '2022-10-19 16:10:07', 0);
INSERT INTO `lzh_comment` VALUES (1582645284092137474, '2', -1, 1582645253939286018, '[可怜][可怜][可怜][可怜]', 1, 1, NULL, '2022-10-19 16:10:15', NULL, '2022-10-19 16:10:15', 0);
INSERT INTO `lzh_comment` VALUES (1582645309006303234, '2', -1, 1582615217869905921, '[哈哈][哈哈][哈哈]', 2, 1, NULL, '2022-10-19 16:10:20', NULL, '2022-10-19 16:10:20', 0);
INSERT INTO `lzh_comment` VALUES (1582665569520451585, '2', -1, 1582645253939286018, '[微笑][微笑][微笑][微笑]', 1, 1, NULL, '2022-10-19 17:30:51', NULL, '2022-10-19 17:30:51', 0);
INSERT INTO `lzh_comment` VALUES (1583641905399537665, '0', 2, -1, '[泪][泪][泪]测试时间排序评论', -1, 1, NULL, '2022-10-22 10:10:28', NULL, '2022-10-22 10:10:28', 0);
INSERT INTO `lzh_comment` VALUES (1583643380838244353, '2', -1, -1, 'welcome to persevere blog[哈哈][哈哈][哈哈]', -1, 1, NULL, '2022-10-22 10:16:19', NULL, '2022-10-22 10:16:19', 0);
INSERT INTO `lzh_comment` VALUES (1583782576512999425, '2', -1, -1, 'never forget why you started!!![太开心][太开心][太开心]', -1, 1, NULL, '2022-10-22 19:29:26', NULL, '2022-10-22 19:29:26', 0);
INSERT INTO `lzh_comment` VALUES (1584064756111880194, '0', 2, -1, '111', -1, 1, NULL, '2022-10-23 14:10:43', NULL, '2022-10-23 14:10:43', 0);
INSERT INTO `lzh_comment` VALUES (1584146154445320194, '2', -1, -1, '完成粉丝、关注[哈哈][哈哈][哈哈][哈哈]', -1, 20, NULL, '2022-10-23 19:34:10', NULL, '2022-10-23 19:34:10', 0);
INSERT INTO `lzh_comment` VALUES (1584333375416807425, '2', -1, -1, '[哈欠][哈欠][哈欠][哈欠]', -1, 1, NULL, '2022-10-24 07:58:07', NULL, '2022-10-24 07:58:07', 0);
INSERT INTO `lzh_comment` VALUES (1584333470937886721, '2', -1, -1, '[心][心][心][心]', -1, 1, NULL, '2022-10-24 07:58:30', NULL, '2022-10-24 07:58:30', 0);
INSERT INTO `lzh_comment` VALUES (1584333963365953538, '2', -1, 1584146154445320194, '[微笑][微笑][微笑]', 20, 1, NULL, '2022-10-24 08:00:27', NULL, '2022-10-24 08:00:27', 0);
INSERT INTO `lzh_comment` VALUES (1584333994718375938, '2', -1, -1, '123', -1, 1, NULL, '2022-10-24 08:00:35', NULL, '2022-10-24 08:00:35', 0);
INSERT INTO `lzh_comment` VALUES (1584334473078747138, '2', -1, -1, 'hello world', -1, 1, NULL, '2022-10-24 08:02:29', NULL, '2022-10-24 08:02:29', 0);
INSERT INTO `lzh_comment` VALUES (1584335785233207297, '2', -1, -1, '[可爱][可爱][可爱][可爱]', -1, 1, NULL, '2022-10-24 08:07:41', NULL, '2022-10-24 08:07:41', 0);
INSERT INTO `lzh_comment` VALUES (1584787198513917953, '0', 1579730661248593922, -1, '[微笑][微笑][微笑]', -1, 1, NULL, '2022-10-25 14:01:27', NULL, '2022-10-25 14:01:27', 0);
INSERT INTO `lzh_comment` VALUES (1584809807700017153, '2', -1, -1, '[可怜][可怜]', -1, 1, NULL, '2022-10-25 15:31:17', NULL, '2022-10-25 15:31:17', 0);
INSERT INTO `lzh_comment` VALUES (1589564043325116418, '0', 2, -1, '[衰][衰][衰][衰]', -1, 1, NULL, '2022-11-07 18:22:55', NULL, '2022-11-07 18:22:55', 0);
INSERT INTO `lzh_comment` VALUES (1589570536569081857, '0', 1589570183937167361, -1, '[嘻嘻][嘻嘻][嘻嘻]', -1, 1, NULL, '2022-11-07 18:48:43', NULL, '2022-11-07 18:48:43', 0);
INSERT INTO `lzh_comment` VALUES (1621764964459184129, '0', 1580782348893626370, -1, 'hello\n你好', -1, 1, NULL, '2023-02-04 14:57:53', NULL, '2023-02-04 14:57:53', 0);

-- ----------------------------
-- Table structure for lzh_friend_link
-- ----------------------------
DROP TABLE IF EXISTS `lzh_friend_link`;
CREATE TABLE `lzh_friend_link`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '友链名称',
  `url` varchar(150) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'url链接',
  `target` tinyint NOT NULL DEFAULT 0 COMMENT '跳转方式，0_blank，1_self，2_parent，3_top，4framename',
  `group_id` int NOT NULL DEFAULT 0 COMMENT '分组ID',
  `listorder` int NOT NULL DEFAULT 50 COMMENT '排序',
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '友链简介',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '头像',
  `del_flag` int NULL DEFAULT 0 COMMENT '逻辑删除 0 未删除 1 已删除',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '友情链接表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_friend_link
-- ----------------------------
INSERT INTO `lzh_friend_link` VALUES (1, '411工作室', 'http://101.42.177.4:9002/', 0, 0, 50, '411工作室', 'https://mybucket182.oss-cn-hangzhou.aliyuncs.com/4eb7f7f4-5b0d-40d3-ae79-95e0cba6c1c4.png', 0);
INSERT INTO `lzh_friend_link` VALUES (2, '宁波财经学院', 'https://www.nbufe.edu.cn/', 0, 0, 50, '宁波财经学院官网', '\r\nhttp://rkafz00mn.hd-bkt.clouddn.com/nbufe.jpg', 0);
INSERT INTO `lzh_friend_link` VALUES (3, 'PERSEVERE-BLOG', 'http://1.117.218.230:8088/#/home', 0, 0, 50, 'LZH的博客', 'http://rkafz00mn.hd-bkt.clouddn.com/logo.png', 0);

-- ----------------------------
-- Table structure for lzh_subscribe
-- ----------------------------
DROP TABLE IF EXISTS `lzh_subscribe`;
CREATE TABLE `lzh_subscribe`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `be_subscribe` bigint NOT NULL DEFAULT 0 COMMENT '被关注者id',
  `subscribe` bigint NOT NULL DEFAULT 0 COMMENT '关注者id',
  `status` tinyint NOT NULL DEFAULT 0 COMMENT '关注关系存续状态，0-存在关注关系，1-取消关注',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后变更时间',
  `del_flag` int NULL DEFAULT 0 COMMENT '逻辑删除 0 未删除 1 已删除',
  PRIMARY KEY (`id`, `be_subscribe`, `subscribe`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1584370789774520321 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户关注关系表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_subscribe
-- ----------------------------
INSERT INTO `lzh_subscribe` VALUES (1584055894965182466, 2, 1, 0, '2023-02-02 14:46:46', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182467, 1, 2, 0, '2022-10-23 19:27:21', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182469, 3, 1, 0, '2022-10-23 16:40:20', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182470, 10, 1, 0, '2022-10-23 16:40:20', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182471, 11, 1, 0, '2022-10-23 15:56:43', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182472, 22, 1, 0, '2022-10-23 16:38:59', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182473, 20, 1, 0, '2023-02-02 14:46:51', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182474, 24, 1, 1, '2022-10-23 16:40:27', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182475, 29, 1, 0, '2022-10-23 16:40:20', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182476, 30, 1, 0, '2022-11-08 21:38:19', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182477, 3, 2, 0, '2022-10-23 19:28:04', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182478, 10, 2, 0, '2022-10-23 19:28:15', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182479, 20, 2, 0, '2022-10-23 19:28:15', 0);
INSERT INTO `lzh_subscribe` VALUES (1584055894965182480, 30, 2, 0, '2022-10-23 19:28:15', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144950998839298, 1, 30, 0, '2022-10-23 19:29:30', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554817, 2, 30, 0, '2022-10-23 19:29:29', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554818, 20, 30, 0, '2022-10-23 19:30:14', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554819, 20, 11, 0, '2022-10-23 19:30:42', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554820, 20, 3, 0, '2022-10-23 19:30:42', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554821, 20, 24, 0, '2022-10-23 19:30:42', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554822, 20, 29, 0, '2022-10-23 19:30:42', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554823, 20, 22, 0, '2022-10-23 19:30:42', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554824, 20, 14787164048662, 0, '2022-10-23 19:31:36', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554825, 20, 1578603364453953538, 0, '2022-10-24 18:48:54', 0);
INSERT INTO `lzh_subscribe` VALUES (1584144957835554826, 20, 1579691106277396482, 0, '2022-10-23 19:31:36', 0);
INSERT INTO `lzh_subscribe` VALUES (1584145680711266306, 1, 20, 0, '2022-10-23 19:44:37', 0);
INSERT INTO `lzh_subscribe` VALUES (1584145710197223426, 2, 20, 0, '2022-10-23 19:44:42', 0);
INSERT INTO `lzh_subscribe` VALUES (1584145735488876546, 29, 20, 0, '2022-10-23 19:32:30', 0);
INSERT INTO `lzh_subscribe` VALUES (1584145944763674625, 30, 20, 1, '2022-10-23 19:33:21', 0);
INSERT INTO `lzh_subscribe` VALUES (1584145957191397378, 1579691106277396482, 20, 0, '2022-10-23 19:33:23', 0);
INSERT INTO `lzh_subscribe` VALUES (1584145962270699522, 1578603364453953538, 20, 0, '2022-10-23 19:33:24', 0);
INSERT INTO `lzh_subscribe` VALUES (1584145968016896001, 14787164048662, 20, 0, '2022-10-23 19:33:25', 0);
INSERT INTO `lzh_subscribe` VALUES (1584370789774520321, 1, 1, 1, '2023-02-05 10:29:29', 0);

-- ----------------------------
-- Table structure for lzh_tag
-- ----------------------------
DROP TABLE IF EXISTS `lzh_tag`;
CREATE TABLE `lzh_tag`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '标签名',
  `create_by` bigint NULL DEFAULT NULL,
  `update_by` bigint NULL DEFAULT NULL,
  `del_flag` int NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `sort` bigint NULL DEFAULT 0 COMMENT '排序',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '备注',
  `click_num` bigint NULL DEFAULT 0 COMMENT '点击数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1628993782942859266 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '标签' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of lzh_tag
-- ----------------------------
INSERT INTO `lzh_tag` VALUES (1, 'Mybatis', NULL, NULL, 0, '2022-01-11 09:20:50', '2022-09-24 13:02:20', 213, 'weqwe', 432);
INSERT INTO `lzh_tag` VALUES (2, 'SpringSecurity', NULL, NULL, 0, '2022-01-11 09:20:55', '2022-01-11 09:20:55', 4, 'security framework', 13);
INSERT INTO `lzh_tag` VALUES (4, 'Java', NULL, NULL, 0, '2022-01-13 15:22:43', '2022-01-13 15:22:43', 1, 'sdad', 3);
INSERT INTO `lzh_tag` VALUES (5, 'WAD', NULL, NULL, 0, '2022-01-13 15:22:47', '2022-01-13 15:22:47', 73, 'ASDAD', 43);
INSERT INTO `lzh_tag` VALUES (6, 'C#', NULL, NULL, 0, '2022-01-11 09:20:50', '2023-02-23 09:55:15', 5, NULL, 435);
INSERT INTO `lzh_tag` VALUES (7, 'C++', NULL, NULL, 0, '2022-01-11 09:20:55', '2023-02-05 09:55:18', 2, NULL, 54);
INSERT INTO `lzh_tag` VALUES (9, 'Spring', NULL, NULL, 0, '2022-01-13 15:22:43', '2023-02-11 09:55:22', 331, NULL, 55);
INSERT INTO `lzh_tag` VALUES (10, 'SpringBoot', NULL, NULL, 0, '2022-01-13 15:22:47', '2022-09-24 13:02:20', 6, NULL, 5);
INSERT INTO `lzh_tag` VALUES (11, 'MybatisPlus', NULL, NULL, 0, '2022-01-11 09:20:50', '2022-01-11 09:20:55', 7, NULL, 7);
INSERT INTO `lzh_tag` VALUES (12, 'SpringMVC', NULL, NULL, 0, '2022-01-11 09:20:55', '2022-01-13 15:22:43', 8, NULL, 52);
INSERT INTO `lzh_tag` VALUES (13, 'RabbitMQ', NULL, NULL, 0, '2022-01-13 15:22:43', '2022-01-13 15:22:47', 4, NULL, 95);
INSERT INTO `lzh_tag` VALUES (14, 'Python', NULL, NULL, 0, '2022-01-13 15:22:47', '2023-02-23 09:55:15', 33, NULL, 12);
INSERT INTO `lzh_tag` VALUES (15, '机器学习', NULL, NULL, 1, '2022-01-13 15:22:43', '2023-02-05 09:55:18', 675, NULL, 2);
INSERT INTO `lzh_tag` VALUES (16, 'MyCat', NULL, NULL, 0, '2022-01-13 15:22:47', '2023-02-11 09:55:22', 29, NULL, 72);
INSERT INTO `lzh_tag` VALUES (1628584864840237058, 'RocketMQ', NULL, NULL, 0, '2022-01-13 15:22:47', '2023-02-23 10:41:53', 1, NULL, 0);
INSERT INTO `lzh_tag` VALUES (1628585912761864194, 'JDBC', NULL, NULL, 0, '2023-02-23 10:41:53', '2023-02-23 10:41:53', 12, NULL, 0);
INSERT INTO `lzh_tag` VALUES (1628585912761864195, 'JVM', NULL, NULL, 0, '2023-02-23 13:37:33', '2023-02-23 13:37:33', 0, NULL, 0);
INSERT INTO `lzh_tag` VALUES (1628585912761864196, 'JUC', NULL, NULL, 0, '2023-02-23 13:37:44', '2023-02-23 13:37:44', 0, NULL, 0);
INSERT INTO `lzh_tag` VALUES (1628585912761864197, 'MyBatis-Plus', NULL, NULL, 0, '2023-02-23 13:38:02', '2023-02-23 13:38:02', 0, NULL, 0);
INSERT INTO `lzh_tag` VALUES (1628993782942859265, 'Netty', NULL, NULL, 0, '2023-02-24 13:42:37', '2023-02-24 13:42:37', 0, NULL, 0);

-- ----------------------------
-- Table structure for lzh_user_like
-- ----------------------------
DROP TABLE IF EXISTS `lzh_user_like`;
CREATE TABLE `lzh_user_like`  (
  `id` bigint UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_id` bigint NOT NULL DEFAULT 0 COMMENT '用户id',
  `liked_id` bigint NOT NULL COMMENT '被点赞的id',
  `liked_status` int NOT NULL DEFAULT 0 COMMENT '点赞状态，0未点赞，1已点赞',
  `liked_type` int NOT NULL DEFAULT 0 COMMENT '点赞的类型',
  `liked_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '点赞时间',
  `del_flag` int NOT NULL DEFAULT 0 COMMENT '是否逻辑删除',
  `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uniq_user_id_liked_id_type`(`user_id`, `liked_id`, `liked_type`) USING BTREE,
  INDEX `idx_liked_id`(`liked_id`) USING BTREE,
  INDEX `idx_create_time`(`create_time`) USING BTREE,
  INDEX `idx_update_time`(`update_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1590214160973594625 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '用户点赞表' ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of lzh_user_like
-- ----------------------------
INSERT INTO `lzh_user_like` VALUES (1, 1, 1, 0, 0, '2022-10-11 09:57:01', 0, '2022-10-09 18:45:33', '2022-10-11 09:57:01');
INSERT INTO `lzh_user_like` VALUES (2, 2, 1, 0, 0, '2022-10-12 10:05:35', 0, '2022-10-09 18:45:48', '2022-10-12 10:05:35');
INSERT INTO `lzh_user_like` VALUES (1579111706137899009, 1, 3, 0, 0, '2023-02-02 14:13:14', 0, '2022-10-09 22:09:04', '2023-02-02 14:13:14');
INSERT INTO `lzh_user_like` VALUES (1579275791802482689, 1, 2, 0, 0, '2023-02-02 14:13:35', 0, '2022-10-10 09:01:05', '2023-02-02 14:13:35');
INSERT INTO `lzh_user_like` VALUES (1579667549912707073, 1, 5, 1, 0, '2023-02-02 14:13:17', 0, '2022-10-11 10:57:47', '2023-02-02 14:13:17');
INSERT INTO `lzh_user_like` VALUES (1579722585007190017, 1, 9, 1, 0, '2022-10-15 20:13:54', 0, '2022-10-11 14:36:29', '2022-10-15 20:13:54');
INSERT INTO `lzh_user_like` VALUES (1579745048109735938, 1, 1579031502224822274, 1, 0, '2022-10-19 10:56:47', 0, '2022-10-11 16:05:44', '2022-10-19 10:56:47');
INSERT INTO `lzh_user_like` VALUES (1579745123267469314, 1, 1578333695557947393, 1, 0, NULL, 0, '2022-10-11 16:06:02', '2022-10-11 16:06:02');
INSERT INTO `lzh_user_like` VALUES (1579745140183097346, 1, 1576527547464937474, 1, 0, '2023-02-02 14:13:24', 0, '2022-10-11 16:06:06', '2023-02-02 14:13:24');
INSERT INTO `lzh_user_like` VALUES (1579745155710410754, 1, 10, 1, 0, '2022-11-07 18:07:57', 0, '2022-10-11 16:06:10', '2022-11-07 18:07:57');
INSERT INTO `lzh_user_like` VALUES (1579745468429328386, 1, 1579730661248593922, 1, 0, '2022-10-25 14:01:14', 0, '2022-10-11 16:07:25', '2022-10-25 14:01:14');
INSERT INTO `lzh_user_like` VALUES (1579745506601689089, 1, 1579692483556806657, 1, 0, '2022-10-13 20:08:27', 0, '2022-10-11 16:07:34', '2022-10-13 20:08:27');
INSERT INTO `lzh_user_like` VALUES (1579745593662857218, 1, 8, 1, 0, '2022-11-07 18:59:16', 0, '2022-10-11 16:07:54', '2022-11-07 18:59:16');
INSERT INTO `lzh_user_like` VALUES (1579790537408516097, 1, 1576928390408253442, 1, 0, NULL, 0, '2022-10-11 19:06:30', '2022-10-11 19:06:30');
INSERT INTO `lzh_user_like` VALUES (1579791546608390145, 1, 1579034777426792450, 0, 0, '2022-10-13 20:09:42', 0, '2022-10-11 19:10:30', '2022-10-13 20:09:42');
INSERT INTO `lzh_user_like` VALUES (1579791562777432065, 1, 1579035117211553793, 1, 0, '2022-10-13 20:08:26', 0, '2022-10-11 19:10:34', '2022-10-13 20:08:26');
INSERT INTO `lzh_user_like` VALUES (1579798235864879105, 1, 1579798069829046273, 1, 0, '2022-10-12 09:09:39', 0, '2022-10-11 19:37:05', '2022-10-12 09:09:39');
INSERT INTO `lzh_user_like` VALUES (1579804568773185537, 1, 1579798362625134593, 1, 0, '2022-10-11 20:02:24', 0, '2022-10-11 20:02:15', '2022-10-11 20:02:24');
INSERT INTO `lzh_user_like` VALUES (1580004049552576513, 1, 1580003318506323970, 1, 0, '2022-10-15 20:15:34', 0, '2022-10-12 09:14:55', '2022-10-15 20:15:34');
INSERT INTO `lzh_user_like` VALUES (1580004071597838338, 1, 1580002217321168897, 1, 0, '2022-10-14 09:41:21', 0, '2022-10-12 09:15:00', '2022-10-14 09:41:21');
INSERT INTO `lzh_user_like` VALUES (1580012925089910786, 2, 2, 0, 0, '2022-10-23 19:00:46', 0, '2022-10-12 09:50:11', '2022-10-23 19:00:46');
INSERT INTO `lzh_user_like` VALUES (1580013004186095617, 2, 3, 1, 0, '2022-10-12 10:07:29', 0, '2022-10-12 09:50:30', '2022-10-12 10:07:29');
INSERT INTO `lzh_user_like` VALUES (1580013031918833666, 2, 9, 1, 0, NULL, 0, '2022-10-12 09:50:37', '2022-10-12 09:50:37');
INSERT INTO `lzh_user_like` VALUES (1580013051506233345, 2, 1580003318506323970, 1, 0, '2022-10-12 10:16:29', 0, '2022-10-12 09:50:41', '2022-10-12 10:16:29');
INSERT INTO `lzh_user_like` VALUES (1580015448714547201, 2, 5, 0, 0, '2022-10-12 10:00:13', 0, '2022-10-12 10:00:13', '2022-10-12 10:00:13');
INSERT INTO `lzh_user_like` VALUES (1580019538261692417, 2, 1580002217321168897, 1, 0, NULL, 0, '2022-10-12 10:16:28', '2022-10-12 10:16:28');
INSERT INTO `lzh_user_like` VALUES (1580019568947220481, 2, 1580001549915234305, 1, 0, NULL, 0, '2022-10-12 10:16:35', '2022-10-12 10:16:35');
INSERT INTO `lzh_user_like` VALUES (1580531358764257281, 1, 1580001549915234305, 1, 0, '2022-10-13 20:10:16', 0, '2022-10-13 20:10:15', '2022-10-13 20:10:16');
INSERT INTO `lzh_user_like` VALUES (1580746616984510465, 2, 8, 1, 0, NULL, 0, '2022-10-14 10:25:37', '2022-10-14 10:25:37');
INSERT INTO `lzh_user_like` VALUES (1580782373090566145, 1, 1580782348893626370, 1, 0, '2023-02-05 10:29:05', 0, '2022-10-14 12:47:42', '2023-02-05 10:29:05');
INSERT INTO `lzh_user_like` VALUES (1580873834318524418, 1578603364453953538, 2, 1, 0, NULL, 0, '2022-10-14 18:51:08', '2022-10-14 18:51:08');
INSERT INTO `lzh_user_like` VALUES (1580873843210448897, 1578603364453953538, 3, 1, 0, NULL, 0, '2022-10-14 18:51:10', '2022-10-14 18:51:10');
INSERT INTO `lzh_user_like` VALUES (1580874120554606594, 1578603364453953538, 1576527547464937474, 1, 0, NULL, 0, '2022-10-14 18:52:16', '2022-10-14 18:52:16');
INSERT INTO `lzh_user_like` VALUES (1580875315104968705, 1578603364453953538, 1580782348893626370, 1, 0, NULL, 0, '2022-10-14 18:57:01', '2022-10-14 18:57:01');
INSERT INTO `lzh_user_like` VALUES (1581248833512415233, 1, 1581248764574834689, 1, 0, '2022-10-25 13:20:34', 0, '2022-10-15 19:41:15', '2022-10-25 13:20:34');
INSERT INTO `lzh_user_like` VALUES (1581257072064991234, 1, 1580876557625585665, 1, 0, '2022-10-16 11:28:23', 0, '2022-10-15 20:13:59', '2022-10-16 11:28:23');
INSERT INTO `lzh_user_like` VALUES (1581523542518935554, 1, 1581523482204844033, 1, 0, '2022-10-16 14:08:48', 0, '2022-10-16 13:52:50', '2022-10-16 14:08:48');
INSERT INTO `lzh_user_like` VALUES (1584138931505602562, 2, 1581248764574834689, 1, 0, NULL, 0, '2022-10-23 19:05:28', '2022-10-23 19:05:28');
INSERT INTO `lzh_user_like` VALUES (1584138970034479106, 2, 1579035117211553793, 1, 0, NULL, 0, '2022-10-23 19:05:37', '2022-10-23 19:05:37');
INSERT INTO `lzh_user_like` VALUES (1584776966584807426, 1, 1581491547428610050, 0, 0, '2022-10-25 13:20:53', 0, '2022-10-25 13:20:47', '2022-10-25 13:20:53');
INSERT INTO `lzh_user_like` VALUES (1584795456507199490, 1, 1584795396985831425, 0, 0, '2022-10-25 14:34:35', 0, '2022-10-25 14:34:16', '2022-10-25 14:34:35');
INSERT INTO `lzh_user_like` VALUES (1589422798355304449, 1, 1589422745435770881, 0, 0, '2022-11-07 16:22:24', 0, '2022-11-07 09:01:40', '2022-11-07 16:22:24');
INSERT INTO `lzh_user_like` VALUES (1589533057421963266, 1, 1584804994513879042, 0, 0, '2022-11-07 16:19:48', 0, '2022-11-07 16:19:48', '2022-11-07 16:19:48');
INSERT INTO `lzh_user_like` VALUES (1589570248743358466, 1, 1589570183937167361, 1, 0, '2022-11-07 18:47:40', 0, '2022-11-07 18:47:35', '2022-11-07 18:47:40');
INSERT INTO `lzh_user_like` VALUES (1589571251983126530, 1, 1589570781973614594, 0, 0, '2022-11-07 18:51:35', 0, '2022-11-07 18:51:34', '2022-11-07 18:51:35');
INSERT INTO `lzh_user_like` VALUES (1589621467016921090, 1, 1589618524242935810, 0, 0, '2023-02-02 14:13:21', 0, '2022-11-07 22:11:06', '2023-02-02 14:13:21');
INSERT INTO `lzh_user_like` VALUES (1590214160973594625, 30, 2, 0, 0, '2022-11-09 13:26:16', 0, '2022-11-09 13:26:15', '2022-11-09 13:26:16');

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '菜单ID',
  `menu_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '菜单名称',
  `parent_id` bigint NULL DEFAULT 0 COMMENT '父菜单ID',
  `order_num` int NULL DEFAULT 0 COMMENT '显示顺序',
  `path` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '路由地址',
  `component` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '组件路径',
  `is_frame` int NULL DEFAULT 1 COMMENT '是否为外链（0是 1否）',
  `menu_type` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '菜单类型（M目录 C菜单 F按钮）',
  `visible` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',
  `status` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',
  `perms` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限标识',
  `icon` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '#' COMMENT '菜单图标',
  `create_by` bigint NULL DEFAULT NULL COMMENT '创建者',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint NULL DEFAULT NULL COMMENT '更新者',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '备注',
  `del_flag` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2034 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '菜单权限表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES (1, '系统管理', 0, 1, 'system', NULL, 1, 'M', '0', '0', '', 'system', 0, '2021-11-12 10:46:19', 0, NULL, '系统管理目录', '0');
INSERT INTO `sys_menu` VALUES (100, '用户管理', 1, 1, 'user', 'system/user/index', 1, 'C', '0', '0', 'system:user:list', 'user', 0, '2021-11-12 10:46:19', 1, '2022-07-31 15:47:58', '用户管理菜单', '0');
INSERT INTO `sys_menu` VALUES (101, '角色管理', 1, 2, 'role', 'system/role/index', 1, 'C', '0', '0', 'system:role:list', 'peoples', 0, '2021-11-12 10:46:19', 0, NULL, '角色管理菜单', '0');
INSERT INTO `sys_menu` VALUES (102, '菜单管理', 1, 3, 'menu', 'system/menu/index', 1, 'C', '0', '0', 'system:menu:list', 'tree-table', 0, '2021-11-12 10:46:19', 0, NULL, '菜单管理菜单', '0');
INSERT INTO `sys_menu` VALUES (1001, '用户查询', 100, 1, '', '', 1, 'F', '0', '0', 'system:user:query', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1002, '用户新增', 100, 2, '', '', 1, 'F', '0', '0', 'system:user:add', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1003, '用户修改', 100, 3, '', '', 1, 'F', '0', '0', 'system:user:edit', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1004, '用户删除', 100, 4, '', '', 1, 'F', '0', '0', 'system:user:remove', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1005, '用户导出', 100, 5, '', '', 1, 'F', '0', '0', 'system:user:export', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1006, '用户导入', 100, 6, '', '', 1, 'F', '0', '0', 'system:user:import', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1007, '重置密码', 100, 7, '', '', 1, 'F', '0', '0', 'system:user:resetPwd', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1008, '角色查询', 101, 1, '', '', 1, 'F', '0', '0', 'system:role:query', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1009, '角色新增', 101, 2, '', '', 1, 'F', '0', '0', 'system:role:add', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1010, '角色修改', 101, 3, '', '', 1, 'F', '0', '0', 'system:role:edit', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1011, '角色删除', 101, 4, '', '', 1, 'F', '0', '0', 'system:role:remove', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1012, '角色导出', 101, 5, '', '', 1, 'F', '0', '0', 'system:role:export', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1013, '菜单查询', 102, 1, '', '', 1, 'F', '0', '0', 'system:menu:query', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1014, '菜单新增', 102, 2, '', '', 1, 'F', '0', '0', 'system:menu:add', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1015, '菜单修改', 102, 3, '', '', 1, 'F', '0', '0', 'system:menu:edit', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1016, '菜单删除', 102, 4, '', '', 1, 'F', '0', '0', 'system:menu:remove', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (2017, '内容管理', 0, 4, 'content', NULL, 1, 'M', '0', '0', NULL, 'table', NULL, '2022-01-08 02:44:38', 1, '2022-07-31 12:34:23', '', '0');
INSERT INTO `sys_menu` VALUES (2018, '分类管理', 2017, 1, 'category', 'content/category/index', 1, 'C', '0', '0', 'content:category:list', 'example', NULL, '2022-01-08 02:51:45', NULL, '2022-01-08 02:51:45', '', '0');
INSERT INTO `sys_menu` VALUES (2019, '文章管理', 2017, 0, 'article', 'content/article/index', 1, 'C', '0', '0', 'content:article:list', 'build', NULL, '2022-01-08 02:53:10', NULL, '2022-01-08 02:53:10', '', '0');
INSERT INTO `sys_menu` VALUES (2021, '标签管理', 2017, 6, 'tag', 'content/tag/index', 1, 'C', '0', '0', 'content:tag:index', 'button', NULL, '2022-01-08 02:55:37', NULL, '2022-01-08 02:55:50', '', '0');
INSERT INTO `sys_menu` VALUES (2022, '友链管理', 2017, 4, 'link', 'content/link/index', 1, 'C', '0', '0', 'content:link:list', '404', NULL, '2022-01-08 02:56:50', NULL, '2022-01-08 02:56:50', '', '0');
INSERT INTO `sys_menu` VALUES (2023, '写博文', 0, 0, 'write', 'content/article/write/index', 1, 'C', '0', '0', 'content:article:writer', 'build', NULL, '2022-01-08 03:39:58', 1, '2022-07-31 22:07:05', '', '0');
INSERT INTO `sys_menu` VALUES (2024, '友链新增', 2022, 0, '', NULL, 1, 'F', '0', '0', 'content:link:add', '#', NULL, '2022-01-16 07:59:17', NULL, '2022-01-16 07:59:17', '', '0');
INSERT INTO `sys_menu` VALUES (2025, '友链修改', 2022, 1, '', NULL, 1, 'F', '0', '0', 'content:link:edit', '#', NULL, '2022-01-16 07:59:44', NULL, '2022-01-16 07:59:44', '', '0');
INSERT INTO `sys_menu` VALUES (2026, '友链删除', 2022, 1, '', NULL, 1, 'F', '0', '0', 'content:link:remove', '#', NULL, '2022-01-16 08:00:05', NULL, '2022-01-16 08:00:05', '', '0');
INSERT INTO `sys_menu` VALUES (2027, '友链查询', 2022, 2, '', NULL, 1, 'F', '0', '0', 'content:link:query', '#', NULL, '2022-01-16 08:04:09', NULL, '2022-01-16 08:04:09', '', '0');
INSERT INTO `sys_menu` VALUES (2028, '导出分类', 2018, 1, '', NULL, 1, 'F', '0', '0', 'content:category:export', '#', NULL, '2022-01-21 07:06:59', NULL, '2022-01-21 07:06:59', '', '0');

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色名称',
  `role_key` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色权限字符串',
  `role_sort` int NOT NULL COMMENT '显示顺序',
  `status` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色状态（0正常 1停用）',
  `del_flag` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '删除标志（0代表存在 1代表删除）',
  `create_by` bigint NULL DEFAULT NULL COMMENT '创建者',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint NULL DEFAULT NULL COMMENT '更新者',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色信息表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (1, '超级管理员', 'admin', 1, '0', '0', 0, '2021-11-12 10:46:19', 0, NULL, '超级管理员');
INSERT INTO `sys_role` VALUES (2, '普通角色', 'common', 2, '0', '0', 0, '2021-11-12 10:46:19', 0, '2022-01-01 22:32:58', '普通角色');
INSERT INTO `sys_role` VALUES (11, '嘎嘎嘎', 'aggag', 5, '0', '0', NULL, '2022-01-06 14:07:40', NULL, '2022-01-07 03:48:48', '嘎嘎嘎');
INSERT INTO `sys_role` VALUES (12, '友链审核员', 'link', 1, '0', '0', NULL, '2022-01-16 06:49:30', NULL, '2022-01-16 08:05:09', NULL);

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `role_id` bigint NOT NULL COMMENT '角色ID',
  `menu_id` bigint NOT NULL COMMENT '菜单ID',
  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色和菜单关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES (0, 0);
INSERT INTO `sys_role_menu` VALUES (1, 1);
INSERT INTO `sys_role_menu` VALUES (1, 101);
INSERT INTO `sys_role_menu` VALUES (2, 1);
INSERT INTO `sys_role_menu` VALUES (2, 102);
INSERT INTO `sys_role_menu` VALUES (2, 1013);
INSERT INTO `sys_role_menu` VALUES (2, 1014);
INSERT INTO `sys_role_menu` VALUES (2, 1015);
INSERT INTO `sys_role_menu` VALUES (2, 1016);
INSERT INTO `sys_role_menu` VALUES (2, 2000);
INSERT INTO `sys_role_menu` VALUES (3, 2);
INSERT INTO `sys_role_menu` VALUES (3, 3);
INSERT INTO `sys_role_menu` VALUES (3, 4);
INSERT INTO `sys_role_menu` VALUES (3, 100);
INSERT INTO `sys_role_menu` VALUES (3, 101);
INSERT INTO `sys_role_menu` VALUES (3, 103);
INSERT INTO `sys_role_menu` VALUES (3, 104);
INSERT INTO `sys_role_menu` VALUES (3, 105);
INSERT INTO `sys_role_menu` VALUES (3, 106);
INSERT INTO `sys_role_menu` VALUES (3, 107);
INSERT INTO `sys_role_menu` VALUES (3, 108);
INSERT INTO `sys_role_menu` VALUES (3, 109);
INSERT INTO `sys_role_menu` VALUES (3, 110);
INSERT INTO `sys_role_menu` VALUES (3, 111);
INSERT INTO `sys_role_menu` VALUES (3, 112);
INSERT INTO `sys_role_menu` VALUES (3, 113);
INSERT INTO `sys_role_menu` VALUES (3, 114);
INSERT INTO `sys_role_menu` VALUES (3, 115);
INSERT INTO `sys_role_menu` VALUES (3, 116);
INSERT INTO `sys_role_menu` VALUES (3, 500);
INSERT INTO `sys_role_menu` VALUES (3, 501);
INSERT INTO `sys_role_menu` VALUES (3, 1001);
INSERT INTO `sys_role_menu` VALUES (3, 1002);
INSERT INTO `sys_role_menu` VALUES (3, 1003);
INSERT INTO `sys_role_menu` VALUES (3, 1004);
INSERT INTO `sys_role_menu` VALUES (3, 1005);
INSERT INTO `sys_role_menu` VALUES (3, 1006);
INSERT INTO `sys_role_menu` VALUES (3, 1007);
INSERT INTO `sys_role_menu` VALUES (3, 1008);
INSERT INTO `sys_role_menu` VALUES (3, 1009);
INSERT INTO `sys_role_menu` VALUES (3, 1010);
INSERT INTO `sys_role_menu` VALUES (3, 1011);
INSERT INTO `sys_role_menu` VALUES (3, 1012);
INSERT INTO `sys_role_menu` VALUES (3, 1017);
INSERT INTO `sys_role_menu` VALUES (3, 1018);
INSERT INTO `sys_role_menu` VALUES (3, 1019);
INSERT INTO `sys_role_menu` VALUES (3, 1020);
INSERT INTO `sys_role_menu` VALUES (3, 1021);
INSERT INTO `sys_role_menu` VALUES (3, 1022);
INSERT INTO `sys_role_menu` VALUES (3, 1023);
INSERT INTO `sys_role_menu` VALUES (3, 1024);
INSERT INTO `sys_role_menu` VALUES (3, 1025);
INSERT INTO `sys_role_menu` VALUES (3, 1026);
INSERT INTO `sys_role_menu` VALUES (3, 1027);
INSERT INTO `sys_role_menu` VALUES (3, 1028);
INSERT INTO `sys_role_menu` VALUES (3, 1029);
INSERT INTO `sys_role_menu` VALUES (3, 1030);
INSERT INTO `sys_role_menu` VALUES (3, 1031);
INSERT INTO `sys_role_menu` VALUES (3, 1032);
INSERT INTO `sys_role_menu` VALUES (3, 1033);
INSERT INTO `sys_role_menu` VALUES (3, 1034);
INSERT INTO `sys_role_menu` VALUES (3, 1035);
INSERT INTO `sys_role_menu` VALUES (3, 1036);
INSERT INTO `sys_role_menu` VALUES (3, 1037);
INSERT INTO `sys_role_menu` VALUES (3, 1038);
INSERT INTO `sys_role_menu` VALUES (3, 1039);
INSERT INTO `sys_role_menu` VALUES (3, 1040);
INSERT INTO `sys_role_menu` VALUES (3, 1041);
INSERT INTO `sys_role_menu` VALUES (3, 1042);
INSERT INTO `sys_role_menu` VALUES (3, 1043);
INSERT INTO `sys_role_menu` VALUES (3, 1044);
INSERT INTO `sys_role_menu` VALUES (3, 1045);
INSERT INTO `sys_role_menu` VALUES (3, 1046);
INSERT INTO `sys_role_menu` VALUES (3, 1047);
INSERT INTO `sys_role_menu` VALUES (3, 1048);
INSERT INTO `sys_role_menu` VALUES (3, 1049);
INSERT INTO `sys_role_menu` VALUES (3, 1050);
INSERT INTO `sys_role_menu` VALUES (3, 1051);
INSERT INTO `sys_role_menu` VALUES (3, 1052);
INSERT INTO `sys_role_menu` VALUES (3, 1053);
INSERT INTO `sys_role_menu` VALUES (3, 1054);
INSERT INTO `sys_role_menu` VALUES (3, 1055);
INSERT INTO `sys_role_menu` VALUES (3, 1056);
INSERT INTO `sys_role_menu` VALUES (3, 1057);
INSERT INTO `sys_role_menu` VALUES (3, 1058);
INSERT INTO `sys_role_menu` VALUES (3, 1059);
INSERT INTO `sys_role_menu` VALUES (3, 1060);
INSERT INTO `sys_role_menu` VALUES (3, 2000);
INSERT INTO `sys_role_menu` VALUES (11, 1);
INSERT INTO `sys_role_menu` VALUES (11, 100);
INSERT INTO `sys_role_menu` VALUES (11, 101);
INSERT INTO `sys_role_menu` VALUES (11, 102);
INSERT INTO `sys_role_menu` VALUES (11, 103);
INSERT INTO `sys_role_menu` VALUES (11, 104);
INSERT INTO `sys_role_menu` VALUES (11, 105);
INSERT INTO `sys_role_menu` VALUES (11, 106);
INSERT INTO `sys_role_menu` VALUES (11, 107);
INSERT INTO `sys_role_menu` VALUES (11, 108);
INSERT INTO `sys_role_menu` VALUES (11, 500);
INSERT INTO `sys_role_menu` VALUES (11, 501);
INSERT INTO `sys_role_menu` VALUES (11, 1001);
INSERT INTO `sys_role_menu` VALUES (11, 1002);
INSERT INTO `sys_role_menu` VALUES (11, 1003);
INSERT INTO `sys_role_menu` VALUES (11, 1004);
INSERT INTO `sys_role_menu` VALUES (11, 1005);
INSERT INTO `sys_role_menu` VALUES (11, 1006);
INSERT INTO `sys_role_menu` VALUES (11, 1007);
INSERT INTO `sys_role_menu` VALUES (11, 1008);
INSERT INTO `sys_role_menu` VALUES (11, 1009);
INSERT INTO `sys_role_menu` VALUES (11, 1010);
INSERT INTO `sys_role_menu` VALUES (11, 1011);
INSERT INTO `sys_role_menu` VALUES (11, 1012);
INSERT INTO `sys_role_menu` VALUES (11, 1013);
INSERT INTO `sys_role_menu` VALUES (11, 1014);
INSERT INTO `sys_role_menu` VALUES (11, 1015);
INSERT INTO `sys_role_menu` VALUES (11, 1016);
INSERT INTO `sys_role_menu` VALUES (11, 1017);
INSERT INTO `sys_role_menu` VALUES (11, 1018);
INSERT INTO `sys_role_menu` VALUES (11, 1019);
INSERT INTO `sys_role_menu` VALUES (11, 1020);
INSERT INTO `sys_role_menu` VALUES (11, 1021);
INSERT INTO `sys_role_menu` VALUES (11, 1022);
INSERT INTO `sys_role_menu` VALUES (11, 1023);
INSERT INTO `sys_role_menu` VALUES (11, 1024);
INSERT INTO `sys_role_menu` VALUES (11, 1025);
INSERT INTO `sys_role_menu` VALUES (11, 1026);
INSERT INTO `sys_role_menu` VALUES (11, 1027);
INSERT INTO `sys_role_menu` VALUES (11, 1028);
INSERT INTO `sys_role_menu` VALUES (11, 1029);
INSERT INTO `sys_role_menu` VALUES (11, 1030);
INSERT INTO `sys_role_menu` VALUES (11, 1031);
INSERT INTO `sys_role_menu` VALUES (11, 1032);
INSERT INTO `sys_role_menu` VALUES (11, 1033);
INSERT INTO `sys_role_menu` VALUES (11, 1034);
INSERT INTO `sys_role_menu` VALUES (11, 1035);
INSERT INTO `sys_role_menu` VALUES (11, 1036);
INSERT INTO `sys_role_menu` VALUES (11, 1037);
INSERT INTO `sys_role_menu` VALUES (11, 1038);
INSERT INTO `sys_role_menu` VALUES (11, 1039);
INSERT INTO `sys_role_menu` VALUES (11, 1040);
INSERT INTO `sys_role_menu` VALUES (11, 1041);
INSERT INTO `sys_role_menu` VALUES (11, 1042);
INSERT INTO `sys_role_menu` VALUES (11, 1043);
INSERT INTO `sys_role_menu` VALUES (11, 1044);
INSERT INTO `sys_role_menu` VALUES (11, 1045);
INSERT INTO `sys_role_menu` VALUES (11, 2000);
INSERT INTO `sys_role_menu` VALUES (11, 2003);
INSERT INTO `sys_role_menu` VALUES (11, 2004);
INSERT INTO `sys_role_menu` VALUES (11, 2005);
INSERT INTO `sys_role_menu` VALUES (11, 2006);
INSERT INTO `sys_role_menu` VALUES (11, 2007);
INSERT INTO `sys_role_menu` VALUES (11, 2008);
INSERT INTO `sys_role_menu` VALUES (11, 2009);
INSERT INTO `sys_role_menu` VALUES (11, 2010);
INSERT INTO `sys_role_menu` VALUES (11, 2011);
INSERT INTO `sys_role_menu` VALUES (11, 2012);
INSERT INTO `sys_role_menu` VALUES (11, 2013);
INSERT INTO `sys_role_menu` VALUES (11, 2014);
INSERT INTO `sys_role_menu` VALUES (12, 2017);
INSERT INTO `sys_role_menu` VALUES (12, 2022);
INSERT INTO `sys_role_menu` VALUES (12, 2024);
INSERT INTO `sys_role_menu` VALUES (12, 2025);
INSERT INTO `sys_role_menu` VALUES (12, 2026);
INSERT INTO `sys_role_menu` VALUES (12, 2027);

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'NULL' COMMENT '用户名',
  `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'NULL' COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'NULL' COMMENT '密码',
  `type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '用户类型：0代表普通用户，1代表管理员',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '账号状态（0正常 1停用）',
  `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `phonenumber` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '手机号',
  `sex` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',
  `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '地址',
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '备注',
  `avatar` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '头像',
  `create_by` bigint NULL DEFAULT NULL COMMENT '创建人的用户id',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint NULL DEFAULT NULL COMMENT '更新人',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `del_flag` int NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1579691106277396483 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (1, 'lzh', '声声慢', '$2a$10$9UcCIUI49qExTid8xCF/2OPTv4vqwjN9OYHEfdtTcBwVIAM4BHsoS', '1', '0', '1203464373@qq.com', '13175932620', '0', '浙江省宁波市海曙区', 'PERSEVERE-BLOG\nWELCOME TO MY BLOG\nNever forget why you started!', 'http://1.117.218.230:9000/test/nbufe.jpg', NULL, '2022-01-05 09:01:56', 1, '2023-02-02 14:45:35', 0);
INSERT INTO `sys_user` VALUES (2, 'lisi', 'xiaoli', '$2a$10$MaFiiwNV45glvPXYVlRt5.kMatuYD/mLzSAirVwZThZnKU.CjxcLC', '0', '0', 'weixin@qq.com', '12312341234', '0', '浙江宁波', 'Never forget why you started!', 'https://img1.baidu.com/it/u=1659441821,1293635445&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', -1, '2022-01-30 17:18:44', -1, '2022-01-30 17:18:44', 0);
INSERT INTO `sys_user` VALUES (3, 'zhangming', 'zhangming', '$2a$10$MaFiiwNV45glvPXYVlRt5.kMatuYD/mLzSAirVwZThZnKU.CjxcLC', '0', '0', NULL, NULL, '0', '浙江宁波', 'Never forget why you started!', 'https://img0.baidu.com/it/u=825023390,3429989944&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', NULL, NULL, NULL, NULL, 0);
INSERT INTO `sys_user` VALUES (10, 'lihua', 'lihua', '$2a$10$MaFiiwNV45glvPXYVlRt5.kMatuYD/mLzSAirVwZThZnKU.CjxcLC', '0', '0', NULL, NULL, '0', '浙江宁波', 'Never forget why you started!', 'https://img0.baidu.com/it/u=825023390,3429989944&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', NULL, NULL, NULL, NULL, 0);
INSERT INTO `sys_user` VALUES (11, 'xiaoming', 'xiaoming', '$2a$10$ffgpMr04F4lOfs.Q86W88.4/sURUoXYOaw3NfhFfG/2111bKCkTre', '0', '0', 'l13758395941@163.com', NULL, '1', '浙江宁波', 'Never forget why you started!', 'https://img0.baidu.com/it/u=825023390,3429989944&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', NULL, '2022-10-03 20:23:29', NULL, '2022-10-03 20:23:29', 0);
INSERT INTO `sys_user` VALUES (20, 'lihong', '李红', '$2a$10$MaFiiwNV45glvPXYVlRt5.kMatuYD/mLzSAirVwZThZnKU.CjxcLC', '0', '0', NULL, NULL, '1', '浙江宁波', 'Never forget why you started!', 'https://img1.baidu.com/it/u=592570905,1313515675&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', NULL, NULL, NULL, '2022-10-23 19:46:12', 0);
INSERT INTO `sys_user` VALUES (22, 'liming', 'liming', '$2a$10$MaFiiwNV45glvPXYVlRt5.kMatuYD/mLzSAirVwZThZnKU.CjxcLC', '0', '0', NULL, NULL, '1', '浙江宁波', 'Never forget why you started!', 'https://img1.baidu.com/it/u=1659441821,1293635445&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', NULL, NULL, NULL, NULL, 0);
INSERT INTO `sys_user` VALUES (24, 'wangwu', 'wangwu', '$2a$10$MaFiiwNV45glvPXYVlRt5.kMatuYD/mLzSAirVwZThZnKU.CjxcLC', '0', '0', NULL, NULL, '1', '浙江宁波', 'Never forget why you started!', 'https://img0.baidu.com/it/u=825023390,3429989944&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', NULL, NULL, NULL, NULL, 0);
INSERT INTO `sys_user` VALUES (29, 'tom', 'tom', '$2a$10$MaFiiwNV45glvPXYVlRt5.kMatuYD/mLzSAirVwZThZnKU.CjxcLC', '0', '0', NULL, NULL, '1', '浙江宁波', 'Never forget why you started!', 'https://img0.baidu.com/it/u=3596636266,3550539430&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', NULL, NULL, NULL, NULL, 0);
INSERT INTO `sys_user` VALUES (30, 'zhangsan', 'zhangsan', '$2a$10$MaFiiwNV45glvPXYVlRt5.kMatuYD/mLzSAirVwZThZnKU.CjxcLC', '0', '0', '1203464373@qq.com', NULL, '1', '浙江宁波', 'Never forget why you started!', 'https://img0.baidu.com/it/u=825023390,3429989944&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', NULL, NULL, NULL, '2022-10-25 20:06:53', 0);
INSERT INTO `sys_user` VALUES (14787164048662, 'tony', 'tony', '$2a$10$MaFiiwNV45glvPXYVlRt5.kMatuYD/mLzSAirVwZThZnKU.CjxcLC', '0', '0', NULL, NULL, '0', '浙江宁波', 'Never forget why you started!', 'https://img1.baidu.com/it/u=1817915659,804553856&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', NULL, NULL, NULL, NULL, 0);
INSERT INTO `sys_user` VALUES (1578603364453953538, 'rootjx', '泰迪', '$2a$10$f/ezuRT7RKuXkgCzlfIONOVy2Pr/SsJLKzq5yCjJX99PbgzqAPYM2', '0', '0', '1048341117@qq.com', NULL, '0', '浙江宁波', 'Never forget why you started!', 'http://rir6wdlzn.hd-bkt.clouddn.com/2022/10/14/e6cbc23109fb48f69bc26aec04ddfb1c.jpg', NULL, '2022-10-08 12:29:06', NULL, '2022-10-14 18:58:54', 0);
INSERT INTO `sys_user` VALUES (1579691106277396482, 'szh', 'szh', '$2a$10$osnK6crabirQl.tTHXjUBO69kS8O7OrFWBC1YfRFmxbCuQ6OppwtG', '0', '0', '3032388097@qq.com', NULL, '0', '浙江宁波', 'Never forget why you started!', 'http://rir6wdlzn.hd-bkt.clouddn.com/2022/10/15/4f5ed2aaaa454e659cb45d3c80fc88a1.jpg', NULL, '2022-10-11 12:31:24', NULL, '2022-10-15 16:17:22', 0);

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role`  (
  `user_id` bigint NOT NULL COMMENT '用户ID',
  `role_id` bigint NOT NULL COMMENT '角色ID',
  PRIMARY KEY (`user_id`, `role_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户和角色关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES (1, 1);
INSERT INTO `sys_user_role` VALUES (2, 2);
INSERT INTO `sys_user_role` VALUES (5, 2);
INSERT INTO `sys_user_role` VALUES (6, 12);

SET FOREIGN_KEY_CHECKS = 1;
